<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>可打印流 | Shawshank</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">可打印流</h1><a id="logo" href="/.">Shawshank</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">可打印流</h1><div class="post-meta">Oct 3, 2016</div><div class="post-content"><h2 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a>PrintStream</h2><p>这个流类提供了大量 print 类方法，用来将数据以 字符串 形式打印出来。注意这里的打印:</p>
<ul>
<li><p>输出到屏幕上</p>
<p>  例如 使用 System.out.println(); 其中的 out 变量就是 PrintStream 的一个实例。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意到这几个变量都是 final 类型的</span></span><br><span class="line"><span class="comment">// 并且，其初始化值都被设置成 null</span></span><br><span class="line"><span class="comment">// 所以为了不违反 java 的 final 关键词的语义</span></span><br><span class="line"><span class="comment">// 对于这三个变量的 set 方法，提供了 native 的实现，</span></span><br><span class="line"><span class="comment">// 即 setIn0, setOut0, setErr0</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> InputStream in = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> PrintStream out = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> PrintStream err = <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// FileDescriptor.in, FileDescriptor.out 为系统预定义的文件描述符</span></span><br><span class="line"><span class="comment">// 表示标准输出，标准输入。</span></span><br><span class="line">FileInputStream fdIn = <span class="keyword">new</span> FileInputStream(FileDescriptor.in);</span><br><span class="line">FileOutputStream fdOut = <span class="keyword">new</span> FileOutputStream(FileDescriptor.out);</span><br><span class="line">FileOutputStream fdErr = <span class="keyword">new</span> FileOutputStream(FileDescriptor.err);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对应的 PrintStream 流。</span></span><br><span class="line">setIn0(<span class="keyword">new</span> BufferedInputStream(fdIn));</span><br><span class="line">setOut0(<span class="keyword">new</span> PrintStream(<span class="keyword">new</span> BufferedOutputStream(fdOut, <span class="number">128</span>), <span class="keyword">true</span>));</span><br><span class="line">setErr0(<span class="keyword">new</span> PrintStream(<span class="keyword">new</span> BufferedOutputStream(fdErr, <span class="number">128</span>), <span class="keyword">true</span>));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>setOut0 的实现如下：

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// System.c</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_java_lang_System_setOut0(JNIEnv *env, jclass cla, jobject stream)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 获得 System.out 的 fieldId</span></span><br><span class="line">    jfieldID fid =</span><br><span class="line">        (*env)-&gt;GetStaticFieldID(env,cla,<span class="string">"out"</span>,<span class="string">"Ljava/io/PrintStream;"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fid == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置 out 字段的值为 stream</span></span><br><span class="line">    (*env)-&gt;SetStaticObjectField(env,cla,fid,stream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>输出到文件中</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(filename);</span><br><span class="line">PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="keyword">new</span> BufferedOutputStream(fos), <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>这里 ps 的 print 方法调用，会将数据输出到 filename 命名的文件中去。
</code></pre><ul>
<li><p>输出到内存中</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">PrintStream ps = <span class="keyword">new</span> PrintStream(bos);</span><br><span class="line">ps.println(<span class="string">"你好"</span>);</span><br><span class="line">ps.println(<span class="number">7892</span>);</span><br><span class="line">ps.print(<span class="number">434.22</span>);</span><br><span class="line">System.out.println(bos.toString());</span><br></pre></td></tr></table></figure>
<p>  这里的 ps 将数据输出到 bos 所拥有的字节数组中。</p>
</li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>PrintStream 提供了许多构造函数，最终都是使用下面的两个，来完成构造过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> BufferedWriter textOut;</span><br><span class="line"><span class="keyword">private</span> OutputStreamWriter charOut;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private constructors */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">PrintStream</span><span class="params">(<span class="keyword">boolean</span> autoFlush, OutputStream out)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(out);</span><br><span class="line">    <span class="keyword">this</span>.autoFlush = autoFlush;</span><br><span class="line">    <span class="keyword">this</span>.charOut = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.textOut = <span class="keyword">new</span> BufferedWriter(charOut);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">PrintStream</span><span class="params">(<span class="keyword">boolean</span> autoFlush, OutputStream out, Charset charset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(out);</span><br><span class="line">    <span class="keyword">this</span>.autoFlush = autoFlush;</span><br><span class="line">    <span class="keyword">this</span>.charOut = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">this</span>, charset);</span><br><span class="line">    <span class="keyword">this</span>.textOut = <span class="keyword">new</span> BufferedWriter(charOut);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类的实现过程，如下：</p>
<ol>
<li><p>PrintStream 类的 print 系列方法，将原生数据类型转换成 String 类型。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">       write(String.valueOf(l));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>PrintStream 的 print 方法将调用其 write 方法</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            textOut.write(s);</span><br><span class="line">            textOut.flushBuffer();</span><br><span class="line">            charOut.flushBuffer();</span><br><span class="line">            <span class="keyword">if</span> (autoFlush &amp;&amp; (s.indexOf(<span class="string">'\n'</span>) &gt;= <span class="number">0</span>))</span><br><span class="line">                out.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        trouble = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>BufferedWriter 调用 write, 使写入的过程带有缓冲功能，同时将 String 转换成 char 数组</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">flushBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">       ensureOpen();</span><br><span class="line">       <span class="keyword">if</span> (nextChar == <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       out.write(cb, <span class="number">0</span>, nextChar);</span><br><span class="line">       nextChar = <span class="number">0</span>;</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>BufferedWriter 内部持有 OutputStreamWriter </p>
<p> 当 BufferedWriter 调用上面的 flushBuffer 时，将调用 OutputStreamWriter 的 write 方法。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    se.write(cbuf, off, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用 StreamEncoder 对 char[] 进行编码，将编码后的字节写入目的Stream中。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// out 参数是流最终目标，可能是 </span></span><br><span class="line"><span class="comment">// 文件: FileOutputStream</span></span><br><span class="line"><span class="comment">// 内存: ByteArrayOutputStream</span></span><br><span class="line"><span class="comment">// 等等。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OutputStreamWriter</span><span class="params">(OutputStream out, String charsetName)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(out);</span><br><span class="line">       <span class="keyword">if</span> (charsetName == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"charsetName"</span>);</span><br><span class="line">	<span class="comment">// se 持有 out, 最终 se 将接受 char 数组</span></span><br><span class="line">	<span class="comment">// 将 char 数组，以 charsetName 的字符集进行编码成字节流</span></span><br><span class="line">	<span class="comment">// 写入到 out 中。</span></span><br><span class="line">       se = StreamEncoder.forOutputStreamWriter(out, <span class="keyword">this</span>, charsetName);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p> 这就是一个编码转换的过程 对于待写入的数据 char[] cbuf 来说，其本身是 UTF-16BE 格式的编码，现在需要写入目标流中，因为 utf-16BE 是 JVM 自身用来存储字符数据的编码格式，所以需要将这种编码格式的数据重新进行编码（Encoder）然后输出到输出流 out 中。那么新的编码格式如何获取呢？可以看看 StreamEncoder.forOutputStreamWriter 的实现。</p>
</li>
</ol>
<h3 id="StreamEncoder-类的实现"><a href="#StreamEncoder-类的实现" class="headerlink" title="StreamEncoder 类的实现"></a>StreamEncoder 类的实现</h3><p>注意这个类所在的包是 sun.nio.cs 所以 jdk 文档中并没有这个类的信息，可以参考 openjdk 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamEncoder</span> <span class="keyword">extends</span> <span class="title">Writer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Charset cs;</span><br><span class="line">	<span class="comment">// 将由 Charset.newEncoder() 来初始化</span></span><br><span class="line">    <span class="keyword">private</span> CharsetEncoder encoder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Factories for java.io.OutputStreamWriter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StreamEncoder <span class="title">forOutputStreamWriter</span><span class="params">(OutputStream out,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      Object lock,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String charsetName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String csn = charsetName;</span><br><span class="line">        <span class="keyword">if</span> (csn == <span class="keyword">null</span>)</span><br><span class="line">			<span class="comment">// 如果没有传递 charsetName 则使用 JVM 默认的 字符集。</span></span><br><span class="line">            csn = Charset.defaultCharset().name();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (Charset.isSupported(csn))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> StreamEncoder(out, lock, Charset.forName(csn));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalCharsetNameException x) &#123; &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedEncodingException (csn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StreamEncoder</span><span class="params">(OutputStream out, Object lock, Charset cs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(out, lock,</span><br><span class="line">         cs.newEncoder() <span class="comment">// 这里调用 cs.newEncoder() 创建encoder</span></span><br><span class="line">         .onMalformedInput(CodingErrorAction.REPLACE)</span><br><span class="line">         .onUnmappableCharacter(CodingErrorAction.REPLACE));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StreamEncoder 类继承自 Writer， 所以它有 writer 方法，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> ByteBuffer bb;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">		<span class="comment">// 参数检查</span></span><br><span class="line">        <span class="keyword">if</span> ((off &lt; <span class="number">0</span>) || (off &gt; cbuf.length) || (len &lt; <span class="number">0</span>) ||</span><br><span class="line">            ((off + len) &gt; cbuf.length) || ((off + len) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 调用具体的实现</span></span><br><span class="line">        implWrite(cbuf, off, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">implWrite</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CharBuffer cb = CharBuffer.wrap(cbuf, off, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (haveLeftoverChar)</span><br><span class="line">    flushLeftoverChar(cb, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cb.hasRemaining()) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 实现的关键，使用 encoder 的  encode 方法对 cb 中的 char 进行</span></span><br><span class="line">	<span class="comment">// 编码，编码成 encoder 所代表的字符集的字节数据，放到 bb 中</span></span><br><span class="line">	<span class="comment">// bb 是全局变量 ByteBuffer bb;</span></span><br><span class="line">    CoderResult cr = encoder.encode(cb, bb, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cr.isUnderflow()) &#123;</span><br><span class="line">       <span class="keyword">assert</span> (cb.remaining() &lt;= <span class="number">1</span>) : cb.remaining();</span><br><span class="line">       <span class="keyword">if</span> (cb.remaining() == <span class="number">1</span>) &#123;</span><br><span class="line">            haveLeftoverChar = <span class="keyword">true</span>;</span><br><span class="line">            leftoverChar = cb.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cr.isOverflow()) &#123;</span><br><span class="line">        <span class="keyword">assert</span> bb.position() &gt; <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 数据已经解码成功，放置到 bb 当中。</span></span><br><span class="line">		<span class="comment">// 调用 writeBytes 将 bb 当中的数据写入到底层的流中</span></span><br><span class="line">		<span class="comment">// 释放 bb 的空间，然后，继续进行编码剩余的数据。</span></span><br><span class="line">        writeBytes();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cr.throwException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeBytes</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    bb.flip();</span><br><span class="line">    <span class="keyword">int</span> lim = bb.limit();</span><br><span class="line">    <span class="keyword">int</span> pos = bb.position();</span><br><span class="line">    <span class="keyword">assert</span> (pos &lt;= lim);</span><br><span class="line">    <span class="keyword">int</span> rem = (pos &lt;= lim ? lim - pos : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rem &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ch != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch.write(bb) != rem)</span><br><span class="line">            <span class="keyword">assert</span> <span class="keyword">false</span> : rem;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 写入到底层的流中，</span></span><br><span class="line">		<span class="comment">// out 可能是 FileOutputStream， </span></span><br><span class="line">		<span class="comment">// ByteArrayOutputStream 等等。</span></span><br><span class="line">        out.write(bb.array(), bb.arrayOffset() + pos, rem);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bb.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a>PrintWriter</h2><p>这个类的实现和 PrintStream 非常相似</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintWriter</span> <span class="keyword">extends</span> <span class="title">Writer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(OutputStream out, <span class="keyword">boolean</span> autoFlush)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">this</span>(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(out)), autoFlush);</span><br><span class="line">	</span><br><span class="line">	    <span class="comment">// save print stream for error propagation</span></span><br><span class="line">	    <span class="keyword">if</span> (out <span class="keyword">instanceof</span> java.io.PrintStream) &#123;</span><br><span class="line">	        psOut = (PrintStream) out;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(file))),</span><br><span class="line">             <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file)) 最终使用这个 Writer 入流中写入数据。</p>
<p>需要注意的是： PrintStream类有两个可以直接写入字节数据的方法：</p>
<ul>
<li>write(byte[] buf, int off, int len)</li>
<li>write(int b)</li>
</ul>
<p>在 PrintStream 的实现中，这两个方法都是直接将原始的字节数据写入到底层的流中，而没有进行编码操作。</p>
<p>在 PrintWriter 中，对应的有</p>
<ul>
<li>write(int c)</li>
</ul>
<p>这个方法会将 c 进行转码操作，然后写入底层流中。</p>
<h2 id="多字节字符编码，解码"><a href="#多字节字符编码，解码" class="headerlink" title="多字节字符编码，解码"></a>多字节字符编码，解码</h2><p>UTF-16 和 UTF-8, UTF-32 存在直接的映射关系，所以可以直接通过线性计算就可以实现转码。</p>
<p>所谓线性关系就是， U8 = f(U16), 而这里的 f 是一个数学运算函数。</p>
<p>由于 GBK 和 UTF-16 编码并没有线性映射关系（因为相同的字符在 GBK 中的编码和 UTF-16 中的编码的分布是没有规律），所以GBK 和 UTF-16的编码转换必须通过不断的循环查找来实现转换，这样效率非常低。</p>
<p>所以在非线性编码的转码（编码和解码）的过程中创建一个码表将非线性的关系转换成了线性关系。这样转码的效率就是O(1)了，而不用循环查找，这么低效的方法。</p>
<p>所以创建码表就成了关键所在：</p>
<p>jdk中提供的类：sun.nio.cs.ext.GBK 代表 GBK 字符集。 这个字符集中就实现了两个码表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GBK</span> <span class="keyword">extends</span> <span class="title">Charset</span> <span class="keyword">implements</span> <span class="title">HistoricallyNamedCharset</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// GBK 字节 ====&gt; UTF-16 字符 的码表</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span>[][] b2c = <span class="keyword">new</span> <span class="keyword">char</span>[b2cStr.length][];</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span>[] b2cSB;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> b2cInitialized = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  UTF-16 字节 ====&gt; GBK  字符 的码表</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span>[] c2b = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">28672</span>];</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span>[] c2bIndex = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">256</span>];</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> c2bInitialized = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 摘自 openjdk sun.nio.cs.ext.DoubleByte</span></span><br><span class="line"> * Decoding: 解码 GBK ===&gt; UTF16</span><br><span class="line"> *</span><br><span class="line"> *    <span class="keyword">char</span>[][] b2c;</span><br><span class="line"> *    <span class="keyword">char</span>[] b2cSB;</span><br><span class="line"> *    <span class="keyword">int</span> b2Min, b2Max</span><br><span class="line"> *</span><br><span class="line"> *    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">decodeSingle</span><span class="params">(<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"> *        <span class="keyword">return</span> b2cSB.[b];</span><br><span class="line"> *    &#125;</span><br><span class="line"> *</span><br><span class="line"> *    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">decodeDouble</span><span class="params">(<span class="keyword">int</span> b1, <span class="keyword">int</span> b2)</span> </span>&#123;</span><br><span class="line"> *        <span class="keyword">if</span> (b2 &lt; b2Min || b2 &gt; b2Max)</span><br><span class="line"> *            <span class="keyword">return</span> UNMAPPABLE_DECODING;</span><br><span class="line"> *         <span class="keyword">return</span> b2c[b1][b2 - b2Min];</span><br><span class="line"> *    &#125;</span><br><span class="line"> *</span><br><span class="line"> *    (<span class="number">1</span>)b2Min, b2Max are the corresponding min and max value of the</span><br><span class="line"> *       low-half of the <span class="keyword">double</span>-<span class="keyword">byte</span>.</span><br><span class="line"> *    (<span class="number">2</span>)The high <span class="number">8</span>-bit/b1 of the <span class="keyword">double</span>-<span class="keyword">byte</span> are used to indexed into</span><br><span class="line"> *       b2c array.</span><br><span class="line"> *</span><br><span class="line"> * Encoding: 编码： UTF16 ===&gt; GBK</span><br><span class="line"> *</span><br><span class="line"> *    <span class="keyword">char</span>[] c2b;</span><br><span class="line"> *    <span class="keyword">char</span>[] c2bIndex;</span><br><span class="line"> *</span><br><span class="line"> *    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">encodeChar</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line"> *        <span class="keyword">return</span> c2b[c2bIndex[ch &gt;&gt; <span class="number">8</span>] + (ch &amp; <span class="number">0xff</span>)];</span><br><span class="line"> *    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">GBK ===&gt; UTF-16 码表:</span><br><span class="line"></span><br><span class="line"> 0x  00  01  02  03  ... 40  41  42  43  ... a0  a1  a2  a3  ... f8   f9  fa  fb  fd  fe  ff</span><br><span class="line">	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line"> 00 |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |</span><br><span class="line">	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line"> 01 |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |</span><br><span class="line">	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line"> 02 |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |</span><br><span class="line">	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line"> ...|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |</span><br><span class="line">	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line"> 81 |   |   |   |   |   |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |   |</span><br><span class="line">	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line"> 82 |   |   |   |   |   |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |   |</span><br><span class="line">	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line"> 83 |   |   |   |   |   |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |   |</span><br><span class="line">	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line"> ...|   |   |   |   |   |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |   |</span><br><span class="line">	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line"> fd |   |   |   |   |   |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |   |</span><br><span class="line">	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line"> fe |   |   |   |   |   |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |Ux |   |</span><br><span class="line">	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line"> ff |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |</span><br><span class="line">	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line"></span><br><span class="line">Ux表示： 字符的 UTF-16 编码。</span><br><span class="line"></span><br><span class="line">由上面的码表，可以反向，计算出另一张码表: UTF-16 ===&gt; GBK.</span><br><span class="line"></span><br><span class="line">假设，上面的码表存储在：</span><br><span class="line"></span><br><span class="line">// GBK ===&gt; UTF-16 码表：</span><br><span class="line">char[][] b2c = new char[0x100][0x100];</span><br><span class="line"></span><br><span class="line">// UTF-16 ===&gt; GBK</span><br><span class="line">char[][] c2b = new char[0x100][0x100];</span><br><span class="line">for(int b1 = 0x00; b1 &lt; 0x100; b1++)&#123;</span><br><span class="line"></span><br><span class="line">	for(int b2 = 0x00; b2 &lt; 0x100; b2++)&#123;</span><br><span class="line">		</span><br><span class="line">		// 得到 GBK编码为 (b1, b2) 字符的 UTF-16 编码</span><br><span class="line">		char Ux = b2c[b1][b2];</span><br><span class="line">		</span><br><span class="line">		// 得到 UTF-16 编码的高位字节。</span><br><span class="line">		int i1 = Ux &gt;&gt; 8;</span><br><span class="line">		// 得到 UTF-16 编码的低位字节。</span><br><span class="line">		int i2 = Ux &amp;&amp; 0xff;</span><br><span class="line"></span><br><span class="line">		// 计算 GBK 编码</span><br><span class="line">		char gbk = (char)((b1 &lt;&lt; 8) | b2);</span><br><span class="line"></span><br><span class="line">		c2b[i1][i2] = gbk</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这样就制作出的另一张码表：UTF-16 ===&gt; GBK</span><br><span class="line">下面模拟，转换过程：</span><br><span class="line"></span><br><span class="line">char[] utf16chars = &#123;&apos;丂&apos;, &apos;丄&apos;, &apos;丅&apos;, &apos;丆&apos;, &apos;丏&apos;&#125;;</span><br><span class="line">char c1 = utf16chars[0];</span><br><span class="line">int i1 = c1 &gt;&gt; 8;</span><br><span class="line">int i2 = c1 &amp;&amp; 0xff;</span><br><span class="line"></span><br><span class="line">// 直接使用 c2b 码表即可</span><br><span class="line">int gbk = c2b[i1][i2];</span><br><span class="line"></span><br><span class="line">上面的实现，只是为了表达编码转换的过程和思路，sun.nio.cs.ext.DoubleByte 的实现更加的优化，码表占用空间更小，还考虑到了和 ASCII 字符集兼容的问题等等，但其基本思路是和上面的描述是一致的。</span><br></pre></td></tr></table></figure>
<p>由上面的码表可知，这其实就是一个二维数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// char 数组用来存储上面的码表</span></span><br><span class="line"><span class="keyword">char</span>[][] b2c;</span><br></pre></td></tr></table></figure>
<p>对于 二维数组 b2c ，其第一维是 GBK 的高位字节： 0x81 – 0xfe, 其第二维，构成了 char[] 存放 GBK 低字节 0x40 – 0xfe 其 191 个字符的 char 数据，由 java 语言可以知道 char 类型其实存储的是 UTF-16BE 编码。所以这张码表就实现了从 GBK 字符集到 UTF-16BE 字符集的编码操作。一旦字节从 GBK 转成 UTF-16BE， 那么 UTF系列编码之间的转换将非常容易，因为它们之间是存在线性关系的。比如，从 UTF-16BE ==&gt; UTF-16LE 按照 UTF-16LE 的编码规范，将 UTF-16BE 字符的高位字节和底位字节对调即可完成转换。UTF-16BE ==&gt; UTF-8 也非常容易，按照 UTF-8 的编码规则进行计算即可。</p>
<p>下面模拟，转换过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 丂丄丅丆丏 </span><br><span class="line">// 上面5个字符的 GBK 编码：</span><br><span class="line">byte[] bytes = &#123;81, 40, 81, 41, 81, 42, 81, 43, 81, 44&#125;;</span><br><span class="line"></span><br><span class="line">// GBK 是双字节字符集，所以使用两个字节来代表一个字符，所以当读取到上面的字节时，每两个字节构成一个字符：</span><br><span class="line"></span><br><span class="line">// 先解析 81, 40 按照上面码表的规则，81 将是这个字符的在码表的高位索引，40是低位索引所以对应的 char 就是：</span><br><span class="line"></span><br><span class="line">char c = b2c[81][40]  </span><br><span class="line"></span><br><span class="line">// 这个 c 就是编码后的字符，其编码是 UTF-16 ，也是两个字节，分别对应：4E, 02</span><br><span class="line">// 所以通过 b2c 就可以将 GBK 字节流转换成 UTF-16 字节流。</span><br><span class="line">// 字符     GBK       UTF-16</span><br><span class="line">//  丂    (81, 40)   (4E, 02)</span><br><span class="line">//  丄    (81, 41)   (4E, 04)</span><br><span class="line">//  丅    (81, 42)   (4E, 05)</span><br><span class="line">//  丆    (81, 43)   (4E, 06)</span><br><span class="line">//  丏    (81, 44)   (4E, 0F)</span><br></pre></td></tr></table></figure>
<p>从上面的转换过程中，可以看到，所谓不同编码（或者说，不同字符集）之间的转换其实就是：</p>
<p><strong>字符A（丂） 在字符集C1（GBK）中的字节（81, 40）  通过映射或者线程运算（b2c[81][40]，其实就是一种映射, b2c 本身就是一个二维数组构成的编码对照表，所以也可以认为就是查表操作）<br>转换成 字符集C2(UTF-16)中该字符的字节（4E, 02）</strong></p>
<ul>
<li><p>字符是什么？</p>
<p>  字符的本质就是图形</p>
</li>
<li><p>字符集是什么？</p>
<p>  字符集的本质就是字符的集合，一个文化领域内的字符构成一个字符集，例如：汉字字符构成的集合：GBK字符集</p>
</li>
<li><p>字符编码是什么？</p>
<p>  对于字符和字符集来说，本身是没有所谓编码的概念的。例如: GBK 字符集的字符：汉字，当我们使用的时候，就是按照这个字符的字形进行书写的，所以这个过程并没有涉及到编码。</p>
<p>  但是，对于计算机来说，它是无法理解字符的字形，也就不可能让计算机来书写字符（也即在屏幕上显示字符），但是，换个角度，对于同一个书写方法（例如：宋体书法，隶书，草书）其所对应的字符的字形（glyph）总是固定的，而且一个字符集中所包含的字符总数也是固定的。</p>
<p>  所以，可以将字符集中的所有字符的图形的形式存储起来，然后给每一个图形（字符）进行编号。当我们在计算机中存储字符时，就可以直接存储这些编号。计算机在屏幕上显示的时候，就可以使用这些编号从字符集的图形文件中索引到该字符对应的图形，将这个图形显示出来，就间接地达到也显示字符的效果。</p>
<p>  这个存储 字符集中的所有字符的图形 的文件就是 字体文件。</p>
<p>  对每一个字符需要有一个惟一的编号，使其可以从 字体文件 中被索引到。这个编号 就是 这个字符的编码。</p>
<p>  字符的编码就是一个数字，这个数字在同一个字符集中惟一的索引这个字符。</p>
<p>  由此，也可以知道，其实这个 索引（编码） 就是人为规定的，即使这个规定中存在一定的规律（例如：汉字按拼音排序，高位使用 0x81-0xfe, 低位使用 0x40-0xfe 编码（注意，这只是一个假设的编码的规则，为了便于理解）），它也只不过是一个人为的编号而已。</p>
</li>
<li><p>为什么会有不同的字符集？</p>
<p>  由上面的分析可以知道，只要有一个字符集就可以表示字符了，为什么出现多个？<br>  先出现 GB2312，也就是先编码了最常用的字符，后来计算机普及到各个领域，需要表示的字符需要扩充，就出来了 GBK, GB18030 等等。</p>
</li>
<li><p>字符集之间的转换？</p>
<p>  其实就是同一个字符在不同字符集间的编码的转换，就是字节到字节之间的转换。</p>
</li>
</ul>
<h3 id="java-中的字符集类"><a href="#java-中的字符集类" class="headerlink" title="java 中的字符集类"></a>java 中的字符集类</h3><ul>
<li><p>Charset</p>
<blockquote>
<p>A named mapping between sequences of sixteen-bit Unicode code units and sequences of bytes.</p>
</blockquote>
<p>  表示各种字符集： UTF-16, UTF-8, GBK 等等，</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建这个字符集的解码器，即 当前字符集 ===&gt; UTF-16</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> CharsetDecoder <span class="title">newDecoder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 创建当前字符集的编码器，即 UTF-16 ===&gt; 当前字符集</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> CharsetEncoder <span class="title">newEncoder</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>CharsetDecoder</p>
<blockquote>
<p>An engine that can transform a sequence of bytes in a specific charset into a sequence of sixteen-bit Unicode characters</p>
</blockquote>
</li>
<li><p>CharsetEncoder</p>
<blockquote>
<p>An engine that can transform a sequence of sixteen-bit Unicode characters into a sequence of bytes in a specific charset. </p>
</blockquote>
</li>
<li><p>sun.nio.cs.StreamEncoder</p>
<p>  StreamEncoder 接受 OutputStream out 和 Charset cs. 这个类还是一个 Writer。这个类的功能就是<br>  使用 write 方法时，将 char[] 通过 encoder 的编码，转码成 cs 字符集字符，然后，写入到 out 流中。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamEncoder</span> <span class="keyword">extends</span> <span class="title">Writer</span></span>&#123;</span><br><span class="line">	<span class="comment">// 这个Stream的 Encoder</span></span><br><span class="line">   	<span class="keyword">private</span> CharsetEncoder encoder;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造函数中将初始化这个 Encoder</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">StreamEncoder</span><span class="params">(OutputStream out, Object lock, Charset cs)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(out, lock,</span><br><span class="line">        cs.newEncoder()</span><br><span class="line">        .onMalformedInput(CodingErrorAction.REPLACE)</span><br><span class="line">        .onUnmappableCharacter(CodingErrorAction.REPLACE));</span><br><span class="line">   	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// write 方法的实现中</span></span><br><span class="line">	<span class="comment">// 将使用 encoder, 对字符进行转码操作。</span></span><br><span class="line">	<span class="comment">// encoder.encode(cb, bb, false);</span></span><br><span class="line"> 	<span class="function"><span class="keyword">void</span> <span class="title">implWrite</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        CharBuffer cb = CharBuffer.wrap(cbuf, off, len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (haveLeftoverChar)</span><br><span class="line">        flushLeftoverChar(cb, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cb.hasRemaining()) &#123;</span><br><span class="line">        CoderResult cr = encoder.encode(cb, bb, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (cr.isUnderflow()) &#123;</span><br><span class="line">           <span class="keyword">assert</span> (cb.remaining() &lt;= <span class="number">1</span>) : cb.remaining();</span><br><span class="line">           <span class="keyword">if</span> (cb.remaining() == <span class="number">1</span>) &#123;</span><br><span class="line">                haveLeftoverChar = <span class="keyword">true</span>;</span><br><span class="line">                leftoverChar = cb.get();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cr.isOverflow()) &#123;</span><br><span class="line">            <span class="keyword">assert</span> bb.position() &gt; <span class="number">0</span>;</span><br><span class="line">            writeBytes();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cr.throwException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>sun.nio.cs.StreamDecoder</p>
<p>  这个类接受： InputStream in 和 Charset cs ， cs 表示 in 数据流的字符集。可以通过 decoder 将 in 流转码成 java 中的 char 类型，也就是转换成 UTF-16 字节。这样 java 代码就可以处理这些字符数据了。</p>
</li>
</ul>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2016/10/06/IO-Reader/">Reader &amp; Writer</a><a class="next" href="/2016/10/02/IO-OutputStream/">OutputStream</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/interface/" style="font-size: 15px;">interface</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/Collections/" style="font-size: 15px;">Collections</a> <a href="/tags/Collection/" style="font-size: 15px;">Collection</a> <a href="/tags/J-U-C/" style="font-size: 15px;">J.U.C</a> <a href="/tags/lock/" style="font-size: 15px;">lock</a> <a href="/tags/Semaphore/" style="font-size: 15px;">Semaphore</a> <a href="/tags/CyclicBarrier/" style="font-size: 15px;">CyclicBarrier</a> <a href="/tags/CountDownLatch/" style="font-size: 15px;">CountDownLatch</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/LinkedList/" style="font-size: 15px;">LinkedList</a> <a href="/tags/Queue/" style="font-size: 15px;">Queue</a> <a href="/tags/Set/" style="font-size: 15px;">Set</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/collection/" style="font-size: 15px;">collection</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/api/" style="font-size: 15px;">api</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/mvc/" style="font-size: 15px;">mvc</a> <a href="/tags/context/" style="font-size: 15px;">context</a> <a href="/tags/component-scan/" style="font-size: 15px;">component-scan</a> <a href="/tags/storm/" style="font-size: 15px;">storm</a> <a href="/tags/windows/" style="font-size: 15px;">windows</a> <a href="/tags/命令行/" style="font-size: 15px;">命令行</a> <a href="/tags/cmder/" style="font-size: 15px;">cmder</a> <a href="/tags/win/" style="font-size: 15px;">win</a> <a href="/tags/效率/" style="font-size: 15px;">效率</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/博客/" style="font-size: 15px;">博客</a> <a href="/tags/apache/" style="font-size: 15px;">apache</a> <a href="/tags/extends/" style="font-size: 15px;">extends</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/svn/" style="font-size: 15px;">svn</a> <a href="/tags/BlockingQueue/" style="font-size: 15px;">BlockingQueue</a> <a href="/tags/LinkedBlockingQueue/" style="font-size: 15px;">LinkedBlockingQueue</a> <a href="/tags/PriorityBlockingQueue/" style="font-size: 15px;">PriorityBlockingQueue</a> <a href="/tags/ConcurrentLinkedQueue/" style="font-size: 15px;">ConcurrentLinkedQueue</a> <a href="/tags/CopyOnWriteArrayList/" style="font-size: 15px;">CopyOnWriteArrayList</a> <a href="/tags/接口/" style="font-size: 15px;">接口</a> <a href="/tags/抽象类/" style="font-size: 15px;">抽象类</a> <a href="/tags/Executor/" style="font-size: 15px;">Executor</a> <a href="/tags/ExecutorService/" style="font-size: 15px;">ExecutorService</a> <a href="/tags/CompletionService/" style="font-size: 15px;">CompletionService</a> <a href="/tags/ThreadPoolExecutor/" style="font-size: 15px;">ThreadPoolExecutor</a> <a href="/tags/vim/" style="font-size: 15px;">vim</a> <a href="/tags/vundle/" style="font-size: 15px;">vundle</a> <a href="/tags/ArrayList/" style="font-size: 15px;">ArrayList</a> <a href="/tags/log/" style="font-size: 15px;">log</a> <a href="/tags/index/" style="font-size: 15px;">index</a> <a href="/tags/concepts/" style="font-size: 15px;">concepts</a> <a href="/tags/Timer/" style="font-size: 15px;">Timer</a> <a href="/tags/TimerTask/" style="font-size: 15px;">TimerTask</a> <a href="/tags/ConcurrentMap/" style="font-size: 15px;">ConcurrentMap</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 15px;">ConcurrentHashMap</a> <a href="/tags/HashMap/" style="font-size: 15px;">HashMap</a> <a href="/tags/ReentrantReadWriteLock/" style="font-size: 15px;">ReentrantReadWriteLock</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/SynchronousQueue/" style="font-size: 15px;">SynchronousQueue</a> <a href="/tags/ScheduledExecutorService/" style="font-size: 15px;">ScheduledExecutorService</a> <a href="/tags/AQS/" style="font-size: 15px;">AQS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/BigData-docker/">Windows 上安装 docker</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/mysql-0.路线/">Mysql学习路线</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/mysql-索引/">Mysql安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/Qunar基础框架-QSchedule/">Qunar基础框架-QSchedule</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/java集合构架中使用到的数据结构和算法/">java集合构架中使用到的数据结构和算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/20/reids-调试环境搭建/">redis-调试环境搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/31/OpenStack-安装/">OpenStack-安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/26/JVM-hotspot-GC机制/">JVM-hotspot-GC机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/11/netty-socketio + socket.io 实现消息推送/">netty-socketio + socket.io 实现消息推送</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/26/mongodb-安装/">mongodb-安装</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/a-ray-of-sunshine" title="github" target="_blank">github</a><ul></ul><a href="http://www.cnblogs.com/a-ray-of-sunshine" title="cnblog" target="_blank">cnblog</a><ul></ul><a href="http://blog.csdn.net/a_ray_of_sunshine" title="csdn" target="_blank">csdn</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Shawshank.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>