<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>kafka log文件格式 | Shawshank</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">kafka log文件格式</h1><a id="logo" href="/.">Shawshank</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">kafka log文件格式</h1><div class="post-meta">Jun 8, 2016</div><div class="post-content"><h2 id="topic存储位置"><a href="#topic存储位置" class="headerlink" title="topic存储位置"></a>topic存储位置</h2><p>broker在启动的时候会，配置这个broker产生的topic的存储位置，kafka默认的配置在 server.properties 文件中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># A comma seperated list of directories under which to store log files</span></span><br><span class="line">log.dirs=/tmp/kafka-logs</span><br></pre></td></tr></table></figure></p>
<p>在这里可以查看到各个topic的物理文件。</p>
<h2 id="查看-topic-的-index-文件和-log-文件"><a href="#查看-topic-的-index-文件和-log-文件" class="headerlink" title="查看 topic 的 index 文件和 log 文件"></a>查看 topic 的 index 文件和 log 文件</h2><p>kafka自身提供了一些工具来查看这些文件，关于这些工具的介绍，参考文档：<a href="https://cwiki.apache.org/confluence/display/KAFKA/System+Tools" target="_blank" rel="noopener">system tools</a></p>
<p>其中有一个工具：Dump Log Segment</p>
<p>This can print the messages directly from the log files or just verify the indexes correct for the logs</p>
<p>这个工具可以打印出 index 和 log 文件的内容。执行以下命令，查看这个工具的使用帮助：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-run-class.sh kafka.tools.DumpLogSegments</span><br></pre></td></tr></table></figure></p>
<p>其中比较重要的两个选项：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用来指定要查看的 log 或 index 文件</span></span><br><span class="line">--files &lt;file1, file2, ...&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是个标记选项，如果带了这个参数，则当解析 log 文件时</span></span><br><span class="line"><span class="comment"># 会将存储的message 和 这个message对应的key都打印出来</span></span><br><span class="line">--<span class="built_in">print</span>-data-log</span><br></pre></td></tr></table></figure></p>
<h2 id="与文件格式相关的类"><a href="#与文件格式相关的类" class="headerlink" title="与文件格式相关的类"></a>与文件格式相关的类</h2><p>查看 kafka.tools.DumpLogSegments 这个类的源代码可知<br>最终，index 和 log 文件的解析都由kafka.log.FileMessageSet 这个类的 iterator 方法来完成，这个方法的返回值是： Iterator[MessageAndOffset]<br>这个类的核心代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> MessageAndOffset(<span class="keyword">new</span> Message(buffer), offset)</span><br></pre></td></tr></table></figure></p>
<p>最终从文件中读入的字节流buffer都交由 Messsage 类完成解析。<br>kafka.message.Message 这个类的：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A message. The format of an N byte message is the following:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 4 byte CRC32 of the message</span></span><br><span class="line"><span class="comment"> * 2. 1 byte "magic" identifier to allow format changes, value is 2 currently</span></span><br><span class="line"><span class="comment"> * 3. 1 byte "attributes" identifier to allow annotations on the message independent of the version (e.g. compression enabled, type of codec used)</span></span><br><span class="line"><span class="comment"> * 4. 4 byte key length, containing length K</span></span><br><span class="line"><span class="comment"> * 5. K byte key</span></span><br><span class="line"><span class="comment"> * 6. 4 byte payload length, containing length V</span></span><br><span class="line"><span class="comment"> * 7. V byte payload</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Default constructor wraps an existing ByteBuffer with the Message object with no change to the contents.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">class Message(val buffer: ByteBuffer) &#123;</span><br></pre></td></tr></table></figure></p>
<p>这个类描述了Message在文件中存储格式。</p>
<p>log文件中的一个例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">offset: 291178 position: 180 isvalid: <span class="literal">true</span> payloadsize: 10 magic: 0 compresscodec: NoCompressionCodec crc: 576249152 keysize: 2 key: 11 payload: Message_11</span><br></pre></td></tr></table></figure></p>
<p>这是一条 message 记录，共 10 个字段，其中后 7 个字段和上面 message 中定义的信息相对应。还有 3 个字段，没有对应，分别是：</p>
<ul>
<li>isvalid：Returns true if the crc stored with the message matches the crc computed off the message contents，这个值是 message 被读取出来之后，进行crc校验之后的结果。</li>
<li>position: 这个标志的含义是：当前这条 message 在这个文件内的绝对偏移量。也就是 message 的在这个文件中的 起始的字节个数。例如，上面的那条 message，其 position 是 180，表示这个 message 在这个文件的第 180 个字节处开始。这数字详细算法见： kafka.message.MessageSet 类的 entrySize 方法。其实就是头部的 12 字节 + message的size.</li>
<li>offset: 这个变量的值是： message 头部的前 8 个字节。</li>
</ul>
<p>##　index 和 log 文件的解析<br>由上面的分析可知，这两个文件由<br>kafka.log.FileMessageSet 的 iterator 方法来完成。这个方法的实现代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">iterator</span><span class="params">(maxMessageSize: Int)</span>: Iterator[MessageAndOffset] </span>= &#123;</span><br><span class="line">  <span class="keyword">new</span> IteratorTemplate[MessageAndOffset] &#123;</span><br><span class="line">    <span class="keyword">var</span> location = start</span><br><span class="line">    <span class="comment">// 这个 buufer 用来存储，channel 中的 message 的头部。</span></span><br><span class="line"><span class="comment">// 这个头部包含两个信息。这两个信息共占，12个字节</span></span><br><span class="line"><span class="comment">// 所以只分配 12 个字节	 </span></span><br><span class="line">    val sizeOffsetBuffer = ByteBuffer.allocate(<span class="number">12</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function">override def <span class="title">makeNext</span><span class="params">()</span>: MessageAndOffset </span>= &#123;</span><br><span class="line">      <span class="keyword">if</span>(location &gt;= end)</span><br><span class="line">        <span class="keyword">return</span> allDone()</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// read the size of the item</span></span><br><span class="line">      sizeOffsetBuffer.rewind()</span><br><span class="line">      <span class="comment">// 从 channel 中读取数据</span></span><br><span class="line">      channel.read(sizeOffsetBuffer, location)</span><br><span class="line">      <span class="keyword">if</span>(sizeOffsetBuffer.hasRemaining)</span><br><span class="line">        <span class="keyword">return</span> allDone()</span><br><span class="line">      </span><br><span class="line">      sizeOffsetBuffer.rewind()</span><br><span class="line">      <span class="comment">// 从 buffer 中获取，这个 message 的 offset</span></span><br><span class="line">      <span class="comment">// 占 8 个字节（long 类型）</span></span><br><span class="line">      val offset = sizeOffsetBuffer.getLong()</span><br><span class="line">      <span class="comment">// 从 buffer 中获取，这个 message 的 size</span></span><br><span class="line">      <span class="comment">// 占 4 个字节（int 类型）</span></span><br><span class="line">      val size = sizeOffsetBuffer.getInt()</span><br><span class="line">      <span class="keyword">if</span>(size &lt; Message.MinHeaderSize)</span><br><span class="line">        <span class="keyword">return</span> allDone()</span><br><span class="line">      <span class="keyword">if</span>(size &gt; maxMessageSize)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidMessageException(<span class="string">"Message size exceeds the largest allowable message size (%d)."</span>.format(maxMessageSize))</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// read the item itself</span></span><br><span class="line">      val buffer = ByteBuffer.allocate(size)</span><br><span class="line">      <span class="comment">// 读取 message 本身，其大小就是上面的size</span></span><br><span class="line">      channel.read(buffer, location + <span class="number">12</span>)</span><br><span class="line">      <span class="keyword">if</span>(buffer.hasRemaining)</span><br><span class="line">        <span class="keyword">return</span> allDone()</span><br><span class="line">      buffer.rewind()</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// increment the location and return the item</span></span><br><span class="line">      <span class="comment">// 调整 location 的位置，用于读取下一条message</span></span><br><span class="line">      location += size + <span class="number">12</span></span><br><span class="line">      <span class="keyword">new</span> MessageAndOffset(<span class="keyword">new</span> Message(buffer), offset)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h2><p>message 在一个分区内会维护其顺序，这个 offset 是指这条 message 在这个分区内的偏移量。同一个分区中的数据可以存储到不同的文件中，文件大小的指定是在：<br>server.properties 中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.segment.bytes=10485760</span><br></pre></td></tr></table></figure></p>
<p>不分区中的数据达到这个字节数时，server 就会另创建一个文件，这个文件的命名就是以这个文件中将要存储的第一条数据的offset来命名的。<br><strong>由于 offset 存储为 8 字节，而8字节能够表示的最大值是：18446744073709551615，其共有 20 位，所以 server 生成的数据的命名是 20 位，其规则是: 当前这个文件中的第一个 message 中的 offset ,不足20位，前面补0 </strong></p>
<h2 id="index"><a href="#index" class="headerlink" title="index"></a>index</h2><p>对于 index 文件也可以由 DumpLogSegments 类来查看，解析。由这个类的 dumpIndex 方法来完成。查看这个方法，可知，最终的解析由 kafka.log.OffsetIndex 类来完成。查看这个类的文档：</p>
<p>An index that maps offsets to physical file locations for a particular log segment. This index may be sparse: that is it may not hold an entry for all messages in the log.</p>
<p>The index is stored in a file that is pre-allocated to hold a fixed maximum number of 8-byte entries.</p>
<p>The index supports lookups against a memory-map of this file. These lookups are done using a simple binary search variant to locate the offset/location pair for the greatest offset less than or equal to the target offset.</p>
<p>Index files can be opened in two ways: either as an empty, mutable index that allows appends or an immutable read-only index file that has previously been populated. The makeReadOnly method will turn a mutable file into an immutable one and truncate off any extra bytes. This is done when the index file is rolled over.</p>
<p>No attempt is made to checksum the contents of this file, in the event of a crash it is rebuilt.</p>
<p>The file format is a series of entries. The physical format is a 4 byte “relative” offset and a 4 byte file location for the message with that offset. The offset stored is relative to the base offset of the index file. So, for example, if the base offset was 50, then the offset 55 would be stored as 5. Using relative offsets in this way let’s us use only 4 bytes for the offset.</p>
<p>index 文件： 存储 message 的 offset 和 position 映射 entity, 每个 entity 占8个字节： The physical format is a 4 byte “relative” offset and a 4 byte file location for the message with that offset</p>
<p>这里的 offset 和 log 文件中的 offset 有区别，log 文件中的 offset 是这个分区中的 绝对offset, 而在 index 文件中存储的是相对于当前的这个 index 文件的 相对（relative）offset </p>
<p>kafka实现参考：<a href="http://blog.csdn.net/kisimple/article/details/42342459" target="_blank" rel="noopener">kafka实现</a></p>
</div><div class="tags"><a href="/tags/kafka/">kafka</a><a href="/tags/log/">log</a><a href="/tags/index/">index</a></div><div class="post-nav"><a class="pre" href="/2016/06/10/win提升效率/">win提升效率</a><a class="next" href="/2016/06/06/kafka-api/">kafka-api</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/interface/" style="font-size: 15px;">interface</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/Collections/" style="font-size: 15px;">Collections</a> <a href="/tags/Collection/" style="font-size: 15px;">Collection</a> <a href="/tags/J-U-C/" style="font-size: 15px;">J.U.C</a> <a href="/tags/lock/" style="font-size: 15px;">lock</a> <a href="/tags/Semaphore/" style="font-size: 15px;">Semaphore</a> <a href="/tags/CyclicBarrier/" style="font-size: 15px;">CyclicBarrier</a> <a href="/tags/CountDownLatch/" style="font-size: 15px;">CountDownLatch</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/LinkedList/" style="font-size: 15px;">LinkedList</a> <a href="/tags/Queue/" style="font-size: 15px;">Queue</a> <a href="/tags/Set/" style="font-size: 15px;">Set</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/collection/" style="font-size: 15px;">collection</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/api/" style="font-size: 15px;">api</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/mvc/" style="font-size: 15px;">mvc</a> <a href="/tags/context/" style="font-size: 15px;">context</a> <a href="/tags/component-scan/" style="font-size: 15px;">component-scan</a> <a href="/tags/storm/" style="font-size: 15px;">storm</a> <a href="/tags/windows/" style="font-size: 15px;">windows</a> <a href="/tags/命令行/" style="font-size: 15px;">命令行</a> <a href="/tags/cmder/" style="font-size: 15px;">cmder</a> <a href="/tags/win/" style="font-size: 15px;">win</a> <a href="/tags/效率/" style="font-size: 15px;">效率</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/博客/" style="font-size: 15px;">博客</a> <a href="/tags/apache/" style="font-size: 15px;">apache</a> <a href="/tags/extends/" style="font-size: 15px;">extends</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/svn/" style="font-size: 15px;">svn</a> <a href="/tags/BlockingQueue/" style="font-size: 15px;">BlockingQueue</a> <a href="/tags/LinkedBlockingQueue/" style="font-size: 15px;">LinkedBlockingQueue</a> <a href="/tags/PriorityBlockingQueue/" style="font-size: 15px;">PriorityBlockingQueue</a> <a href="/tags/ConcurrentLinkedQueue/" style="font-size: 15px;">ConcurrentLinkedQueue</a> <a href="/tags/CopyOnWriteArrayList/" style="font-size: 15px;">CopyOnWriteArrayList</a> <a href="/tags/接口/" style="font-size: 15px;">接口</a> <a href="/tags/抽象类/" style="font-size: 15px;">抽象类</a> <a href="/tags/Executor/" style="font-size: 15px;">Executor</a> <a href="/tags/ExecutorService/" style="font-size: 15px;">ExecutorService</a> <a href="/tags/CompletionService/" style="font-size: 15px;">CompletionService</a> <a href="/tags/ThreadPoolExecutor/" style="font-size: 15px;">ThreadPoolExecutor</a> <a href="/tags/vim/" style="font-size: 15px;">vim</a> <a href="/tags/vundle/" style="font-size: 15px;">vundle</a> <a href="/tags/ArrayList/" style="font-size: 15px;">ArrayList</a> <a href="/tags/log/" style="font-size: 15px;">log</a> <a href="/tags/index/" style="font-size: 15px;">index</a> <a href="/tags/concepts/" style="font-size: 15px;">concepts</a> <a href="/tags/Timer/" style="font-size: 15px;">Timer</a> <a href="/tags/TimerTask/" style="font-size: 15px;">TimerTask</a> <a href="/tags/ConcurrentMap/" style="font-size: 15px;">ConcurrentMap</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 15px;">ConcurrentHashMap</a> <a href="/tags/HashMap/" style="font-size: 15px;">HashMap</a> <a href="/tags/ReentrantReadWriteLock/" style="font-size: 15px;">ReentrantReadWriteLock</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/SynchronousQueue/" style="font-size: 15px;">SynchronousQueue</a> <a href="/tags/ScheduledExecutorService/" style="font-size: 15px;">ScheduledExecutorService</a> <a href="/tags/AQS/" style="font-size: 15px;">AQS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/BigData-docker/">Windows 上安装 docker</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/mysql-0.路线/">Mysql学习路线</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/mysql-索引/">Mysql安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/Qunar基础框架-QSchedule/">Qunar基础框架-QSchedule</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/java集合构架中使用到的数据结构和算法/">java集合构架中使用到的数据结构和算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/20/reids-调试环境搭建/">redis-调试环境搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/31/OpenStack-安装/">OpenStack-安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/26/JVM-hotspot-GC机制/">JVM-hotspot-GC机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/11/netty-socketio + socket.io 实现消息推送/">netty-socketio + socket.io 实现消息推送</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/26/mongodb-安装/">mongodb-安装</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/a-ray-of-sunshine" title="github" target="_blank">github</a><ul></ul><a href="http://www.cnblogs.com/a-ray-of-sunshine" title="cnblog" target="_blank">cnblog</a><ul></ul><a href="http://blog.csdn.net/a_ray_of_sunshine" title="csdn" target="_blank">csdn</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Shawshank.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>