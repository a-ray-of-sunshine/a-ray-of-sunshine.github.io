<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>IO-InputStream | Shawshank</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">IO-InputStream</h1><a id="logo" href="/.">Shawshank</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">IO-InputStream</h1><div class="post-meta">Sep 10, 2016</div><div class="post-content"><h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><p>抽象类，提供了一个 read 方法来读取字节。这个方法是一个抽象方法<br>交由具体的子类来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStream</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 对象要实现 InputStream 的类，</span></span><br><span class="line">	<span class="comment">// 需要实现下面的方法。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Reads the <strong>next byte of data</strong> from the input stream. The value byte is returned as an int in the range 0 to 255. </p>
<p>If no byte is available because the end of the stream has been reached, the value -1 is returned. </p>
<p>This method blocks until input data is available, the end of the stream is detected, or an exception is thrown.</p>
</blockquote>
<p>对于 read 方法来说，每调用一次，其返回数据中的下一个字节，所以就像流水一样。数据从某个地方（数据的源头，例如：磁盘文件，内存，java序列化后的对象）不断地调用 read 方法，将数据取出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+---------+</span><br><span class="line">|         |           </span><br><span class="line">|  data   |==========&gt;&gt;(read)====&gt; 1bye</span><br><span class="line">|         |</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure>
<p>这个函数会一直阻塞，直到：</p>
<ul>
<li>input data is available</li>
<li>the end of the stream is detected</li>
<li>an exception is thrown</li>
</ul>
<blockquote>
<p>If no byte is available because the end of the stream has been reached, the value -1 is returned.</p>
</blockquote>
<p>当 read 到数据源的 EOF 时，这个函数将返回 -1.</p>
<p>由于 read 方法并没有任何参数，所以，对于数据源的数据读取，只能是顺序的读取，其数据源内部的下一个返回字节的offset则由具体的实现来维护。例如 FileInputStream中，打开的文件，其默认 offset 就是第一个字节，随着不断 read , offset 由 ReadFile （win32） 和 read (linux) 的实现来维护。</p>
<p>同时，从 InputStream 这个抽象来说，其设计的目的就是提供数据的流式访问，而不是随机访问。所以，InputStream 中并没有提供类似 lseek 等，可以直接设置，下次读取数据位置的方法。</p>
<h2 id="mark"><a href="#mark" class="headerlink" title="mark"></a>mark</h2><p>虽然，InputStream 是流式（顺序）读取数据，但是其仍然，提供了一些可以跳跃式读取数据的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">markSupported</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readlimit)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"mark/reset not supported"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>long skip(long n)</p>
<p>  Skips over and discards n bytes of data from this input stream. 从 stream 的当前位置起 skip n 个字节，所以在 skip 调用之后，stream 的 offset 自然也就偏移了 n 个字节，所以 read 调用，将返回 skip 之后的字节。</p>
</li>
<li><p>boolean markSupported()</p>
<p>  Tests if this input stream supports the mark and reset methods. 如果 stream 支持 mark 和 reset 操作，则这个方法返回 true, 否则返回 false.</p>
</li>
<li><p>void mark(int readlimit)</p>
<p>  Marks the current position in this input stream.当这个方法被调用的时候，mark 会将当前的 stream 的读取的 position 记录下来，注意，<strong>mark的stream的位置和参数 readlimit 没有任何关系。</strong></p>
<p>  mark 下来的当前位置是有一个有效期的，在这个有效期内，调用 reset 方法可以恢复到 mark 的 position,否则，reset 将抛出异常。这个有效期就是 mark 的参数 readlimit:</p>
<p>  The readlimit arguments tells this input stream to allow that many bytes to be read before the mark position gets invalidated. </p>
<p>  也就是说在 mark 之后，如果有 readlimit 个字节，已经被读取，那么 mark 调用记录下来的那个 position 将变成 invalidated. 所以 reset 可能抛出 IOException</p>
</li>
<li><p>void reset()</p>
<p>  Repositions this stream to the position at the time the mark method was last called on this input stream.</p>
</li>
</ul>
<p>注意上面的描述是来自 InputStream 的文档，也就是说这相当于接口的约定。而具体的行为，则需要参考具体的实现。</p>
<p>例如：InputStream 的一个实现类 ByteArrayInputStream 是支持 mark &amp; reset 操作的，但是其在实现 mark 方法时，并没有使用参数 readlimit. 也就是说这个参数并没有干预到 reset 方法的实现。而在 InputStream 对接口的 reset 的描述中，readlimit 是起作用的。</p>
<p>所以，对一个 stream 的 mark &amp; reset 操作，一定要参考其具体的实现的方式。而不是 InputStream 中的描述。</p>
<p>InputStream 对于 mark &amp; reset 的实现是：</p>
<ul>
<li>markSupported return false</li>
<li>mark  does nothing</li>
<li>reset does nothing except throw an IOException.</li>
</ul>
<p>所以，如果InputStream的子类没有 override 这几个方法，则这个stream 就不支持 mark &amp; reset.</p>
<h2 id="InputStream-子类"><a href="#InputStream-子类" class="headerlink" title="InputStream 子类"></a>InputStream 子类</h2><p>InputStream 子类， 以数据源为分类有</p>
<p>字节数组，文件，java对象序列化文件流，管道，等等。</p>
<h3 id="ByteArrayInputStream"><a href="#ByteArrayInputStream" class="headerlink" title="ByteArrayInputStream"></a>ByteArrayInputStream</h3><h4 id="构造过程"><a href="#构造过程" class="headerlink" title="构造过程"></a>构造过程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ByteArrayInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">byte</span> buf[];</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> mark = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// The index one greater than the last valid </span></span><br><span class="line">	<span class="comment">// character in the input stream buffer.</span></span><br><span class="line">	<span class="comment">// count 并不是流的大小（size）或者说长度（length）</span></span><br><span class="line">	<span class="comment">// 而是 buf 数组中最后一个属于当前流的字节的索引+1.</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">            pos, mark                             count </span><br><span class="line">                ↓                                   ↓</span><br><span class="line">          +---+---+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line">bytes ---→| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |10 |11 |</span><br><span class="line">          +---+---+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line">              ↑                                   ↑</span><br><span class="line">              |___________________________________|</span><br><span class="line">                                  ↑</span><br><span class="line">                                 buf</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当使用下面的构造函数来构造，ByteArrayInputStream 时</span></span><br><span class="line"><span class="comment">// 其生成的内部结构如上图所示</span></span><br><span class="line"></span><br><span class="line">InputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bytes, <span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的调用使用 bytes[1] &lt;---&gt; bytes[9] 作为 </span></span><br><span class="line"><span class="comment">// ByteArrayInputStream 内部的 buf. read 方法的实现，就是以 buf 作为</span></span><br><span class="line"><span class="comment">// 数据源。由此可知，bytes[0],bytes[10],bytes[11] 这三个字节，对于</span></span><br><span class="line"><span class="comment">// bais 这个 stream 来说是不可见的。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ByteArrayInputStream</span><span class="params">(<span class="keyword">byte</span> buf[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.buf = buf;</span><br><span class="line">    <span class="keyword">this</span>.pos = offset;</span><br><span class="line">    <span class="keyword">this</span>.count = Math.min(offset + length, buf.length);</span><br><span class="line">    <span class="keyword">this</span>.mark = offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mark-amp-reset"><a href="#mark-amp-reset" class="headerlink" title="mark &amp; reset"></a>mark &amp; reset</h4><p>这个类支持 mark &amp; reset</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">markSupported</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readAheadLimit)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 记录当前位置。</span></span><br><span class="line">    mark = pos;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// readAheadLimit 参数并未使用，所以不存在</span></span><br><span class="line">	<span class="comment">// mark 失效的情况。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 将 stream 位置重置为最近一次 mark 调用时</span></span><br><span class="line">	<span class="comment">// 设置的 mark.</span></span><br><span class="line">    pos = mark;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="notes"><a href="#notes" class="headerlink" title="notes"></a>notes</h4><ol>
<li><p>close</p>
<p> 调用 close 方法并没有任何作用。close 方法是空实现。</p>
</li>
<li><p>内部直接引用的，参数传递过来的数组。如果这个字节数组在其它被修改了，对应 的流内部读取到的数据，也是被修改后的数据。</p>
</li>
<li><p>mark的位置，不会因为 readlimt 参数而失效，其内部没有使用 readlimt.</p>
</li>
</ol>
<h3 id="SequenceInputStream"><a href="#SequenceInputStream" class="headerlink" title="SequenceInputStream"></a>SequenceInputStream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储串连起来的流</span></span><br><span class="line">	Enumeration e;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 表示当前将要被使用或正在被使用的流</span></span><br><span class="line">    InputStream in;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类的作用是：将流串连起来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">               InputStream in;</span><br><span class="line">                     ↓</span><br><span class="line">+-------------+   +-------------+   +-------------+</span><br><span class="line">|   stream1   |--→|   stream2   |--→|   stream3   |--→ ...</span><br><span class="line">+-------------+   +-------------+   +-------------+</span><br><span class="line">↑                                                        ↑</span><br><span class="line">|________________________________________________________|</span><br><span class="line">                          ↑</span><br><span class="line">				   Enumeration e</span><br></pre></td></tr></table></figure>
<p>内部使用 Enumeration 来存储这些流的引用。</p>
<p>将流串连起来的核心方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Continues reading in the next stream if an EOF is reached.</span></span><br><span class="line"><span class="comment"> *  将流串连起来</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">nextStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e.hasMoreElements()) &#123;</span><br><span class="line">        <span class="comment">// 将流设置为下一个 elements.</span></span><br><span class="line">        in = (InputStream) e.nextElement();</span><br><span class="line">        <span class="keyword">if</span> (in == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125; <span class="comment">// 当 enumeration 中没有元素时，当前流自然就是 null 为了。</span></span><br><span class="line">    <span class="keyword">else</span> in = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以递归的形式来调用串连起来的流。</span></span><br><span class="line"><span class="comment">// 直到所有的流都读取完毕，直接返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (in == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 所有的流都已经读完</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c = in.read();</span><br><span class="line">	<span class="comment">// 说当前流已经读完，调整当前流。</span></span><br><span class="line">    <span class="keyword">if</span> (c == -<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">// 调整到下一个流</span></span><br><span class="line">        nextStream();</span><br><span class="line">		<span class="comment">// 继续读取。</span></span><br><span class="line">        <span class="keyword">return</span> read();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="PipedInputStream"><a href="#PipedInputStream" class="headerlink" title="PipedInputStream"></a>PipedInputStream</h3><p>这个类和 PipedOutputStream 在不同的线程中配合使用。表示管道。</p>
<p>流从 PipedOutputStream 中流入，从 PipedInputStream 流出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PipedInputStream 将在 out 处读取数据</span><br><span class="line">	       out</span><br><span class="line">	        ↓		</span><br><span class="line">         +-----+-------------------------+-----+</span><br><span class="line">     -1  |  0  |   buffer: 1024 bytes    | 1023|</span><br><span class="line">         +-----+-------------------------+-----+</span><br><span class="line">      ↑</span><br><span class="line">     in</span><br><span class="line">PipedOutputStream 将在 in 处写入数据</span><br></pre></td></tr></table></figure>
<p>PipedInputStream 的初始状态。</p>
<ul>
<li>in   表示 PipedOutputStream.write 方法写入buffer中下一个字节的索引。</li>
<li>out  表示 PipedInputStream.read 方法读取buffer中下一个字节的索引。</li>
</ul>
<p>初始状态下：<br>buffer 中没有数据，所以 in = -1 表示流是空的。<br>out = 0, 表示可以向 buffer[0] 处写入数据。</p>
<p>此时，如果从 pipe 中 read 数据，则 reader 线程将进入循环等待状态。直到 in &gt; 0,也就是 pipe 中有数据。如果从 pipe 中 write 数据，则 write 完成之后， out = 0, in = 1. 表示，此时若写入数据则应该写入 buffer[in] == buffer[1], 如果读取数据则应该读取，buffer[out] == buffer[0]。并且此后，将保持， out &lt; in, 直到 out 读到 in 的位置，也就是 out == in, 此时，相当于 buffer 中的数据已经全部读完。所以，重置 in = -1.</p>
<h4 id="PipedOutputStream-write"><a href="#PipedOutputStream-write" class="headerlink" title="PipedOutputStream.write"></a>PipedOutputStream.write</h4><p>PipedOutputStream.write 调用 PipedInputStream.receive 完成向 Pipe 中写入数据的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    checkStateForReceive();</span><br><span class="line">    writeSide = Thread.currentThread();</span><br><span class="line">	<span class="comment">// 如果向 pipe 中不停地写入数据，而不读取数据，则</span></span><br><span class="line">	<span class="comment">// 则，in 直到 &gt;= buffer.length, 此时， 而 buffer 的最后一个字节</span></span><br><span class="line">	<span class="comment">// 被写满之后，in 重置为 0, 则此时由于水消费数据，所以 out 也是 0, </span></span><br><span class="line">	<span class="comment">// 就有 in == out, 此时，说明 buffer 中全部是有效的数据，且都没有</span></span><br><span class="line">	<span class="comment">// 被消费，所以没有多余的空间存储数据了，所以 进入 wait 状态。</span></span><br><span class="line">	<span class="comment">// 直到 in != out , 也就是 out 被移动了，数据被消费了。</span></span><br><span class="line">	<span class="comment">// write 操作才可以继续。</span></span><br><span class="line">	<span class="comment">// 在 write 过程中，如果出现 in == out, 则表明，写入数据，已经</span></span><br><span class="line">	<span class="comment">// 将 buffer 写满，所以要进行 wait.</span></span><br><span class="line">    <span class="keyword">if</span> (in == out)</span><br><span class="line">        awaitSpace();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// in &lt; 0，表示此时 buffer 中没有数据。buffer 是空的。</span></span><br><span class="line">    <span class="keyword">if</span> (in &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        in = <span class="number">0</span>;</span><br><span class="line">        out = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 向 buffer 的 in 处 写入数据，</span></span><br><span class="line">	<span class="comment">// 并将 in 步进1，表示下次写入数据的位置是 in+1.</span></span><br><span class="line">    buffer[in++] = (<span class="keyword">byte</span>)(b &amp; <span class="number">0xFF</span>);</span><br><span class="line">	<span class="comment">// 当写入到 buffer 的最后一个位置的时候，重置写入位置</span></span><br><span class="line">	<span class="comment">// 开始循环写入到 buffer 的第一个字节处。</span></span><br><span class="line">    <span class="keyword">if</span> (in &gt;= buffer.length) &#123;</span><br><span class="line">        in = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// awaitSpace 进行循环等待。</span></span><br><span class="line"><span class="comment">// 等待 1s ,检测是否有空间，</span></span><br><span class="line"><span class="comment">// 如果没有空间，则继续等待。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">awaitSpace</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (in == out) &#123;</span><br><span class="line">        checkStateForReceive();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* full: kick any waiting readers */</span></span><br><span class="line">		<span class="comment">// 如果处在这个循环等待中，则表明当前 pipe 是有数据的</span></span><br><span class="line">		<span class="comment">// 所以调用 notifyAll, 将所有在这个 pipe 上 wait的</span></span><br><span class="line">		<span class="comment">// 的 reader 线程唤醒，使其能够，执行 read 操作。</span></span><br><span class="line">		<span class="comment">// 从而，达到释放空间的目的。</span></span><br><span class="line">        notifyAll();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.io.InterruptedIOException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="PipedInputStream-read"><a href="#PipedInputStream-read" class="headerlink" title="PipedInputStream.read"></a>PipedInputStream.read</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span>  <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!connected) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe not connected"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (closedByReader) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe closed"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (writeSide != <span class="keyword">null</span> &amp;&amp; !writeSide.isAlive()</span><br><span class="line">               &amp;&amp; !closedByWriter &amp;&amp; (in &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Write end dead"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    readSide = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> trials = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// in &lt; 0 表明，未曾有数据写入，此时 pipe 是空的</span></span><br><span class="line">	<span class="comment">// 所以进入循环等待中，直到 in &gt;= 0 表明，已经有数据写入了</span></span><br><span class="line">	<span class="comment">// 可以读取了。</span></span><br><span class="line">    <span class="keyword">while</span> (in &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (closedByWriter) &#123;</span><br><span class="line">            <span class="comment">/* closed by writer, return EOF */</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((writeSide != <span class="keyword">null</span>) &amp;&amp; (!writeSide.isAlive()) &amp;&amp; (--trials &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe broken"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* might be a writer waiting */</span></span><br><span class="line">        <span class="comment">// 在这个循环等待中，说明，目前 pipe 是空的，所以 writer 可以</span></span><br><span class="line">	    <span class="comment">// 执行，写入操作，所以 notifyAll， 将所所有在这个 pipe 上</span></span><br><span class="line">		<span class="comment">// wait 的 writer 唤醒。让其能够进行写入操作。</span></span><br><span class="line">		<span class="comment">// 从而，使得 pipe 中有了可以消费的数据。</span></span><br><span class="line">        notifyAll();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.io.InterruptedIOException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 代码，执行到这里，表明， pipe中有数据了</span></span><br><span class="line">	<span class="comment">// 直接获取数据。</span></span><br><span class="line">    <span class="keyword">int</span> ret = buffer[out++] &amp; <span class="number">0xFF</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当获取数据的位置，到达 buffer 的最后一个位置的时候</span></span><br><span class="line">	<span class="comment">// 重置 out 到 0, 表明，下次读取数据将从 buffer[0] 处开始。</span></span><br><span class="line">    <span class="keyword">if</span> (out &gt;= buffer.length) &#123;</span><br><span class="line">        out = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果 pipe 中没有数据了 则 in == out</span></span><br><span class="line">	<span class="comment">// 表明，下次读和写的位置相同了，也就是说当前 pipe</span></span><br><span class="line">	<span class="comment">// 空了，所以：</span></span><br><span class="line">	<span class="comment">// 此时，重置 in = -1, 表示，buffer 已经空了。</span></span><br><span class="line">	<span class="comment">// 其实，这里也应该将 out 重置成 0 的。但是</span></span><br><span class="line">	<span class="comment">// 由于 write 处，有:</span></span><br><span class="line">	<span class="comment">//   if (in &lt; 0) &#123;</span></span><br><span class="line">    <span class="comment">//        in = 0;</span></span><br><span class="line">    <span class="comment">//        out = 0;</span></span><br><span class="line">    <span class="comment">//   &#125;</span></span><br><span class="line">	<span class="comment">// 所以这里，只是将 in 重置。</span></span><br><span class="line">    <span class="keyword">if</span> (in == out) &#123;</span><br><span class="line">	<span class="comment">// 在 read 过程中，如果出现: in == out 则表明，</span></span><br><span class="line">	<span class="comment">// 当前 buffer 已经读完，所以 buffer 是空的，则</span></span><br><span class="line">	<span class="comment">// 重置 in = -1</span></span><br><span class="line">        <span class="comment">/* now empty */</span></span><br><span class="line">        in = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h4><p>PipedInputStream 和 PipedOutputStream 如果连接(connect)起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PipedInputStream.connect</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(PipedOutputStream src)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    src.connect(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PipedOutputStream.connect</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(PipedInputStream snk)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (snk == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sink != <span class="keyword">null</span> || snk.connected) &#123;</span><br><span class="line">		<span class="comment">// 如果当前 PipedOutputStream 已经和其它 </span></span><br><span class="line">		<span class="comment">// PipedInputStream 连接了(sink != null) </span></span><br><span class="line">		<span class="comment">// 或者 PipedInputStream 已经被其它 PipedOutputStream</span></span><br><span class="line">		<span class="comment">// 连接了(snk.connected)，</span></span><br><span class="line">		<span class="comment">// 则直接抛出 IOException("Already connected")</span></span><br><span class="line">		<span class="comment">// 表明 PipedInputStream 和 PipedOutputStream 已经被</span></span><br><span class="line">		<span class="comment">// connect 过了。</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Already connected"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sink = snk;</span><br><span class="line">    snk.in = -<span class="number">1</span>;</span><br><span class="line">    snk.out = <span class="number">0</span>;</span><br><span class="line">    snk.connected = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 每一个 PipedOutputStream 对象，内部持有一个 PipedInputStream 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PipedInputStream sink;</span><br></pre></td></tr></table></figure>
<p>表示这个 OutputStream 的输出的目的地。</p>
<p>由上面的 connect 的实现，可知，PipedOutputStream 和 PipedInputStream 永远是 1:1 的关系，一个 PipedOutputStream 对象只能和一个 PipedInputStream 进行 connect，反之亦然。否则，直接 IOException(“Already connected”);</p>
<p>所以，这里的 pipe 就像管道一样，一个出口，一个入口。而不是像消息系统，那样，可以有多个消费者（PipedInputStream），多个生产者（PipedOutputStream）。</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><blockquote>
<p>Typically, data is written to a PipedOutputStream object by one thread and data is read from the connected PipedInputStream by some other thread</p>
<p>Typically, data is read from a PipedInputStream object by one thread and data is written to the corresponding PipedOutputStream by some other thread.</p>
</blockquote>
<p>所以通常是使用两个线程来使用 PipedOutputStream 和 PipedInputStream。对于使用 PipedOutputStream 向 pipe 中写入数据的线程可以认为是生产者，使用 PipedInputStream 读取数据的线程可以认为是 消费者。</p>
<p>pipe 是线程安全的：<br>尽管 pipe 是 1：1 的 PipedOutputStream 和 PipedInputStream 互相连接，但是 PipedOutputStream 和 PipedInputStream 的对象，可以由多个线程，同时使用。也就是说 PipedOutputStream 和 PipedInputStream 两个对象，构成了一个线程安全的 pipe , 然后多个线程可以通过这个 pipe 来生产和消费数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------------------------------------+</span><br><span class="line">|                                                     |</span><br><span class="line">| ThreadA                                             |</span><br><span class="line">|         ↘                                Thread1   |</span><br><span class="line">| ThreadB →    +----------------------+  ↗           |</span><br><span class="line">|              |  ===== pipe =======&gt; |  → Thread2    |</span><br><span class="line">| ThreadC →    +----------------------+  ↘           |</span><br><span class="line">|                                          Thread3    |</span><br><span class="line">| ThreadD ↗                                          |</span><br><span class="line">|                                                     |</span><br><span class="line">+-----------------------------------------------------+</span><br></pre></td></tr></table></figure>
<p>如上图所示，ThreadA， ThreadB，ThreadC，ThreadD 持有PipedOutputStream 可以向 pipe 中写入数据，而 Thread1，Thread2，Thread3 持有 PipedInputStream 可以从 pipe 中读取数据。</p>
<p>虽然，我们可以这样使用pipe, 但是这里存在一个问题:<br>例如 对于 Thread2 这个 reader ，如果它没有调用了 read 之后，没有调用 close 方法，然后线程 Thread2 终止了。则此时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span>  <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// readSide 就是 Thread2, </span></span><br><span class="line">	<span class="comment">// 但是，之后 Thread2 终止，且没有调用 close</span></span><br><span class="line">	<span class="comment">// 则 closedByReader = false</span></span><br><span class="line">    readSide = Thread.currentThread();</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// write 之前，进行状态判断</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkStateForReceive</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!connected) &#123; <span class="comment">// connected = true</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe not connected"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (closedByWriter || closedByReader) &#123; <span class="comment">// closedByReader = false</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe closed"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readSide != <span class="keyword">null</span> &amp;&amp; !readSide.isAlive()) &#123;</span><br><span class="line">		<span class="comment">// 此时进入这个分支，由于 Thread2 已经终止，</span></span><br><span class="line">		<span class="comment">// 所以，当前 write 线程（ThreadD）</span></span><br><span class="line">		<span class="comment">// ThreadD 在 write 时出现 IOException("Read end dead")</span></span><br><span class="line">		<span class="comment">// 而，如果 Thread1， 进行正常的 read 操作，则是可以</span></span><br><span class="line">		<span class="comment">// 正常进行的，而线程 ThreadA 进行 write 操作，也就可以</span></span><br><span class="line">		<span class="comment">// 正常进行了，所以这对 ThreadD 来说，有点莫名其妙</span></span><br><span class="line">		<span class="comment">// ThreadD write 就失败了，而　ThreadA　却成功了。</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Read end dead"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实，造成这种状况的根本，原因，在于:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PipedInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> closedByWriter = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> closedByReader = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> connected = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Thread readSide;</span><br><span class="line">    Thread writeSide;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PipedInputStream 只跟踪了最近一次在 pipe 上执行 read 和 write 操作的线程。所以，也就无法，在其中一个 reader 或者， writer 出现问题的时候，通知，其它的线程。</p>
<p>再考虑，如果 Thread2 在终止之前调用了 close 方法呢，其实也还是有问题，Thread2 在没有通过其它 reader 的情况下，就直接将 pipe 给关闭了，这是否对其它正在工作的 reader 造成影响。所以，对于在同一个 pipe 上进行 read 和 write 的线程，维护 pipe 的状态，是一个大的问题。</p>
<p>所以，pipe 最好，还是一个线程进行 write 操作，另一个线程进行 read 操作，比较好。或者 一个线程 write , 并执行 close 操作，多个线程 read. 或者 多个线程 write, 然后一个线程 read, 由这个 read 线程来维护 pipe 的 close 操作.</p>
<p>对于 pipe 来说，是有吞吐量的，其吞吐量就是 创建 PipedInputStream 时的参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PipedInputStream</span><span class="params">(PipedOutputStream src, <span class="keyword">int</span> pipeSize)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     initPipe(pipeSize);</span><br><span class="line">     connect(src);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PIPE_SIZE = <span class="number">1024</span>;</span><br></pre></td></tr></table></figure>
<p>就是 pipeSize， 默认是 1024 个字节。一旦，向这个 pipe 写入 1024 个字节之后，如果不进行消费，则 PipedOutputStream.write 操作将进入 wait 状态，直到，有数据被消费，write 才有空间，继续写入数据。</p>
<p>同理，如果 pipe 中没有数据，没有进行 write 操作，或者 pipe 中的 byte 被消费完毕，则 PipedInputStream.read 操作将进入 wait 状态。直到，有数据被写入，read 才可以读取到数据。</p>
<p>PipedInputStream 不支持，mark &amp; reset.</p>
<h4 id="pipe的关闭："><a href="#pipe的关闭：" class="headerlink" title="pipe的关闭："></a>pipe的关闭：</h4><ul>
<li><p>PipedOutputStream 关闭：</p>
<p>  当 PipedOutputStream 调用 close 时，使得 PipedInputStream.closedByWriter = true.<br>  表明，pipe 被 writer 线程关闭了，也就是 write 线程调用了 PipedOutputStream.close 关闭了 pipe. 如果是这样，说明流，再不会产生数据了，则当前 PipedInputStream，直到数据读完之后。再次调用 read时, 将得到 -1，说明流已经读完毕了。</p>
<p>  对于 PipedOutputStream 如果在 close 之后，调用，write, 则会产生： IOException(“Pipe closed”);</p>
</li>
<li><p>PipedInputStream 关闭</p>
<p>  设置 closedByReader = true; ，表示 pipe 被 read 线程关闭了。此时，如果 PipedInputStream 调用 read 将直接：IOException(“Pipe closed”); 而不管流是否被读完。</p>
<p>  当然，对于 PipedOutputStream 写线程来说，其调用<br>  write 也会是 IOException(“Pipe closed”);</p>
</li>
</ul>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2016/09/11/IO-ObjectInputStream/">IO-ObjectInputStream</a><a class="next" href="/2016/09/09/IO-File/">IO-File</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/interface/" style="font-size: 15px;">interface</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/Collections/" style="font-size: 15px;">Collections</a> <a href="/tags/Collection/" style="font-size: 15px;">Collection</a> <a href="/tags/J-U-C/" style="font-size: 15px;">J.U.C</a> <a href="/tags/lock/" style="font-size: 15px;">lock</a> <a href="/tags/Semaphore/" style="font-size: 15px;">Semaphore</a> <a href="/tags/CountDownLatch/" style="font-size: 15px;">CountDownLatch</a> <a href="/tags/CyclicBarrier/" style="font-size: 15px;">CyclicBarrier</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/LinkedList/" style="font-size: 15px;">LinkedList</a> <a href="/tags/Queue/" style="font-size: 15px;">Queue</a> <a href="/tags/Set/" style="font-size: 15px;">Set</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/collection/" style="font-size: 15px;">collection</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/api/" style="font-size: 15px;">api</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/mvc/" style="font-size: 15px;">mvc</a> <a href="/tags/context/" style="font-size: 15px;">context</a> <a href="/tags/component-scan/" style="font-size: 15px;">component-scan</a> <a href="/tags/storm/" style="font-size: 15px;">storm</a> <a href="/tags/windows/" style="font-size: 15px;">windows</a> <a href="/tags/命令行/" style="font-size: 15px;">命令行</a> <a href="/tags/cmder/" style="font-size: 15px;">cmder</a> <a href="/tags/win/" style="font-size: 15px;">win</a> <a href="/tags/效率/" style="font-size: 15px;">效率</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/博客/" style="font-size: 15px;">博客</a> <a href="/tags/apache/" style="font-size: 15px;">apache</a> <a href="/tags/extends/" style="font-size: 15px;">extends</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/svn/" style="font-size: 15px;">svn</a> <a href="/tags/BlockingQueue/" style="font-size: 15px;">BlockingQueue</a> <a href="/tags/LinkedBlockingQueue/" style="font-size: 15px;">LinkedBlockingQueue</a> <a href="/tags/PriorityBlockingQueue/" style="font-size: 15px;">PriorityBlockingQueue</a> <a href="/tags/ConcurrentLinkedQueue/" style="font-size: 15px;">ConcurrentLinkedQueue</a> <a href="/tags/CopyOnWriteArrayList/" style="font-size: 15px;">CopyOnWriteArrayList</a> <a href="/tags/接口/" style="font-size: 15px;">接口</a> <a href="/tags/抽象类/" style="font-size: 15px;">抽象类</a> <a href="/tags/Executor/" style="font-size: 15px;">Executor</a> <a href="/tags/ExecutorService/" style="font-size: 15px;">ExecutorService</a> <a href="/tags/CompletionService/" style="font-size: 15px;">CompletionService</a> <a href="/tags/ThreadPoolExecutor/" style="font-size: 15px;">ThreadPoolExecutor</a> <a href="/tags/vim/" style="font-size: 15px;">vim</a> <a href="/tags/vundle/" style="font-size: 15px;">vundle</a> <a href="/tags/ArrayList/" style="font-size: 15px;">ArrayList</a> <a href="/tags/log/" style="font-size: 15px;">log</a> <a href="/tags/index/" style="font-size: 15px;">index</a> <a href="/tags/concepts/" style="font-size: 15px;">concepts</a> <a href="/tags/Timer/" style="font-size: 15px;">Timer</a> <a href="/tags/TimerTask/" style="font-size: 15px;">TimerTask</a> <a href="/tags/ConcurrentMap/" style="font-size: 15px;">ConcurrentMap</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 15px;">ConcurrentHashMap</a> <a href="/tags/HashMap/" style="font-size: 15px;">HashMap</a> <a href="/tags/ReentrantReadWriteLock/" style="font-size: 15px;">ReentrantReadWriteLock</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/SynchronousQueue/" style="font-size: 15px;">SynchronousQueue</a> <a href="/tags/ScheduledExecutorService/" style="font-size: 15px;">ScheduledExecutorService</a> <a href="/tags/AQS/" style="font-size: 15px;">AQS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/BigData-docker/">Windows 上安装 docker</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/mysql-0.路线/">Mysql学习路线</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/mysql-索引/">Mysql安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/Qunar基础框架-QSchedule/">Qunar基础框架-QSchedule</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/java集合构架中使用到的数据结构和算法/">java集合构架中使用到的数据结构和算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/20/reids-调试环境搭建/">redis-调试环境搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/31/OpenStack-安装/">OpenStack-安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/26/JVM-hotspot-GC机制/">JVM-hotspot-GC机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/11/netty-socketio + socket.io 实现消息推送/">netty-socketio + socket.io 实现消息推送</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/26/mongodb-安装/">mongodb-安装</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/a-ray-of-sunshine" title="github" target="_blank">github</a><ul></ul><a href="http://www.cnblogs.com/a-ray-of-sunshine" title="cnblog" target="_blank">cnblog</a><ul></ul><a href="http://blog.csdn.net/a_ray_of_sunshine" title="csdn" target="_blank">csdn</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Shawshank.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>