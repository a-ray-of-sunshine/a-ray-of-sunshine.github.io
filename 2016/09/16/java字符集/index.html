<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>java字符集 | Shawshank</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">java字符集</h1><a id="logo" href="/.">Shawshank</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">java字符集</h1><div class="post-meta">Sep 16, 2016</div><div class="post-content"><p>我们在java文件中写的代码的所有字符都是字符串。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia = <span class="number">123</span>;</span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"你好"</span>);</span><br></pre></td></tr></table></figure>
<p>上面的代码，使用二进制查看如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00000000: 696e 7420 6961 203d 2031 3233 3b0a 5374  int ia = 123;.St</span><br><span class="line">00000010: 7269 6e67 2073 7472 203d 206e 6577 2053  ring str = new S</span><br><span class="line">00000020: 7472 696e 6728 22e4 bda0 e5a5 bd22 293b  tring(&quot;......&quot;);</span><br><span class="line">00000030: 0a                                       .</span><br></pre></td></tr></table></figure>
<p>可以看到，空格： 0x20, 分号： 0x3b, 换行：0x0a, 引号：0x22</p>
<p>其实对于，计算机来说，它根本就不知道，任何所谓，字符串，汉字，英文字母，数字等等。其实在计算机上面所有我们所能看到的所谓汉字，英文字母，数字都是图片（可以简单认为是图片，或者说是 图形 graph）。</p>
<p>那么，如何存储这些图形呢？ 例如：在　Hello.java 文件中有这样一句代码片断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"你好"</span>);</span><br></pre></td></tr></table></figure>
<p>现在，已经知道 <code>String</code> 其实是6个图形。那么 Hello.java 文件中是要存储这 6 个图形数据吗？图形数据如何表示呢？由谁来定 S 个图形的数据具体是什么呢？ 假如由当前的使用的编辑器来定，则 上面的代码是在 eclipse 中编辑的，所以对于  eclipse 它可以定 S 这个字符的图形数据。eclipse 知道如何解析，并显示这个字符。但是，问题来了，我要使用 notepad.exe 来查看 Hello.java 文件，但是对于 notepad 来说，它并不清楚 eclipse 到底是存储的 S 这个图形的数据结构。则 notepad 肯定是无法正常显示出 S 这个字符了。</p>
<p>但是，事实上，使用 eclipse 编写的代码，notepad 等，任何文本编辑器都可以正常打开。并显示出 String 这些字符。这是怎么回事呢？难道所有文本编辑器都相互将如何保存和显示文本的格式都公开了，当 notepad 打开 eclipse 编辑的 Hello.java 时，就使用 eclipse 的图形解析程序，将 Hello.java 中存储的图形数据。进行解析展示。</p>
<p>但是，如果是这样，notepad 就需要知道 Hello.java 这个文件是 eclipse 编辑的，而不是 notepad++ 或者 ue 等编辑器编辑的。所以 对于每一个文本编辑器，都必须要在编辑的文件中标记清楚，这个文件是由什么工具编辑的。</p>
<p>显然，对于字符的保存和显示所以按照上面的思路去实现，每个文本编辑器要打开显示一个文件将变得非常复杂。</p>
<p>上面的思路是：Hello.java 中就存储，字符的图形数据，这个图形数据可能非常复杂。不同的字符，要表达清楚这个字符，可能图形数据完全不同，如果按照这个思路实现，文本存储，将使得文本的显示变得异常复杂（需要解析每一个图形数据）。并且，常用的字符，就那么多。例如一本 100 万字的小说，其中常用字可能就只有 2000 个，所以，如果使用上面的实现，则同一个字符，将要在这个小说文件中存储 1000000 / 2000 = 500 个完全相同的字符数据。例如 “我” 这个常用字，其图形数据需要 20 字节（假设的，真实需要描述这个字符肯定比较复杂）。这样的话，20 * 500 = 10000, 大约需要 10kb. 而对于每一个字符，其图形数据肯定是完全一样的，那么每出现一次，就存储一次，完全是没有必要的，这样做非常浪费存储空间。</p>
<p>考虑下面的思路：给每一个字符编号，每一个字符对应惟一的一个编号，然后在文件中存储这个编号就可以了。然后，另外创建一个文件 CharsetMapFile（字符编号映射文件），这个文件中存储所有的字符的图形数据和编号。当向一个文本文件中写入一个字符时，就将其编号保存到这个文件中。</p>
<p>当 notepad 打开这个文件时，所读到的全部是字符编号，就到 CharsetMapFile 找到，编号对应的图形数据，然后，就可以正常显示出文件了。</p>
<p>这样做的，图形数据只需要在 CharsetMapFile 存储一份就可以了。所有的文本文件都存储字符编号。</p>
<p>假设，使用 2 个字节进行编号，则一共可以有 2 ^ ( 2 * 8 ) = 2 ^ 16 = 65536 个编号。所以可以有 65536 个字符，可以使用 2 个字节来表示。 常用汉字，英文字母，数字，标点符号也就 3，4千个字符。可见使用 2 个字节来对字符进行编号完全可行。</p>
<p>上面的假设成为了现实，CharsetMapFile 其实就是所谓 字符集（Charset）。字符集就是对字符进行编号。所谓不同的字符集其实就是相同的字符由于编码规则不同，从而造成同一个字符其所对应的编号不同，则这两种编码规则，将产生不同的字符集。</p>
<p>例如： UNICODE 字符集，其中按字形顺序进行编码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">仨： 0x4EE8 </span><br><span class="line">̩仩： 0x4EE9</span><br><span class="line">仪： 0x4EEA</span><br><span class="line">仫： 0x4EEB</span><br><span class="line">们： 0x4EEC</span><br></pre></td></tr></table></figure>
<p>这些字符都是 亻偏旁，进行编码。</p>
<p>对于 gb2312 使用将汉字，按照拼音进行排列，然后，开始逐个编码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">鞍：0xB0B0 （0x978D）</span><br><span class="line">氨：0xB0B1 （0x6C28）</span><br><span class="line">安：0xB0B2 （0x5B89）</span><br><span class="line">俺：0xB0B3 （0x4FFA）</span><br><span class="line">按：0xB0B4 （0x6309）</span><br><span class="line">暗：0xB0B5 （0x6697）</span><br></pre></td></tr></table></figure>
<p>这些字符都是按拼音 an 来进行编码。其中括号内的是该字符的 unicode 编码。</p>
<p>有了字符集的概念，就可以重新考虑，Hello.java 如何存储了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 使用 unicode 表示</span><br><span class="line"></span><br><span class="line">	0x0074  0x0067              0x4F60</span><br><span class="line">	  ↓       ↓                    ↓</span><br><span class="line">	S t r i n g str = new String(&quot;你好&quot;);</span><br><span class="line">	↑     ↑                         ↑</span><br><span class="line"> 0x0053 0x0069                   0x597D</span><br></pre></td></tr></table></figure>
<p>上面的代码中的每一个字符都有一个2个字节的unicde码。那么，文件就可以直接将这些 unicode 代码保存起来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">S:0x0053 t:0x0074 r:0x0072 i:0x0069 n:0x006e g:0x0067 (空格):0x0020 </span><br><span class="line">s::0x0073 t:0x0074 r:0x0072 (空格):0x0020 =:0x003d (空格):0x0020 </span><br><span class="line">n:0x006e e:0x0065 w:0x0077 (空格):0x0020 S:0x0053 t:0x0074 r:0x0072 </span><br><span class="line">i:0x0069 n:0x006e g:0x0067 (:0x0028 &quot;:0x0022 </span><br><span class="line">你:0x4F60 好:0x597D</span><br><span class="line">&quot;:0x0022 ):0x0029 ;:0x003b</span><br><span class="line"></span><br><span class="line">===&gt;</span><br><span class="line">unicode: 对应  UTF-16BE 存储。</span><br><span class="line">0053 0074 0072 0069 006e 0067 0020 0073 0074 0072 0020 003d 0020 006e 0065 </span><br><span class="line">0077 0020 0053 0074 0072 0069 006e 0067 0028 0022 4F60 597D 0022 0029 003b</span><br><span class="line"></span><br><span class="line">utf-8:</span><br><span class="line">5374 7269 6e67 2073 7472 203d 206e 6577 2053 7472 696e 6728 22e4 bda0 e5a5 bd22 293b</span><br></pre></td></tr></table></figure>
<p><code>String str = new String(&quot;你好&quot;);</code> 30个字符，所以，上面使用 unicode 编码存储，一共是 30 * 2 = 60 个字节。</p>
<p>但是，实际 Hello.java 中，存储却不是这样。Hello.java 文件使用的文件编码是 utf-8, 这是一种对 unicode 编码的线性映射编码。可以说 unicode 是一种编码规范，这种规范，将所有的字符进行了编码，分配了惟一的 UNICODE。 但是呢，由于存储空间的问题，例如，一部 100 万字的英文小说，如果使用 unicode 编码来存储，将浪费一半的空间。因为，英文字母和常用的标点符号的 unicode 编码中，前一个字节，总是 0x00,所以可以考虑，将其去掉，这样，存储空间将节省一半。所以就出现了，所谓 utf-8 编码，其实 utf-8,使用的是 unicode 的编码，然后，对编码进行了线性变换，这种线性变换后的存储将更加适合网络传输，更加安全。所以 utf-8 算是对 unicode 的一种具体实现。</p>
<p>其实，我们上面设计的 unicode 存储，就是 UTF-16BE (unicode 大端存储)存储方案。当我们，使用 windows 自带的 记事本（notepad.exe） 程序，保存 <code>String str = new String(&quot;你好&quot;);</code> 然后选择注意在保存时选择，UNICODE 格式。将保存成上面 unicode 格式的数据。</p>
<p>notepad 支持 4 种编码格式:</p>
<p>ANSI: 和系统设置的区域有关，简体中文环境下 ANSI 就是 GBK 编码<br>Unicode:            UTF-16LE unicode 小端<br>Unicode big endian: UTF-16BE unicode 大端<br>UTF-8: utf-8 编码</p>
<p>UTF-16LE 和 UTF-16BE 完全使用字符的 unicode 码，区别就是表示字符的 2 个字节的高位字节和底位字节的顺序。高位字节先存储为 big endian, 低位字节先存储为 little endian. 例如：’你’ unicode 编码是： 0x4F60， 其高位字节是： 0x4F, 低位字节是：0x60, 则 0x4F60 就是大端存储，而 0x604F, 则是小端存储。</p>
<p>对于 java 语言来说，其 数值和字符串 都使用 Big Endian 的存储方式。</p>
<p>String 类的几个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回指定索引位置的字符。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 返回指定索引位置的 codepoint， codepoint 就是字符的 unicode 编码。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">codePointAt</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span>[] <span class="title">getBytes</span><span class="params">(Charset charset)</span></span></span><br></pre></td></tr></table></figure>
<p>java 中的 char 表示的就是字符，’a’ , ‘你’, ‘!’, ‘界’ ，都是字符。那么，char 如何存储呢。 char == 字符，由上面的分析，可以字符可以由，字符集中的编码来表示，例如： ‘你’: unicode: 0x4F60  gbk: 0xC4E3 。不同的字符集有不同的编码。在 java 在使用 Unicode big endian 来表示一个字符 &lt;==&gt; UTF-16 编码，也就是直接使用字符的 unicode 编码来代表一个字符。</p>
<p>也就说，在代码中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \u0030 表示 unicode 字符(char) 0,</span></span><br><span class="line"><span class="comment">// 所以下面的语句相当于</span></span><br><span class="line"><span class="comment">// int iii = (char)\u0030; &lt;==&gt; int iii = (char)0;</span></span><br><span class="line"><span class="comment">// 注意，下面的用法是推荐的，因为，这种写法其实是已经</span></span><br><span class="line"><span class="comment">// 和 char 和 unicode 没有关系也，</span></span><br><span class="line"><span class="comment">// 之所以下面的赋值，可以通过编译，是因为 \u0030 对于编译器来说</span></span><br><span class="line"><span class="comment">// \u0030 和 直接写 0 是完全等价的。</span></span><br><span class="line">/ 字母 i: \u0069, n: \u006e, t: \u0074</span><br><span class="line"><span class="comment">// 所以 int &lt;==&gt; \u0069\u006e\u0074</span></span><br><span class="line"><span class="comment">// 所以下面的代码： \u0069\u006e\u0074 some = 123;</span></span><br><span class="line"><span class="comment">// 就相当于 int some = 123;</span></span><br><span class="line"><span class="comment">// 并且可以正常这样定义的变量，可以正常编码通过并运行。</span></span><br><span class="line"><span class="keyword">int</span> iii = \u0030;</span><br><span class="line"><span class="comment">// 将打印出 0</span></span><br><span class="line">System.out.println(iii);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 \u0030 使用 ' 包裹，表示 '\u0030' 是一个 char, </span></span><br><span class="line"><span class="comment">// '\u0030' 是一个字符 '0', 而字符 '0'，使用 unicode来编码，</span></span><br><span class="line"><span class="comment">// 其对应的 unicode 码是 0x0030，也就是说 '0', 内部存储的字节是 0x0030</span></span><br><span class="line"><span class="comment">// 所以下面的赋值操作相当于： int qqq = (int)0x0030 = (int)48</span></span><br><span class="line"><span class="comment">// 也就是对 char 内部存储的数值进行了类型转换</span></span><br><span class="line"><span class="comment">// 所以自然，将其转换为一个整数 qqq = 48</span></span><br><span class="line"><span class="comment">// 但是，如果把 '\u0030' 赋值给一个 char 变量，</span></span><br><span class="line"><span class="comment">// 则打印出来的就是 0, 对于 char 变量来说 \u0030(也即：0x0030)</span></span><br><span class="line"><span class="comment">// 就是 0 的编码，而打印字符，自然打印的是</span></span><br><span class="line"><span class="comment">// 编码所对应的字符 '0', 而不是编码本身的值。</span></span><br><span class="line"><span class="keyword">int</span> qqq = <span class="string">'\u0030'</span>;</span><br><span class="line"><span class="comment">// 打印出 48</span></span><br><span class="line">System.out.println(qqq);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用 unicode 来作变量的名称</span></span><br><span class="line"><span class="comment">// 使用 '你好' 的 unicode 编码</span></span><br><span class="line"><span class="keyword">int</span> \u4f60\u597d = <span class="number">12</span>;</span><br><span class="line">System.out.println(\u4f60\u597d);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者直接使用 中文 都是可以的</span></span><br><span class="line"><span class="keyword">int</span> 你好<span class="number">2</span> = <span class="number">12</span>;</span><br><span class="line">System.out.println(你好<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>从变量的命名，也可以看到，java 最终将这些字面量（变量名）和 字符串，都以 UTF-16 编码方式存储。</p>
<p>所以，我们甚至可以完全使用 unicode 字符来编码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意下面的代码并不是乱码，只是使用 unicode 字符来编码</span></span><br><span class="line"><span class="comment">// 其含义和 int some = 123; </span></span><br><span class="line"><span class="comment">// 每一个 unicode 编码都和上面的字符一一对应。</span></span><br><span class="line"><span class="comment">// 并且这个代码是完全可以编码通过的。正常运行的</span></span><br><span class="line"><span class="comment">// 并且如果再定义一个名称为 some 的变量，编译器会报出 重复的变量 异常。</span></span><br><span class="line">\u0069\u006e\u0074\u0020\u0073\u006f\u006d\u0065\u0020\u003d\u0020\u0031\u0032\u0033\u003b</span><br><span class="line">System.out.println(\u0073\u006f\u006d\u0065);</span><br></pre></td></tr></table></figure>
<p>同时，对于字符串来说：</p>
<p>String a = “你好world世界”;<br>&lt;==&gt;<br>a = new String({‘你’, ‘好’, ‘w’, ‘o’, ‘r’, ‘l’, ‘d’, ‘世’, ‘界’});<br>&lt;==&gt;<br>a = new String({‘\u4f60’, ‘\u597d’, ‘\u0077’, ‘o’, ‘r’, ‘l’, ‘d’, ‘世’, ‘界’});</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">String ss = <span class="string">"你好"</span>;</span><br><span class="line">System.out.println(ss);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>[] c0 = &#123;<span class="string">'你'</span>, <span class="string">'好'</span>&#125;;</span><br><span class="line">String s0 = <span class="keyword">new</span> String(c0);</span><br><span class="line">System.out.println(s0);</span><br><span class="line"></span><br><span class="line"><span class="comment">// java 中的 char 默认使用 UTF-16 来表示字符，而 utf-16 编码完全和 unicode 对应</span></span><br><span class="line"><span class="comment">// 所以 char a = '\u4f60' ,代表 utf-16 的字符：你</span></span><br><span class="line"><span class="keyword">char</span>[] c1 = &#123;<span class="string">'\u4f60'</span>, <span class="string">'\u597d'</span>, <span class="string">'\u0077'</span>, <span class="string">'\u006f'</span>, <span class="string">'\u0072'</span>, <span class="string">'\u006c'</span>, <span class="string">'\u0064'</span>,</span><br><span class="line">		<span class="string">'\u4e16'</span>, <span class="string">'\u754c'</span>&#125;;</span><br><span class="line">String s1 = <span class="keyword">new</span> String(c1);</span><br><span class="line">System.out.println(s1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于 byte 数组，byte 本身和字符没有关系，只有指定的字符集，</span></span><br><span class="line"><span class="comment">// byte 才能够，通过字符集，byte的值才能够映射成字符集中某个字符的索引（当作这个字符集的索引使用）。</span></span><br><span class="line"><span class="comment">// 然后这个索引，可以通过字符集找到，其所对应的字符，</span></span><br><span class="line"><span class="comment">// 0x4f, 0x60, 0x59, 0x7d 这个四个字节，如果代表数值，则分别是：79， 96，89，125</span></span><br><span class="line"><span class="comment">// 现在指定了，b1 可以使用 字符集 "utf-16" 来进行解码（decode）</span></span><br><span class="line"><span class="comment">// 由 utf-16 的规则，2个字节对应一个字符，并且使用大端存储，所以</span></span><br><span class="line"><span class="comment">// b1[0], b1[1] 按大端形成一个索引： 0x4f60  这个索引在 utf-16 中对应字符： 你</span></span><br><span class="line"><span class="comment">// b1[2], b1[3] 按大端形成一个索引： 0x597d 这个索引在 utf-16 中对应字符： 好</span></span><br><span class="line"><span class="keyword">byte</span>[] b1 = &#123;<span class="number">0x4f</span>, <span class="number">0x60</span>, <span class="number">0x59</span>, <span class="number">0x7d</span>&#125;;</span><br><span class="line">String s2 = <span class="keyword">new</span> String(b1, Charset.forName(<span class="string">"utf-16"</span>));</span><br><span class="line">System.out.println(s2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] b2 = &#123;<span class="number">0x60</span>, <span class="number">0x4f</span>, <span class="number">0x7d</span>, <span class="number">0x59</span>&#125;;</span><br><span class="line">String s3 = <span class="keyword">new</span> String(b2, Charset.forName(<span class="string">"utf-16le"</span>));</span><br><span class="line">System.out.println(s3);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] b3 = &#123;(<span class="keyword">byte</span>) <span class="number">0xe4</span>, (<span class="keyword">byte</span>) <span class="number">0xbd</span>, (<span class="keyword">byte</span>) <span class="number">0xa0</span>, (<span class="keyword">byte</span>) <span class="number">0xe5</span>, (<span class="keyword">byte</span>) <span class="number">0xa5</span>, (<span class="keyword">byte</span>) <span class="number">0xbd</span>&#125;;</span><br><span class="line">String s4 = <span class="keyword">new</span> String(b3, Charset.forName(<span class="string">"utf-8"</span>));</span><br><span class="line">System.out.println(s4);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同理 你 GBK 编码： 0xc4e3 </span></span><br><span class="line"><span class="comment">//      好 GBK 编码： 0xbac3</span></span><br><span class="line"><span class="keyword">byte</span>[] b4 = &#123;(<span class="keyword">byte</span>) <span class="number">0xc4</span>, (<span class="keyword">byte</span>) <span class="number">0xe3</span>, (<span class="keyword">byte</span>) <span class="number">0xba</span>, (<span class="keyword">byte</span>) <span class="number">0xc3</span>&#125;;</span><br><span class="line">String s5 = <span class="keyword">new</span> String(b4, Charset.forName(<span class="string">"gbk"</span>));</span><br><span class="line">System.out.println(s5);</span><br><span class="line"></span><br><span class="line"><span class="comment">// big5 编码：</span></span><br><span class="line"><span class="keyword">byte</span>[] b5 = &#123;(<span class="keyword">byte</span>) <span class="number">0xa7</span>, (<span class="keyword">byte</span>) <span class="number">0x41</span>, (<span class="keyword">byte</span>) <span class="number">0xa6</span>, (<span class="keyword">byte</span>) <span class="number">0x6e</span>&#125;;</span><br><span class="line">String s6 = <span class="keyword">new</span> String(b5, Charset.forName(<span class="string">"big5"</span>));</span><br><span class="line">System.out.println(s6);</span><br></pre></td></tr></table></figure>
<p>Charset.defaultCharset() 方法可以获得默认字符集。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String.getChars</span></span><br><span class="line"><span class="comment">// 这个方法，将 String 内部持有数据的 char数组，拷贝到 dst 参数中。</span></span><br><span class="line"><span class="comment">// 并没有对 value 做任何处理，这样就可以 反推出 value 默认的存储字符集。</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">int</span> srcBegin, <span class="keyword">int</span> srcEnd, <span class="keyword">char</span> dst[], <span class="keyword">int</span> dstBegin)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (srcBegin &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcBegin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (srcEnd &gt; value.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcEnd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (srcBegin &gt; srcEnd) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcEnd - srcBegin);</span><br><span class="line">    &#125;</span><br><span class="line">    System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ch 中持有 String 内部 value 字符数组的数据</span></span><br><span class="line"><span class="comment">// 将 ch 打印出来</span></span><br><span class="line"><span class="comment">// 4f60 597d 77 6f 72 6c 64 4e16 754c</span></span><br><span class="line"><span class="comment">// '你' 的 utf16 编码是： 4f60,</span></span><br><span class="line"><span class="comment">// '界' 的 utf16 编码是： 754c</span></span><br><span class="line"><span class="comment">// 所以，这进一步印证了，Java 中的 char 使用是 utf-16编码存储。</span></span><br><span class="line">String str = <span class="string">"你好world世界"</span>;</span><br><span class="line"><span class="keyword">char</span>[] ch = <span class="keyword">new</span> <span class="keyword">char</span>[str.length()];</span><br><span class="line">str.getChars(<span class="number">0</span>, str.length(), ch, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h2 id="源文件格式编码与-class-文件-编码"><a href="#源文件格式编码与-class-文件-编码" class="headerlink" title="源文件格式编码与 class 文件 编码"></a>源文件格式编码与 class 文件 编码</h2><p>对于 java 源文件来说，可以使用不同类型的编码，例如 gbk, utf-8, 自然，其中的出现的字符串，也是 gbk ,utf-8编码。但是经过 javac 编译之后 生成的class 文件却严格使用 utf-16 编码，所以不同类型的文件，经过编码之后，其编码将发生转换。</p>
<p>but,问题来了, 当我们在 windows 命令行下面调用 javac 执行编译的时候，javac 如何知道当前 Hello.java 文件的编码格式呢？ 对于文本文件 Hello.java 来说，其文件中并没有关于，文件是什么编码格式的说明。所以，必须从外部，获得文件格式。 </p>
<p>javac 将使用当前系统环境的默认编码，ANSI，在 windows 平台上 ANSI 映射为 bgk 字符集。所以如果 Hello.java 使用的是  gbk 字符集，那么下面的编译过程将不会出现问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// Hello.java</span><br><span class="line">public class Hello&#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;源文件&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当 Hello.java 保存为 gbk 编码格式时</span><br><span class="line">// 下面的编译不会出现问题</span><br><span class="line">javac Hello.java</span><br><span class="line"></span><br><span class="line">// 当 Hello.java 保存为 utf-8 编码会出现问题：</span><br><span class="line">$ javac Hello.java</span><br><span class="line">Hello.java:5: 错误: 编码GBK的不可映射字符</span><br><span class="line">            System.out.println(&quot;婧愭枃浠?);</span><br><span class="line">                                    ^</span><br><span class="line">Hello.java:5: 错误: 未结束的字符串文字</span><br><span class="line">            System.out.println(&quot;婧愭枃浠?);</span><br><span class="line">                               ^</span><br><span class="line">Hello.java:5: 错误: 需要&apos;;&apos;</span><br><span class="line">            System.out.println(&quot;婧愭枃浠?);</span><br><span class="line">                                       ^</span><br><span class="line">Hello.java:7: 错误: 解析时已到达文件结尾</span><br><span class="line">&#125;</span><br><span class="line"> ^</span><br><span class="line">4 个错误</span><br><span class="line"></span><br><span class="line">编译过程中，出现了问题，其实就是 javac 默认将 Hello.java 文件中出现的 </span><br><span class="line"></span><br><span class="line">&quot;源文件&quot; 这三个字符当作 gbk 编码处理，然后，将其转换成 utf-16, 但是其实这三个字符是 utf-8 编码，所以误认 gbk 编码，然后按照，gbk 2 个字节一个字符去解析，结果发现，其中的某两个字节构成的字符在 gbk 中并没有可以映射的字符。</span><br><span class="line"></span><br><span class="line">这样说吧： gbk 是2个字节构成一个字符，则应该使用 0x0000 - 0xFFFF 当作编码，但是对于 gbk 来说，并不是上面的这 65535 这个编码已经全部被使用了，所以必然存在，某个编码，假设： 0xE6F8(注意只是假设，但肯定存在这种情况) 这个编码在 gbk 中并没有任何字符和其对应。 </span><br><span class="line">而凑巧上面的 utf-8 中包含 0xE6 , 0xF8 , 被误解析成了一个 gbk 字符。此时，由于我们知道，javac 并会把字符转换成 utf-16, 所以需要将它所认为的 gkb 字符 0xE6F8 转换成 utf-16, 而事实是 gbk 中并不存在编码为 0xE6F8 的字符，所以编译程序的字符转换失败了，编码当然不能通过了。所以出现：编码GBK的不可映射字符。</span><br></pre></td></tr></table></figure>
<p>其实，上面使用 javac 编码 utf-8 源文件时，之所以出现问题，就是 javac 采用了默认的字符编码。 查看 javac 帮助，可知 javac 支持一个参数: encoding</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 直接在命令行 输入 javac , 然后 回车</span><br><span class="line">-encoding &lt;编码&gt; 指定源文件使用的字符编码</span><br></pre></td></tr></table></figure>
<p>所以，如果 代码源文件不同平台默认的字符集，则需要手动指定其编码即可，正常编码了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 还是上面的保存成 utf-8 格式的 Hello.java 文件</span><br><span class="line">// 下面的命令可以成功编码 utf-8 源文件。</span><br><span class="line">javac -encoding utf-8 Hello.java</span><br></pre></td></tr></table></figure>
<p>类似地，可以将 Hello.java 使用 记事本，保存成 utf-16le 和 utf-16be 格式，然后<br>使用 javac 编译，同样也是编译不通过，所以需要显示指定，文件编码，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// utf-16le 和 utf-16be 编码的 Hello.java 文件</span><br><span class="line">// 使用下面的命令可以成功编译</span><br><span class="line">javac -encoding utf-16 Hello.java</span><br></pre></td></tr></table></figure>
<p>如何查看当前系统所支持的所有字符集？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SortedMap&lt;String,Charset&gt; characters = Charset.availableCharsets();</span><br><span class="line"><span class="keyword">for</span>(String name: characters.keySet())&#123;</span><br><span class="line">	Charset charset = characters.get(name);</span><br><span class="line">	<span class="comment">// 字符集的名称</span></span><br><span class="line">	System.out.print(name + <span class="string">" : "</span> + charset + <span class="string">" "</span>);</span><br><span class="line">	<span class="comment">// 字符集的别名</span></span><br><span class="line">	System.out.println(charset.aliases());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 几个常用的字符集</span></span><br><span class="line">Big5 : Big5 [csBig5]</span><br><span class="line">GB18030 : GB18030 [gb18030-<span class="number">2000</span>]</span><br><span class="line">GB2312 : GB2312 [euc-cn, x-EUC-CN, gb2312-<span class="number">1980</span>, gb2312, gb2312-<span class="number">80</span>, EUC_CN, euccn]</span><br><span class="line">GBK : GBK [windows-<span class="number">936</span>, CP936]</span><br><span class="line">ISO-<span class="number">8859</span>-<span class="number">1</span> : ISO-<span class="number">8859</span>-<span class="number">1</span> [csISOLatin1, latin1, IBM-<span class="number">819</span>, iso-ir-<span class="number">100</span>, <span class="number">8859_1</span>, ISO_8859-<span class="number">1</span>:<span class="number">1987</span>, ISO_8859-<span class="number">1</span>, <span class="number">819</span>, l1, ISO8859-<span class="number">1</span>, IBM819, ISO_8859_1, ISO8859_1, cp819]</span><br><span class="line">US-ASCII : US-ASCII [cp367, ascii7, ISO646-US, <span class="number">646</span>, csASCII, us, iso_646.irv:<span class="number">1983</span>, ISO_646.irv:<span class="number">1991</span>, IBM367, ASCII, <span class="keyword">default</span>, ANSI_X3.4-<span class="number">1986</span>, ANSI_X3.4-<span class="number">1968</span>, iso-ir-<span class="number">6</span>]</span><br><span class="line">UTF-<span class="number">16</span> : UTF-<span class="number">16</span> [utf16, UnicodeBig, UTF_16, unicode]</span><br><span class="line">UTF-<span class="number">16</span>BE : UTF-<span class="number">16</span>BE [X-UTF-<span class="number">16</span>BE, UTF_16BE, ISO-<span class="number">10646</span>-UCS-<span class="number">2</span>, UnicodeBigUnmarked]</span><br><span class="line">UTF-<span class="number">16L</span>E : UTF-<span class="number">16L</span>E [UnicodeLittleUnmarked, UTF_16LE, X-UTF-<span class="number">16L</span>E]</span><br><span class="line">UTF-<span class="number">32</span> : UTF-<span class="number">32</span> [UTF32, UTF_32]</span><br><span class="line">UTF-<span class="number">32</span>BE : UTF-<span class="number">32</span>BE [X-UTF-<span class="number">32</span>BE, UTF_32BE]</span><br><span class="line">UTF-<span class="number">32L</span>E : UTF-<span class="number">32L</span>E [X-UTF-<span class="number">32L</span>E, UTF_32LE]</span><br><span class="line">UTF-<span class="number">8</span> : UTF-<span class="number">8</span> [unicode-<span class="number">1</span>-<span class="number">1</span>-utf-<span class="number">8</span>, UTF8]</span><br></pre></td></tr></table></figure>
<p><a href="http://www.biaozhuns.com/" target="_blank" rel="noopener">标准网</a></p>
<p><a href="http://blog.csdn.net/lcfeng1982/article/details/11482709" target="_blank" rel="noopener">区位码、gb2312、gbk编码之间的关系</a></p>
<p><a href="http://www.66ac.com/Java/JavaSE/20121204/22.html" target="_blank" rel="noopener">UTF-8 GBK GB2312 之间的区别和关系</a></p>
<p><a href="http://unicode.org/faq/utf_bom.html" target="_blank" rel="noopener">UTF-8, UTF-16, UTF-32 &amp; BOM</a></p>
<p><a href="https://www.ietf.org/rfc/rfc2781.txt" target="_blank" rel="noopener">UTF-16 编码规范</a></p>
<p><a href="https://tools.ietf.org/html/rfc3629" target="_blank" rel="noopener">UTF-8 编码规范</a></p>
<p><a href="https://www.microsoft.com/typography/otspec/cmap.htm" target="_blank" rel="noopener">Character To Glyph Index Mapping Table</a> 这篇文章中有讲到，如何将 character 映射到 字体文件的的某个具体的字符上。</p>
<p><a href="https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6cmap.html" target="_blank" rel="noopener">The ‘cmap’ table</a></p>
<h2 id="JDK-对各种字符集的支持，以及编码和解码"><a href="#JDK-对各种字符集的支持，以及编码和解码" class="headerlink" title="JDK 对各种字符集的支持，以及编码和解码"></a>JDK 对各种字符集的支持，以及编码和解码</h2><p>jdk提供了三个类用来处理各种字符集。</p>
<ul>
<li><p>字符集类 Charset</p>
<p>  java.nio.charset.Charset</p>
<blockquote>
<p>A named mapping between sequences of sixteen-bit Unicode code units and sequences of bytes. This class defines methods for creating decoders and encoders and for retrieving the various names associated with a charset.</p>
</blockquote>
</li>
<li><p>字符编码类 CharsetEncoder</p>
<p>  java.nio.charset.CharsetEncoder</p>
<blockquote>
<p>An engine that can transform a sequence of sixteen-bit Unicode characters into a sequence of bytes in a specific charset. </p>
</blockquote>
</li>
<li><p>字符解码类 CharsetDecoder</p>
<p>  java.nio.charset.CharsetDecoder</p>
<blockquote>
<p>An engine that can transform a sequence of bytes in a specific charset into a sequence of sixteen-bit Unicode characters. </p>
</blockquote>
</li>
</ul>
<p>这三个类都是抽象类，是各种具体的字符集的实现的共同基类。具体的字符集，需要继承 Charset 类，并实现下面两个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> CharsetDecoder <span class="title">newDecoder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> CharsetEncoder <span class="title">newEncoder</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>newDecoder 获得具体实现字符集的解码类。<br>newEncoder 获得具体实现字符含棉编码类。</p>
<p>各种字符集的实现在：</p>
<p>sun.nio.cs 和 sun.nio.cs.ext 包中</p>
<p>sun.nio.cs 在 jre\lib\rt.jar </p>
<p>sun.nio.cs.ext 在 jre\lib\charsets.jar</p>
<p>sun.nio.cs 包中有 UTF-8, UTF-16, UTF-16LE, UTF-16BE 等字符集的实现。</p>
<p>sun.nio.cs.ext包中有 GBK, BIG5 字符集的实现。</p>
<h3 id="CharsetProvider"><a href="#CharsetProvider" class="headerlink" title="CharsetProvider"></a>CharsetProvider</h3><p>java.nio.charset.spi.CharsetProvider 提供了 charsetForName 方法用来查找上面的具体字符集的实现。</p>
<h3 id="jvm-的默认字符集"><a href="#jvm-的默认字符集" class="headerlink" title="jvm 的默认字符集"></a>jvm 的默认字符集</h3><p>使用 System.getProperty(“file.encoding”) 可以获得 JVM 的默认字符集的名称。对于输入，输出字符流，如果不提供字符集参数，则使用这个默认字符集。</p>
<p>同时 jvm 提供的 Charset.defaultCharset() 方法返回 jvm 默认的 Charset 对象（字符集对象），这个默认的 Charset 对象，就是使用 file.encoding 作为默认的字符集名称创建的。</p>
<p>所以不，file.encoding 设置成 gbk 时， Charset.defaultCharset() 将返回以 gbk 字符集。</p>
<p>默认字符集的作用，就是在涉及到 char 转 byte 的API，如果没有提供字符集，没有提供字符集，则将使用这个默认的字符进行 char 转 byte 的操作。涉及到 char 转 byte 的 API 有：String.getBytes, 还有常用的 System.out.println 方法的类 PrintStream，这个类，如果指定字符集，则 All characters printed by a PrintStream are converted into bytes using the platform’s default character encoding. </p>
<p>还有 FileWriter 类直接使用默认的字符集对字符进行编码：</p>
<blockquote>
<p>Convenience class for writing character files. The constructors of this class assume that the default character encoding and the default byte-buffer size are acceptable. To specify these values yourself, construct an OutputStreamWriter on a FileOutputStream. </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设，启动 jvm 的时候，传递了参数</span></span><br><span class="line"><span class="comment">// -Dfile.encoding=gbk</span></span><br><span class="line"><span class="comment">// 并且 整个项目的编码是 utf-8, </span></span><br><span class="line"><span class="comment">// 则 eclipse console 的默认编码也是 utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前是 utf-16 编码</span></span><br><span class="line">String str = <span class="string">"abc测试字符123"</span>;</span><br><span class="line"><span class="comment">// 会使用 Charset.defaultCharset() 进行编码</span></span><br><span class="line"><span class="comment">// 将 utf-16 转换以默认的字符集，进行编码</span></span><br><span class="line"><span class="comment">// 如果 file.encoding 属性设置成 gbk 则</span></span><br><span class="line"><span class="comment">// 则  str 字符, 会将字符以 gbk 编码格式，</span></span><br><span class="line"><span class="comment">// 进行编码，使其转换成 gbk 编码字节，</span></span><br><span class="line"><span class="comment">// 所以对于显示设置，也需要改成 gbk 才可以正常显示。</span></span><br><span class="line"><span class="comment">// All characters printed by a PrintStream are converted into bytes </span></span><br><span class="line"><span class="comment">// using the platform's default character encoding</span></span><br><span class="line"><span class="comment">// 由于使用 defaultCharset str 最终将转换成 gbk 字节流</span></span><br><span class="line"><span class="comment">// 当输出到 eclipse 的 console 时，由于 console 的编码是 utf-8</span></span><br><span class="line"><span class="comment">// 所以下面的输出将出现乱码</span></span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 out 流进行 osw 底层使用 System.out, 但是</span></span><br><span class="line"><span class="comment">// 对 osw 指定了转码时使用的默认字符集为 utf-8</span></span><br><span class="line"><span class="comment">// 所以当  file.encoding = gbk 时，</span></span><br><span class="line"><span class="comment">// eclipse console, 才能够正常显示出中文来</span></span><br><span class="line"><span class="comment">// 而不会因为使用默认的字符集，而转成 gbk, 而 eclipse console 所以使用的字符集</span></span><br><span class="line"><span class="comment">// 是在 Run ... Run Configurations ... Common ... Encoding 里面进行设置</span></span><br><span class="line"><span class="comment">// 默认应该是和 项目的默认编码一致。</span></span><br><span class="line">OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(System.out, Charset.forName(<span class="string">"utf-8"</span>));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// 这里在 console 输出时，由于指定了编码 utf-8</span></span><br><span class="line">	<span class="comment">// 所以不会出现乱码。</span></span><br><span class="line">	osw.write(str);</span><br><span class="line">	osw.write(<span class="string">'\n'</span>);</span><br><span class="line">	osw.flush();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(Charset.defaultCharset());</span><br></pre></td></tr></table></figure>
<p><a href="http://www.cl.cam.ac.uk/~mgk25/unicode.html" target="_blank" rel="noopener">UTF-8 and Unicode FAQ for Unix/Linux</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-termi-hanzi/" target="_blank" rel="noopener">如何改造 Linux 虚拟终端显示文字</a></p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2016/09/23/centos7在vm中扩展容量/">centos7在vm中扩展容量</a><a class="next" href="/2016/09/12/IO-FilterInputStream/">IO-FilterInputStream</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/interface/" style="font-size: 15px;">interface</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/Collections/" style="font-size: 15px;">Collections</a> <a href="/tags/Collection/" style="font-size: 15px;">Collection</a> <a href="/tags/J-U-C/" style="font-size: 15px;">J.U.C</a> <a href="/tags/lock/" style="font-size: 15px;">lock</a> <a href="/tags/Semaphore/" style="font-size: 15px;">Semaphore</a> <a href="/tags/CountDownLatch/" style="font-size: 15px;">CountDownLatch</a> <a href="/tags/CyclicBarrier/" style="font-size: 15px;">CyclicBarrier</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/LinkedList/" style="font-size: 15px;">LinkedList</a> <a href="/tags/Queue/" style="font-size: 15px;">Queue</a> <a href="/tags/Set/" style="font-size: 15px;">Set</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/collection/" style="font-size: 15px;">collection</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/api/" style="font-size: 15px;">api</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/mvc/" style="font-size: 15px;">mvc</a> <a href="/tags/context/" style="font-size: 15px;">context</a> <a href="/tags/component-scan/" style="font-size: 15px;">component-scan</a> <a href="/tags/storm/" style="font-size: 15px;">storm</a> <a href="/tags/windows/" style="font-size: 15px;">windows</a> <a href="/tags/命令行/" style="font-size: 15px;">命令行</a> <a href="/tags/cmder/" style="font-size: 15px;">cmder</a> <a href="/tags/win/" style="font-size: 15px;">win</a> <a href="/tags/效率/" style="font-size: 15px;">效率</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/博客/" style="font-size: 15px;">博客</a> <a href="/tags/apache/" style="font-size: 15px;">apache</a> <a href="/tags/extends/" style="font-size: 15px;">extends</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/svn/" style="font-size: 15px;">svn</a> <a href="/tags/BlockingQueue/" style="font-size: 15px;">BlockingQueue</a> <a href="/tags/LinkedBlockingQueue/" style="font-size: 15px;">LinkedBlockingQueue</a> <a href="/tags/PriorityBlockingQueue/" style="font-size: 15px;">PriorityBlockingQueue</a> <a href="/tags/ConcurrentLinkedQueue/" style="font-size: 15px;">ConcurrentLinkedQueue</a> <a href="/tags/CopyOnWriteArrayList/" style="font-size: 15px;">CopyOnWriteArrayList</a> <a href="/tags/接口/" style="font-size: 15px;">接口</a> <a href="/tags/抽象类/" style="font-size: 15px;">抽象类</a> <a href="/tags/Executor/" style="font-size: 15px;">Executor</a> <a href="/tags/ExecutorService/" style="font-size: 15px;">ExecutorService</a> <a href="/tags/CompletionService/" style="font-size: 15px;">CompletionService</a> <a href="/tags/ThreadPoolExecutor/" style="font-size: 15px;">ThreadPoolExecutor</a> <a href="/tags/vim/" style="font-size: 15px;">vim</a> <a href="/tags/vundle/" style="font-size: 15px;">vundle</a> <a href="/tags/ArrayList/" style="font-size: 15px;">ArrayList</a> <a href="/tags/log/" style="font-size: 15px;">log</a> <a href="/tags/index/" style="font-size: 15px;">index</a> <a href="/tags/concepts/" style="font-size: 15px;">concepts</a> <a href="/tags/Timer/" style="font-size: 15px;">Timer</a> <a href="/tags/TimerTask/" style="font-size: 15px;">TimerTask</a> <a href="/tags/ConcurrentMap/" style="font-size: 15px;">ConcurrentMap</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 15px;">ConcurrentHashMap</a> <a href="/tags/HashMap/" style="font-size: 15px;">HashMap</a> <a href="/tags/ReentrantReadWriteLock/" style="font-size: 15px;">ReentrantReadWriteLock</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/SynchronousQueue/" style="font-size: 15px;">SynchronousQueue</a> <a href="/tags/ScheduledExecutorService/" style="font-size: 15px;">ScheduledExecutorService</a> <a href="/tags/AQS/" style="font-size: 15px;">AQS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/BigData-docker/">Windows 上安装 docker</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/mysql-0.路线/">Mysql学习路线</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/mysql-索引/">Mysql安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/Qunar基础框架-QSchedule/">Qunar基础框架-QSchedule</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/java集合构架中使用到的数据结构和算法/">java集合构架中使用到的数据结构和算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/20/reids-调试环境搭建/">redis-调试环境搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/31/OpenStack-安装/">OpenStack-安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/26/JVM-hotspot-GC机制/">JVM-hotspot-GC机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/11/netty-socketio + socket.io 实现消息推送/">netty-socketio + socket.io 实现消息推送</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/26/mongodb-安装/">mongodb-安装</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/a-ray-of-sunshine" title="github" target="_blank">github</a><ul></ul><a href="http://www.cnblogs.com/a-ray-of-sunshine" title="cnblog" target="_blank">cnblog</a><ul></ul><a href="http://blog.csdn.net/a_ray_of_sunshine" title="csdn" target="_blank">csdn</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Shawshank.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>