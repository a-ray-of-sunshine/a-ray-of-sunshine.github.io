<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>IO-FilterInputStream | Shawshank</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">IO-FilterInputStream</h1><a id="logo" href="/.">Shawshank</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">IO-FilterInputStream</h1><div class="post-meta">Sep 12, 2016</div><div class="post-content"><blockquote>
<p>A FilterInputStream contains some other input stream, which it uses as its basic source of data, possibly transforming the data along the way or providing additional functionality. </p>
<p>Subclasses of FilterInputStream may further override some of these methods and may also provide additional methods and fields.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">FilterInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.in = in;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类将使用 in 作为底层的流，并实现 InputStream 的方法，实现的过程中，就可以在 底层 in 这个流调用前后添加装饰功能。</p>
<p>实际上，FilterInputStream 就是使用了装饰模式的典型。</p>
<h2 id="PushbackInputStream"><a href="#PushbackInputStream" class="headerlink" title="PushbackInputStream"></a>PushbackInputStream</h2><p>PushbackInputStream 内部持有一个 push back buffer, 调用 unread 方法，将字节 push back 到这个 buffer中，此后，<strong>read 操作 和 skip 操作，都优先 read 和 skip 这个 buffer 的数据</strong>，如果，buffer 中的数据个数，满足了 read 和 skip 操作，则返回。否则，调用底层的流的 read 和 skip 将剩余的还需要 read 和 skip 的数据进行 read 和 skip.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// buf 的 length 由 PushbackInputStream 的构造函数</span><br><span class="line">// size 参数决定。</span><br><span class="line">public PushbackInputStream(InputStream in, int size) &#123;</span><br><span class="line">    super(in);</span><br><span class="line">    if (size &lt;= 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;size &lt;= 0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.buf = new byte[size];</span><br><span class="line">    this.pos = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> buf</span><br><span class="line">  ↓</span><br><span class="line">+----+----+----+----+----+----+----+----+----+----+----+----+</span><br><span class="line">|    |    |    |    |    |    |    |    |    |    |    |    |</span><br><span class="line">+----+----+----+----+----+----+----+----+----+----+----+----+</span><br><span class="line">                                                          ↑</span><br><span class="line">                                                         pos</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                           push back bytes</span><br><span class="line"> buf                                             ↓</span><br><span class="line">  ↓                                     ↓___________________↓ </span><br><span class="line">+----+----+----+----+----+----+----+----+----+----+----+----+</span><br><span class="line">|    |    |    |    |    |    |    |    |    |    |    |    |</span><br><span class="line">+----+----+----+----+----+----+----+----+----+----+----+----+</span><br><span class="line">                                      ↑  </span><br><span class="line">                                     pos</span><br><span class="line"></span><br><span class="line">push back bytes: 表示从 unread 方法 push back 过来的字节数据。</span><br><span class="line">在 buf 中：</span><br><span class="line">0 - pos 表示 buffer 目前的存储容量，是空闲位置</span><br><span class="line">pos - buf.length 的字节是 push back bytes.</span><br></pre></td></tr></table></figure>
<p>这个类的核心在三个 push back 方法，unread.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unread</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ensureOpen();</span><br><span class="line">	<span class="comment">// 初始状态下 pos 是 buf 的 长度，代表 buffer 目前的容量</span></span><br><span class="line">	<span class="comment">// 随着 unread, pos 向右移动，直到 pos = 0</span></span><br><span class="line">	<span class="comment">// 表示 buf 中已经写满的数据，所以</span></span><br><span class="line">	<span class="comment">// push back buffer is full.</span></span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Push back buffer is full"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 写入数据</span></span><br><span class="line">    buf[--pos] = (<span class="keyword">byte</span>)b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unread</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ensureOpen();</span><br><span class="line">	<span class="comment">// pos 表示 push back buffer 当前的容量，</span></span><br><span class="line">	<span class="comment">// len &gt; pos 表示待写入的数据的长度，已经超过，buffer 可以接受的容量</span></span><br><span class="line">	<span class="comment">// 所以，直接抛出异常，但是这个异常描述，准确：Push back buffer is full</span></span><br><span class="line">	<span class="comment">// 可能此时 pos = 3, 而 len = 5, 所以对于当前这个 unread 调用来说</span></span><br><span class="line">	<span class="comment">// 是没法写入数据的，因为空间不够，但不是 buffer is full</span></span><br><span class="line">	<span class="comment">// 事实上，buffer 还可以容纳 3 个字节。所以这个异常描述并不准确</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt; pos) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Push back buffer is full"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 写入数据</span></span><br><span class="line">    pos -= len;</span><br><span class="line">    System.arraycopy(b, off, buf, pos, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unread</span><span class="params">(<span class="keyword">byte</span>[] b)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    unread(b, <span class="number">0</span>, b.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于这个 push back buffer 的存在，对于这个类的 read 方法的实现来说，优先读取 push back buffer 中的数据，如果 push back 中没有数据，或者数据不够，则才从，底层的流 in 中读取数据。</p>
<h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ensureOpen();</span><br><span class="line">	<span class="comment">// pos &lt; buf.length 说明  push back buffer 中有数据</span></span><br><span class="line">	<span class="comment">// 则优先从，buffer 中读取数据</span></span><br><span class="line">    <span class="keyword">if</span> (pos &lt; buf.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> buf[pos++] &amp; <span class="number">0xff</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// push back buffer 中没有数据，从底层的流中读取</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ensureOpen();</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (off &lt; <span class="number">0</span> || len &lt; <span class="number">0</span> || len &gt; b.length - off) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 表示当前 push back buffer 中存储的字节的个数。</span></span><br><span class="line">    <span class="keyword">int</span> avail = buf.length - pos;</span><br><span class="line">    <span class="keyword">if</span> (avail &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// len &lt; avail 表示 buffer 中数据就满足此次的读取，</span></span><br><span class="line">		<span class="comment">// 如果 len &gt;= avail 表示 buffer 中的数据还不够此次读取，</span></span><br><span class="line">		<span class="comment">// 所以先将 avail, 也就是 buffer 中所有数据，全部读完。</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt; avail) &#123;</span><br><span class="line">			<span class="comment">// 调整 avail</span></span><br><span class="line">            avail = len;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 将 avail 个数据从，buf 读到 b 中</span></span><br><span class="line">        System.arraycopy(buf, pos, b, off, avail);</span><br><span class="line">		<span class="comment">// buffer 中的 avail 个字节，已经读完，</span></span><br><span class="line">		<span class="comment">// 所以调整，pos</span></span><br><span class="line">        pos += avail;</span><br><span class="line">		<span class="comment">// b 中已经有  avail 个字节，所以调整</span></span><br><span class="line">        off += avail;</span><br><span class="line">		<span class="comment">// 已经向 b 中写入了 avail 个字节，所以</span></span><br><span class="line">		<span class="comment">// 还需要向 b 写入 len = len - avail 个字节。</span></span><br><span class="line">        len -= avail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// len 表示，还需要向 b 中写入的字节的个数</span></span><br><span class="line">	<span class="comment">// len &gt; 0, 说明，上面从 buffer 中读取的数据并没有满足</span></span><br><span class="line">	<span class="comment">// b 需要的字节个数，所以，还需要从底层的 in 流中向 b 写入数据</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// 此时 len 表示 read 调用，返回的实际数据个数</span></span><br><span class="line">        len = <span class="keyword">super</span>.read(b, off, len);</span><br><span class="line">        <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">// len == -1 表示，没有底层流中获取到数据</span></span><br><span class="line">			<span class="comment">// 同时 avail 表示，从 buffer 中获取到的数据的个数</span></span><br><span class="line">			<span class="comment">// len == -1 &amp;&amp; avail == 0 自然，表示</span></span><br><span class="line">			<span class="comment">// 没有获取到任何数据，所以按照 read 的语义约定</span></span><br><span class="line">			<span class="comment">// 返回 -1, </span></span><br><span class="line">			<span class="comment">// 若 avail != 0,则说明从 buffer 中获取到数据的，所以直接返回</span></span><br><span class="line">			<span class="comment">// 返回 avail, 表示此次读取操作，实际取到的数据个数</span></span><br><span class="line">            <span class="keyword">return</span> avail == <span class="number">0</span> ? -<span class="number">1</span> : avail;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// len != -1, 说明从底层的流中读到了数据</span></span><br><span class="line">		<span class="comment">// 所以总的数据个数是 avail + len</span></span><br><span class="line">        <span class="keyword">return</span> avail + len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自然 len &lt;= 0, 说明 buffer 中读取的 avail 个数据，已经满足此次</span></span><br><span class="line">	<span class="comment">// read 的需求，所以返回 avail, 表示此次读取的个数。</span></span><br><span class="line">    <span class="keyword">return</span> avail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h3><p>同 read 一样，skip 操作也是优先，skip 当前 buffer 中的字节，如果 当前 push back buffer 中数据，足够，skip, 则 返回。否则，调用，剩余的需要的skip的字节个数，调用底层流的 skip 方法。</p>
<h3 id="mark-amp-reset"><a href="#mark-amp-reset" class="headerlink" title="mark &amp; reset"></a>mark &amp; reset</h3><p>不支持： <code>throw new IOException(&quot;mark/reset not supported&quot;);</code></p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h2 id="BufferedInputStream"><a href="#BufferedInputStream" class="headerlink" title="BufferedInputStream"></a>BufferedInputStream</h2><p>默认分配，8192（8KB）个字节的缓冲区，读取数据就从缓冲区中读取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">         markpos               pos</span><br><span class="line">            ↓                   ↓</span><br><span class="line">+----+----+----+----+----+----+----+----+----+----+----+----+</span><br><span class="line">|    |    |    |    |    |    |    |    |    |    | NA | NA |</span><br><span class="line">+----+----+----+----+----+----+----+----+----+----+----+----+</span><br><span class="line">          ↑___________________↑___________________↑</span><br><span class="line">               reset zone         validte zone</span><br><span class="line">          ↑_______________________________________↑</span><br><span class="line">                              ↑</span><br><span class="line">                            count</span><br><span class="line"></span><br><span class="line">buf: 存储缓存的字节</span><br><span class="line">markpos: 指向最近一次调用mark方法时，pos所指向位置</span><br><span class="line">		 按照 mark &amp; reset 接口约定，从 markpos 至 pos 位置的字节是可以通过</span><br><span class="line">         reset 方法进行重置，然后可以重新读取的。</span><br><span class="line">pos: 指向下次调用 read 方法时，将要读取的第一个字节。</span><br><span class="line"></span><br><span class="line">reset zone 区域的数据已经被读取过了，但是如果调用reset 方法，pos 将被重置成 markpos, 所以这部分区域的数据可以被重新读取。</span><br><span class="line"></span><br><span class="line">validte zone 区域的数据表示，buffer 中还未被读取的有效的字节。</span><br><span class="line"></span><br><span class="line">count 表示：当前 buf 中可以被reset的字节，以及在buff中还未被读取的有效的字节的个数的和</span><br><span class="line"></span><br><span class="line">所以 count - pos : 表示当前 buf 可以被直接读取的有效字节数据，（markpos 至 pos的字节只有当前调用 reset 方法之后，才可以被读取）</span><br></pre></td></tr></table></figure>
<p>fill 向缓冲区中读取字节，当 pos &gt;= count 时，也就是缓冲区中没有可用的数据时，就会调用 fill 方法，各缓冲区中补充数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = getBufIfOpen();</span><br><span class="line">    <span class="keyword">if</span> (markpos &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="comment">// markpos &lt; 0 表示 markpos 此时是无效的</span></span><br><span class="line">		<span class="comment">// 也就是说，缓冲区中没有 can reset bytes</span></span><br><span class="line">		<span class="comment">// 所以此时 buf 中所有的数据都是无效的或者已经被读取过的</span></span><br><span class="line">		<span class="comment">// 所以，直接将 pos 置为0，</span></span><br><span class="line">		<span class="comment">// 然后在下面通过 read(buffer, pos, buffer.length - pos);</span></span><br><span class="line">		<span class="comment">// 相当于 read(buffer, 0, buffer.length);</span></span><br><span class="line">		<span class="comment">// 表示把 buffer 缓冲区读满数据。</span></span><br><span class="line">        pos = <span class="number">0</span>;            <span class="comment">/* no mark: throw away the buffer */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pos &gt;= buffer.length)  <span class="comment">/* no room left in buffer */</span></span><br><span class="line">		<span class="comment">// 代码执行到这里则： markpos &gt;= 0 &amp;&amp; pos &gt;= buffer.length</span></span><br><span class="line">		<span class="comment">// markpos &gt;= 0 表示 mark方法 已经被调用过了。所以在下面的处理过程中</span></span><br><span class="line">		<span class="comment">// 就必须考虑 markpos 至 pos 这段，可能会被 reset 的字节区。这段</span></span><br><span class="line">		<span class="comment">// 字节区必须被保存下来。</span></span><br><span class="line">        <span class="keyword">if</span> (markpos &gt; <span class="number">0</span>) &#123;  <span class="comment">/* can throw away early part of the buffer */</span></span><br><span class="line">            <span class="comment">// markpos &gt; 0 &amp;&amp; pos &gt;= buffer.length</span></span><br><span class="line">			<span class="comment">// sz 是 markpos 至 pos 处的字节个数，</span></span><br><span class="line">			<span class="keyword">int</span> sz = pos - markpos;</span><br><span class="line">			<span class="comment">// 保留 reset zone</span></span><br><span class="line">            System.arraycopy(buffer, markpos, buffer, <span class="number">0</span>, sz);</span><br><span class="line">			<span class="comment">// reset zone 已经被移到 buffer 的开头</span></span><br><span class="line">			<span class="comment">// 所以将 markpos 置为0， pos 置为 sz.</span></span><br><span class="line">            pos = sz;</span><br><span class="line">            markpos = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buffer.length &gt;= marklimit) &#123;</span><br><span class="line">            <span class="comment">// markpos == 0 &amp;&amp; pos &gt;= buffer.length &amp;&amp; buffer.length &gt;= marklimit</span></span><br><span class="line">			<span class="comment">// 注意上面的条件：pos &gt;= buffer.length &amp;&amp; buffer.length &gt;= marklimit</span></span><br><span class="line">			<span class="comment">// &lt;==&gt; pos &gt;= marklimit 表示，pos 的位置，已经超过预定的</span></span><br><span class="line">			<span class="comment">// marklimit的限制了，所以当前的 markpos 无效的，所以</span></span><br><span class="line">			<span class="comment">// 直接重置 markpos 和 pos</span></span><br><span class="line">            markpos = -<span class="number">1</span>;   <span class="comment">/* buffer got too big, invalidate mark */</span></span><br><span class="line">            pos = <span class="number">0</span>;        <span class="comment">/* drop buffer contents */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;            <span class="comment">/* grow buffer */</span></span><br><span class="line">			<span class="comment">// markpos == 0 &amp;&amp; pos &gt;= buffer.length &amp;&amp; buffer.length &lt; marklimit</span></span><br><span class="line">			<span class="comment">// 上面的三个条件是代码执行到这里的必要条件。</span></span><br><span class="line">			<span class="comment">// 其含义是，当前 buffer 中所有的数据已经被 read过了，but </span></span><br><span class="line">			<span class="comment">// 由于 markpos == 0 &amp;&amp; buffer.length &lt; marklimit,所以整个buffer 的 bytes 全部是允许 reset 的，所以整个buffer 就需要被保留</span></span><br><span class="line">			<span class="comment">// 这也意味着 此时的 buffer 将没有空间，存放 validate zone的数据了</span></span><br><span class="line">			<span class="comment">// 所以必须扩容。</span></span><br><span class="line">			<span class="comment">// 为 buffer 扩容</span></span><br><span class="line">			<span class="comment">// 计算新 buffer 的 size.</span></span><br><span class="line">            <span class="keyword">int</span> nsz = pos * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nsz &gt; marklimit)</span><br><span class="line">                nsz = marklimit;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 将整个 buffer 中的字节拷贝到新的 buffer 中。</span></span><br><span class="line">            <span class="keyword">byte</span> nbuf[] = <span class="keyword">new</span> <span class="keyword">byte</span>[nsz];</span><br><span class="line">            System.arraycopy(buffer, <span class="number">0</span>, nbuf, <span class="number">0</span>, pos);</span><br><span class="line">			<span class="comment">// 更新 buf 字段</span></span><br><span class="line">            <span class="keyword">if</span> (!bufUpdater.compareAndSet(<span class="keyword">this</span>, buffer, nbuf)) &#123;</span><br><span class="line">                <span class="comment">// Can't replace buf if there was an async close.</span></span><br><span class="line">                <span class="comment">// Note: This would need to be changed if fill()</span></span><br><span class="line">                <span class="comment">// is ever made accessible to multiple threads.</span></span><br><span class="line">                <span class="comment">// But for now, the only way CAS can fail is via close.</span></span><br><span class="line">                <span class="comment">// assert buf == null;</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Stream closed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            buffer = nbuf;</span><br><span class="line">			<span class="comment">// 新的buffer ，相当于原来buffer的后面增加的新的空间</span></span><br><span class="line">			<span class="comment">// 所以 markpos 和 pos 都没有变化，所以不需要进行调整。</span></span><br><span class="line">        &#125;</span><br><span class="line">	<span class="comment">// 将 reset zone 的字节个数 赋给 count</span></span><br><span class="line">    count = pos;</span><br><span class="line">	<span class="comment">// 向 buffer fill 数据</span></span><br><span class="line">    <span class="keyword">int</span> n = getInIfOpen().read(buffer, pos, buffer.length - pos);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">		<span class="comment">// count = validate zone + reset zone </span></span><br><span class="line">		<span class="comment">// n 是 validate zone 的数据</span></span><br><span class="line">		<span class="comment">// pos 是 reset zone 的数据。</span></span><br><span class="line">        count = n + pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    getBufIfOpen(); <span class="comment">// Check for closed stream</span></span><br><span class="line">    <span class="keyword">if</span> ((off | len | (off + len) | (b.length - (off + len))) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// n 表示目前已经向 b 中读取到的字节的个数。</span></span><br><span class="line">	<span class="comment">// 下面通过循环不断向 b 中读取数据</span></span><br><span class="line">	<span class="comment">// 所以初始情况下 n = 0, 表示已经向 b 中读取了 0 个字节。</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">// 已经向 b 中读取了 n 个字节</span></span><br><span class="line">		<span class="comment">// 所以将 b 的下次读取的 offset: 设置成 off + n</span></span><br><span class="line">		<span class="comment">// 读取的 length： 设置成 len - n</span></span><br><span class="line">		<span class="comment">// nread 表示 read1 实际读取的字节个数</span></span><br><span class="line">        <span class="keyword">int</span> nread = read1(b, off + n, len - n);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// nread &lt;= 0 表明，此次 read1 调用</span></span><br><span class="line">		<span class="comment">// 没有读取到数据。 n==0, 表明是循环中的第一次</span></span><br><span class="line">		<span class="comment">// 所以返回 nread 表示读取的字节个数，</span></span><br><span class="line">		<span class="comment">// 如果 n != 0, 则说明已经循环多次了，</span></span><br><span class="line">		<span class="comment">// n 就是 当前 b 中的字节个数。所以直接返回 n</span></span><br><span class="line">        <span class="keyword">if</span> (nread &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (n == <span class="number">0</span>) ? nread : n;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 此时 nread &gt; 0 , 表明 read1 向 b 中读取到了</span></span><br><span class="line">		<span class="comment">// 有效的数据，所以将 读取到的字节个数添加到 n </span></span><br><span class="line">        n += nread;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// n &gt;= len 表明 已经向 b 中读取了至少 len 个字节了 所以应该返回了。</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt;= len)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 此时应该是 n &lt; len, 就是向 b 中还未读取到 len</span></span><br><span class="line">		<span class="comment">// 个字节，应该进行循环读取，</span></span><br><span class="line">		<span class="comment">// 但是在循环读取前先判断一下，底层的流中是否</span></span><br><span class="line">		<span class="comment">// 还有数据可供读取，如果没有自然，就没有必要继续</span></span><br><span class="line">		<span class="comment">// 循环读取了，所以直接返回.</span></span><br><span class="line">        <span class="comment">// if not closed but no bytes available, return</span></span><br><span class="line">        InputStream input = in;</span><br><span class="line">        <span class="keyword">if</span> (input != <span class="keyword">null</span> &amp;&amp; input.available() &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read1 实现的原则是，至多直接向底层流直接读取数据一次，</span></span><br><span class="line"><span class="comment">// 否则，总是，先从 buf 中读取，如果 buf 读完，则调用 fill</span></span><br><span class="line"><span class="comment">// 将 buf 填充，然后再从 buf 中读取。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">read1</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> avail = count - pos;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// buf 中没有可以直接读取的数据。</span></span><br><span class="line">    <span class="keyword">if</span> (avail &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* If the requested length is at least as large as the buffer, and</span></span><br><span class="line"><span class="comment">           if there is no mark/reset activity, do not bother to copy the</span></span><br><span class="line"><span class="comment">           bytes into the local buffer.  In this way buffered streams will</span></span><br><span class="line"><span class="comment">           cascade harmlessly. */</span></span><br><span class="line">        <span class="keyword">if</span> (len &gt;= getBufIfOpen().length &amp;&amp; markpos &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// len &gt;= getBufIfOpen().length 的情况下，如果直接调用</span></span><br><span class="line">			<span class="comment">// fill 进行数据填充，很可能造成 buf 的扩容操作。</span></span><br><span class="line">			<span class="comment">// 所以在 mark 无效的情况的下，可能直接从底层的 in 流中读取数据</span></span><br><span class="line">			<span class="comment">// 而不是 调用 fill， 这样就避免了 fill 中的对 buf 的扩容</span></span><br><span class="line">			<span class="comment">// 从而避免的空间浪费。还有一个作用就是，如果 mark 无效，</span></span><br><span class="line">			<span class="comment">// 则没有必要维护当前的buff了（因为 len &gt; buf.length）</span></span><br><span class="line">			<span class="comment">// 所以直接将数据读取到 b 中，而不是读取到 buf 中，再从 buf 读取到 b 中</span></span><br><span class="line">			<span class="comment">// 减少数组之间的拷贝，从而提升的读取的效率。</span></span><br><span class="line">			<span class="comment">// 当然如果 mark 是有效的（markpos &gt;= 0）</span></span><br><span class="line">			<span class="comment">// 为了维护 markpos，也就是保留 reset zone 的字节区的数据，</span></span><br><span class="line">			<span class="comment">// 则必须得调用 fill, 此时扩容也是有必要的。</span></span><br><span class="line">            <span class="keyword">return</span> getInIfOpen().read(b, off, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 填充 buf.</span></span><br><span class="line">        fill();</span><br><span class="line">        avail = count - pos;</span><br><span class="line">        <span class="keyword">if</span> (avail &lt;= <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从 buf 中读取 cnt 个字节。</span></span><br><span class="line">    <span class="keyword">int</span> cnt = (avail &lt; len) ? avail : len;</span><br><span class="line">    System.arraycopy(getBufIfOpen(), pos, b, off, cnt);</span><br><span class="line">    pos += cnt;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="mark-amp-reset-1"><a href="#mark-amp-reset-1" class="headerlink" title="mark &amp; reset"></a>mark &amp; reset</h3><p>支持 mark &amp; reset</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readlimit)</span> </span>&#123;</span><br><span class="line">    marklimit = readlimit;</span><br><span class="line">    markpos = pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    getBufIfOpen(); <span class="comment">// Cause exception if closed</span></span><br><span class="line">	<span class="comment">// 值得注意的是，在这里并没有直接使用这样的判断条件</span></span><br><span class="line">	<span class="comment">// int haveread = pos - markpos;</span></span><br><span class="line">	<span class="comment">// if (haveread &gt; readlimit)&#123;</span></span><br><span class="line">	<span class="comment">//		throw new IOException("Resetting to invalid mark");</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="comment">// 按照 mark &amp; reset 的语义来说，应该是上面的判断，而</span></span><br><span class="line">	<span class="comment">// BufferedInputStream 却使用下面的方法来判断，mark 是否无效</span></span><br><span class="line">	<span class="comment">// markpos 被重置成 -1 是在 fill 方法中，由此可见，</span></span><br><span class="line">	<span class="comment">// markpos 是否无效有判定，不仅仅由 readlimt 来决定，还</span></span><br><span class="line">	<span class="comment">// 会受到 缓冲区 大小的影响，因为缓冲区大小会决定，fill 方法</span></span><br><span class="line">	<span class="comment">// 何时被调用。</span></span><br><span class="line">    <span class="keyword">if</span> (markpos &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Resetting to invalid mark"</span>);</span><br><span class="line">    pos = markpos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">markSupported</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面的分析，可知 对于 BufferedInputStream 实现的 mark &amp; reset, 其 reset 提供的参数 readlimt 有可能并不会立即生效。也就是说例如： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mark(<span class="number">2</span>);</span><br><span class="line">read();</span><br><span class="line">read();</span><br><span class="line">read();</span><br><span class="line"><span class="comment">// 此时 已经读取了 3 个字节了，而 readlimit 是2</span></span><br><span class="line"><span class="comment">// 那么下面的 reset 会不会抛出异常，就由 当前 buf 的大小决定了</span></span><br><span class="line"><span class="comment">// 如果 buf 足够大， 不会导致 fill 方法被调用，则 markpos 就不会被置为 -1</span></span><br><span class="line"><span class="comment">// 则 reset 方法就 markpos &lt; 0 的判断就失效了，所以不会抛出 IOException</span></span><br><span class="line"><span class="comment">// 同样，如果 上面的第三个 read 方法引发了 fill 方法调用，则 reset 就会抛出异常</span></span><br><span class="line">reset();</span><br></pre></td></tr></table></figure>
<p>摘自：java.io.InputStream.reset 方法文档</p>
<blockquote>
<ul>
<li><p>If the method markSupported returns true, then: </p>
<ul>
<li><p>If the method mark has not been called since the stream was created, or the number of bytes read from the stream since mark was last called is larger than the argument to mark at that last call, then an IOException might be thrown. </p>
</li>
<li><p>If such an IOException is not thrown, then the stream is reset to a state such that all the bytes read since the most recent call to mark (or since the start of the file, if mark has not been called) will be resupplied to subsequent callers of the read method, followed by any bytes that otherwise would have been the next input data as of the time of the call to reset. </p>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>其中就提到，markSupported returns true 并且 mark 方法也被调用了：then an IOException might be thrown，<br>可能会抛出 IOException ，所以说对于 mark &amp; reset 接口来说，并不是说 mark 的参数 readlimit 就一定决定 reset 方法在读取超过 readlimit 个字节被调用时会一定抛出异常。</p>
<h2 id="DataInputStream"><a href="#DataInputStream" class="headerlink" title="DataInputStream"></a>DataInputStream</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> <span class="keyword">implements</span> <span class="title">DataInput</span></span></span><br></pre></td></tr></table></figure>
<p>这个类实现的 DataInput 接口。这个类的实现和 DataOutputStream 密切相关。通常是由 DataOutputStream 写入数据，然后由 DataInputStream 读取数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataOutputStream</span> <span class="keyword">extends</span> <span class="title">FilterOutputStream</span> <span class="keyword">implements</span> <span class="title">DataOutput</span></span></span><br></pre></td></tr></table></figure>
<p>这两个类的实现都比较简单，需要注意的是 DataOutput 接口的几个write 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">writeByte(<span class="keyword">int</span> v)</span><br><span class="line">writeChar(<span class="keyword">int</span> v)</span><br><span class="line">writeShort(<span class="keyword">int</span> v)</span><br></pre></td></tr></table></figure>
<p>这三个方法功能正如其名，但是其所接受的参数，都是 int 类型。DataOutputStream 类在实现的时候，会其对应的低字节，也就是对int参数进行截断。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataOutputStream 的 writeShort 方法。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeShort</span><span class="params">(<span class="keyword">int</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    out.write((v &gt;&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    out.write((v &gt;&gt;&gt; <span class="number">0</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    incCount(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关于-String-的-write-和-read"><a href="#关于-String-的-write-和-read" class="headerlink" title="关于 String 的 write 和 read"></a>关于 String 的 write 和 read</h3><p>DataInput 和 DataOuput 接口提供了两种读写 String 的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataOutputStream.writeChars</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeChars</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = s.charAt(i);</span><br><span class="line">        out.write((v &gt;&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">        out.write((v &gt;&gt;&gt; <span class="number">0</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    incCount(len * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DataInput.readLine</span></span><br><span class="line"><span class="function">String <span class="title">readLine</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DataOutputStream.writeUTF</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeUTF</span><span class="params">(String str)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    writeUTF(str, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DataInputStream.readUTF</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">readUTF</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readUTF(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由 DataOutputStream 的 writeChars 的实现方法，可知，其并没有对于一个String的结束做任何标记，所以如果通过 writeChars 方法写入 String 则由于无法判断这一系列chars的字节的结束位置，所以在 DataInput 在也就不存在，readChars 方法。</p>
<p>但是 DataInput 提供了一个 readLine 方法。but</p>
<blockquote>
<p>Reads the next line of text from the input stream. It reads successive bytes, <strong>converting each byte separately into a character</strong>, until it encounters a line terminator or end of file; the characters read are then returned as a String. Note that because this method processes bytes, it does not support input of the full Unicode character set. </p>
</blockquote>
<p>注意这个方法是将每一个字节转换成一个字符。所以即使使用 DataOutput 的 writeChar 方法写入字节，这个 readLine 方法也不能正常读取出字符数据来。因为对 writeChar 方法来说一个 char(字符) 使用两个字节表示，所以当使用 readLine 方法时会把 char 分解成两个字符，所以这个方法其实，并不能使用。在 DataInputStream 类实现的 readLine 方法已经将其标记为 @Deprecated 的。</p>
<p>writeUTF 方法将 char 使用类 UTF-8 格式存储。同时在存储chars的时候，将 UTF-8 所占的字节流个数也存储了下来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataOutputStream.writeUTF</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">writeUTF</span><span class="params">(String str, DataOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> strlen = str.length();</span><br><span class="line">    <span class="keyword">int</span> utflen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> c, count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* use charAt instead of copying String to char array */</span></span><br><span class="line">	<span class="comment">// 1. 计算String转换成 utf-8 字节之后的字节个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strlen; i++) &#123;</span><br><span class="line">        c = str.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> ((c &gt;= <span class="number">0x0001</span>) &amp;&amp; (c &lt;= <span class="number">0x007F</span>)) &#123;</span><br><span class="line">            utflen++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt; <span class="number">0x07FF</span>) &#123;</span><br><span class="line">            utflen += <span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            utflen += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果存储的数据转换成utf-8字节流之后个数大于 65535</span></span><br><span class="line">	<span class="comment">// 则抛出 UTFDataFormatException。</span></span><br><span class="line">	<span class="comment">// 例如，如果String是一个包含：22000 多个汉字，那么，</span></span><br><span class="line">	<span class="comment">// 每个汉字3个字节，自然超出了 65535 会抛出异常。</span></span><br><span class="line">	<span class="comment">// 至于，为什么是 65535， 原因在下面。</span></span><br><span class="line">    <span class="keyword">if</span> (utflen &gt; <span class="number">65535</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UTFDataFormatException(</span><br><span class="line">            <span class="string">"encoded string too long: "</span> + utflen + <span class="string">" bytes"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 分配存储空间。</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytearr = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (out <span class="keyword">instanceof</span> DataOutputStream) &#123;</span><br><span class="line">        DataOutputStream dos = (DataOutputStream)out;</span><br><span class="line">        <span class="keyword">if</span>(dos.bytearr == <span class="keyword">null</span> || (dos.bytearr.length &lt; (utflen+<span class="number">2</span>)))</span><br><span class="line">            dos.bytearr = <span class="keyword">new</span> <span class="keyword">byte</span>[(utflen*<span class="number">2</span>) + <span class="number">2</span>];</span><br><span class="line">        bytearr = dos.bytearr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bytearr = <span class="keyword">new</span> <span class="keyword">byte</span>[utflen+<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 向缓冲区中写入这个 utf-8 流的 长度 utflen</span></span><br><span class="line">	<span class="comment">// 注意这里使用了两个字节来存储长度，所以 utf-8 流的</span></span><br><span class="line">	<span class="comment">// 长度： utflen 必须 &lt;= 65535. 两个字节所能表示的最大的</span></span><br><span class="line">	<span class="comment">// 无符号数。</span></span><br><span class="line">    bytearr[count++] = (<span class="keyword">byte</span>) ((utflen &gt;&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    bytearr[count++] = (<span class="keyword">byte</span>) ((utflen &gt;&gt;&gt; <span class="number">0</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4. 转换 char 到 utf-8 字节流。</span></span><br><span class="line">	<span class="comment">// 下面的代码很有意思，如果在 char 在 (c &gt;= 0x0001) &amp;&amp; (c &lt;= 0x007F)</span></span><br><span class="line">	<span class="comment">// 范围内，则向 bytearr 内写入数据。直到遇见一个不在上面范围的字符,结束</span></span><br><span class="line">	<span class="comment">// 循环。如果String全是 英文，则下面的循环就可以完全将String转换成 utf-8</span></span><br><span class="line">	<span class="comment">// 字节。</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;strlen; i++) &#123;</span><br><span class="line">       c = str.charAt(i);</span><br><span class="line">       <span class="keyword">if</span> (!((c &gt;= <span class="number">0x0001</span>) &amp;&amp; (c &lt;= <span class="number">0x007F</span>))) <span class="keyword">break</span>;</span><br><span class="line">       bytearr[count++] = (<span class="keyword">byte</span>) c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果 i &lt; strlen 表明，此时出现了 (c &gt;= 0x0001) &amp;&amp; (c &lt;= 0x007F) 之外</span></span><br><span class="line">	<span class="comment">// 的字符。所以需要下面的循环进行判断转换。</span></span><br><span class="line">    <span class="keyword">for</span> (;i &lt; strlen; i++)&#123;</span><br><span class="line">        c = str.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> ((c &gt;= <span class="number">0x0001</span>) &amp;&amp; (c &lt;= <span class="number">0x007F</span>)) &#123;</span><br><span class="line">            bytearr[count++] = (<span class="keyword">byte</span>) c;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt; <span class="number">0x07FF</span>) &#123;</span><br><span class="line">            bytearr[count++] = (<span class="keyword">byte</span>) (<span class="number">0xE0</span> | ((c &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0x0F</span>));</span><br><span class="line">            bytearr[count++] = (<span class="keyword">byte</span>) (<span class="number">0x80</span> | ((c &gt;&gt;  <span class="number">6</span>) &amp; <span class="number">0x3F</span>));</span><br><span class="line">            bytearr[count++] = (<span class="keyword">byte</span>) (<span class="number">0x80</span> | ((c &gt;&gt;  <span class="number">0</span>) &amp; <span class="number">0x3F</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            bytearr[count++] = (<span class="keyword">byte</span>) (<span class="number">0xC0</span> | ((c &gt;&gt;  <span class="number">6</span>) &amp; <span class="number">0x1F</span>));</span><br><span class="line">            bytearr[count++] = (<span class="keyword">byte</span>) (<span class="number">0x80</span> | ((c &gt;&gt;  <span class="number">0</span>) &amp; <span class="number">0x3F</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    out.write(bytearr, <span class="number">0</span>, utflen+<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> utflen + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面的存储过程，可以看到，utf-8 bytes 的前两字节就是流的长度。所以在 DataInputStream 的 readUTF 的实现中，就可以正确的知道，这个utf-8 bytes 的个数，就能够正常的解析字符串。所以要想正常写入和读取 String 就使用DataOutputStream.writeUTF 和 DataInputStream.readUTF 方法即可。</p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2016/09/16/java字符集/">java字符集</a><a class="next" href="/2016/09/11/IO-ObjectInputStream/">IO-ObjectInputStream</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/interface/" style="font-size: 15px;">interface</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/Collections/" style="font-size: 15px;">Collections</a> <a href="/tags/Collection/" style="font-size: 15px;">Collection</a> <a href="/tags/J-U-C/" style="font-size: 15px;">J.U.C</a> <a href="/tags/lock/" style="font-size: 15px;">lock</a> <a href="/tags/Semaphore/" style="font-size: 15px;">Semaphore</a> <a href="/tags/CountDownLatch/" style="font-size: 15px;">CountDownLatch</a> <a href="/tags/CyclicBarrier/" style="font-size: 15px;">CyclicBarrier</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/LinkedList/" style="font-size: 15px;">LinkedList</a> <a href="/tags/Queue/" style="font-size: 15px;">Queue</a> <a href="/tags/Set/" style="font-size: 15px;">Set</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/collection/" style="font-size: 15px;">collection</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/api/" style="font-size: 15px;">api</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/mvc/" style="font-size: 15px;">mvc</a> <a href="/tags/context/" style="font-size: 15px;">context</a> <a href="/tags/component-scan/" style="font-size: 15px;">component-scan</a> <a href="/tags/storm/" style="font-size: 15px;">storm</a> <a href="/tags/windows/" style="font-size: 15px;">windows</a> <a href="/tags/命令行/" style="font-size: 15px;">命令行</a> <a href="/tags/cmder/" style="font-size: 15px;">cmder</a> <a href="/tags/win/" style="font-size: 15px;">win</a> <a href="/tags/效率/" style="font-size: 15px;">效率</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/博客/" style="font-size: 15px;">博客</a> <a href="/tags/apache/" style="font-size: 15px;">apache</a> <a href="/tags/extends/" style="font-size: 15px;">extends</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/svn/" style="font-size: 15px;">svn</a> <a href="/tags/BlockingQueue/" style="font-size: 15px;">BlockingQueue</a> <a href="/tags/LinkedBlockingQueue/" style="font-size: 15px;">LinkedBlockingQueue</a> <a href="/tags/PriorityBlockingQueue/" style="font-size: 15px;">PriorityBlockingQueue</a> <a href="/tags/ConcurrentLinkedQueue/" style="font-size: 15px;">ConcurrentLinkedQueue</a> <a href="/tags/CopyOnWriteArrayList/" style="font-size: 15px;">CopyOnWriteArrayList</a> <a href="/tags/接口/" style="font-size: 15px;">接口</a> <a href="/tags/抽象类/" style="font-size: 15px;">抽象类</a> <a href="/tags/Executor/" style="font-size: 15px;">Executor</a> <a href="/tags/ExecutorService/" style="font-size: 15px;">ExecutorService</a> <a href="/tags/CompletionService/" style="font-size: 15px;">CompletionService</a> <a href="/tags/ThreadPoolExecutor/" style="font-size: 15px;">ThreadPoolExecutor</a> <a href="/tags/vim/" style="font-size: 15px;">vim</a> <a href="/tags/vundle/" style="font-size: 15px;">vundle</a> <a href="/tags/ArrayList/" style="font-size: 15px;">ArrayList</a> <a href="/tags/log/" style="font-size: 15px;">log</a> <a href="/tags/index/" style="font-size: 15px;">index</a> <a href="/tags/concepts/" style="font-size: 15px;">concepts</a> <a href="/tags/Timer/" style="font-size: 15px;">Timer</a> <a href="/tags/TimerTask/" style="font-size: 15px;">TimerTask</a> <a href="/tags/ConcurrentMap/" style="font-size: 15px;">ConcurrentMap</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 15px;">ConcurrentHashMap</a> <a href="/tags/HashMap/" style="font-size: 15px;">HashMap</a> <a href="/tags/ReentrantReadWriteLock/" style="font-size: 15px;">ReentrantReadWriteLock</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/SynchronousQueue/" style="font-size: 15px;">SynchronousQueue</a> <a href="/tags/ScheduledExecutorService/" style="font-size: 15px;">ScheduledExecutorService</a> <a href="/tags/AQS/" style="font-size: 15px;">AQS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/BigData-docker/">Windows 上安装 docker</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/mysql-0.路线/">Mysql学习路线</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/mysql-索引/">Mysql安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/Qunar基础框架-QSchedule/">Qunar基础框架-QSchedule</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/java集合构架中使用到的数据结构和算法/">java集合构架中使用到的数据结构和算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/20/reids-调试环境搭建/">redis-调试环境搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/31/OpenStack-安装/">OpenStack-安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/26/JVM-hotspot-GC机制/">JVM-hotspot-GC机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/11/netty-socketio + socket.io 实现消息推送/">netty-socketio + socket.io 实现消息推送</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/26/mongodb-安装/">mongodb-安装</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/a-ray-of-sunshine" title="github" target="_blank">github</a><ul></ul><a href="http://www.cnblogs.com/a-ray-of-sunshine" title="cnblog" target="_blank">cnblog</a><ul></ul><a href="http://blog.csdn.net/a_ray_of_sunshine" title="csdn" target="_blank">csdn</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Shawshank.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>