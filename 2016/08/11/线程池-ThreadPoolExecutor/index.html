<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>线程池-ThreadPoolExecutor | Shawshank</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">线程池-ThreadPoolExecutor</h1><a id="logo" href="/.">Shawshank</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">线程池-ThreadPoolExecutor</h1><div class="post-meta">Aug 11, 2016</div><div class="post-content"><h2 id="文档简介"><a href="#文档简介" class="headerlink" title="文档简介"></a>文档简介</h2><p>ThreadPoolExecutor 是 ExecutorService的一个实现，其功能是：使用几个被池化的线程来执行提交的任务，这些在池中的线程由 ThreadFactory 来创建。</p>
<p>线程池解决了两个问题：</p>
<ul>
<li><p>提高了执行大量异步任务的效率。</p>
<p>  使用缓存的线程来，执行任务，节省的线程创建的时间。</p>
</li>
<li><p>提供了一种限制和管理资源的方法。</p>
</li>
</ul>
<p>此外，ThreadPoolExecutor 还维护了一些基本统计信息，例如已经完成的任务（task）的个数。</p>
<p>为了使这个线程池可以在不同的场景下使用，这个类提供了许多可以配置的参数和一些回调函数。然而，比较推荐的是使用 Executors 类来创建 ThreadPoolExecutor 对象，这个类提供了一些默认的参数，来实现不同功能的线程池。如果 Executors 类提供的线程池，不能够满足需求，可以按照下面的 ThreadPoolExecutor 的参数配置说明，来配置和微调线程池。</p>
<ul>
<li><p>Core and maximum pool size</p>
<p>  ThreadPoolExecutor 将使用参数 corePoolSize 和maximumPoolSize 来自动地调整 pool size (在池中的线程数量)。当使用 execute 方法提交一个新的任务的时候: (1) 如果当前运行的线程数量少于 corePoolSize ，则ThreadPoolExecutor将创建一个新线程来运行这个任务，尽管此时可能有其它线程处于空闲状态（idle）.(2) 如果当前运行的线程数量是介于 corePoolSize 和 maximumPoolSize 之间，当且仅当任务队列是满的时候（也就是这个任务无法入队列），才会创建一个新线程去运行这个任务。(3) 当前运行的线程数量已经是 maximumPoolSize，且队列也是不满，则入队列。(4) 当前运行的线程数量已经是 maximumPoolSize，且队列也是已经满了，则需要reject这个任务。</p>
<p>  当将 corePoolSize 和 maximumPoolSize 设置相同的时候，此时就是一个 fixed-size（固定大小） 的线程池。</p>
<p>  当将 maximumPoolSize 设置成 Integer.MAX_VALUE的时候，表示这个线程池可以接受任意数量的并发的任务。</p>
<p>  通常情况，使用 ThreadPoolExecutor 的构造函数配置这两个参数。当然也可以使用 setCorePoolSize 和 setMaximumPoolSize 方法动态的改变这两个参数。</p>
</li>
<li><p>On-demand construction</p>
<p>  默认情况下池中所有线程都是任务被提交之后按需要创建的。但是，我们可以使用 prestartCoreThread() 和 prestartAllCoreThreads().方法来预先启动 coreThread。因为有一种情况，可能需要这样做。就是，ThreadPoolExecutor在创建的时候需要指定任务的存储队列，如果这个队列中已经有一些任务存在了，就可以使用上面的方法，通过预先启动线程，使得 BlockingQueue 中的任务可以立即被执行，而不是一直等待到有任务被提交时，才有线程可以执行这些任务。</p>
</li>
<li><p>Creating new threads</p>
<p>  使用 ThreadFactory 来创建新的线程。如果没有指定这个参数，则默认使用 Executors.DefaultThreadFactory 这个实现类。这个类将所有的线程放置到同一个线程组中，其线程的命名规则是：pool-1-thread-1,pool-1-thread-2,pool-1-thread-3,etc. 其中第一个数字是线程池实例的编号，第二个数字是当前线程池中线程的编号。同时将线程的优先级设置在 NORM_PRIORITY 和 non-daemon 状态。</p>
<p>  通过，实现 ThreadFactory 接口，可以对线程池中线程的 name, thread group, priority, daemon status 进行设置。</p>
<p>  如果这个实现类的 newThread 方法返回null, 则当前的 executor 将继续执行，但是有可能不会执行任何任务。</p>
</li>
<li><p>Keep-alive times</p>
<p>  如果线程池中当前线程的个数超过了 corePoolSize，并且这些超出的线程处于空闲状态的时间已经超过了 keepAliveTime, 则这些线程将被终止。当池变得不够活跃的时候，通过回收这些线程，节省了线程的资源的占用。</p>
<p>  这个参数也可以通过 setKeepAliveTime 方法来动态改变。</p>
<p>  默认情况下，超时策略仅适用于，超过 corePoolSize 的那些线程。但是如果使用 allowCoreThreadTimeOut(true) 调用，则可以设置，让 core threads 也可以在超时的时候被回收。</p>
</li>
<li><p>Queuing</p>
<p>  executor 使用 BlockingQueue 来存储提交的任务。通常有三种策略：(1) Direct handoffs(直接切换): SynchronousQueue. (2) Unbounded queues(无界队列): LinkedBlockingQueue. (3) Bounded queues(有界队列): ArrayBlockingQueue.</p>
</li>
<li><p>Rejected tasks</p>
<p>  当 executor 被 shutdown 或者 maximum threads 和 queue capacity 都是有界的，而且，都已经满了的时候。executor 的 execute 方法 将 调用 RejectedExecutionHandler.rejectedExecution 方法，来 reject 一个任务。</p>
<p>  预定义的 handler 有：(1) ThreadPoolExecutor.AbortPolicy: 直接抛出 RejectedExecutionException 异常。(2) ThreadPoolExecutor.CallerRunsPolicy: 被 reject 的任务将直接在 调用者 线程中被执行。它提供了一种简单的反馈控制机制，从而减缓了新任务提交的速率。其实就是新提交的任务被当前提交任务的线程执行，使用提交过程被减缓。(3) ThreadPoolExecutor.DiscardPolicy: 将这个不能提交的任务直接丢弃（不执行，不抛异常，do nothing）。(4) ThreadPoolExecutor.DiscardOldestPolicy: 将当前队列中等待最久的线程移除，然后再次提交这个任务。</p>
<p>  It is possible to define and use other kinds of RejectedExecutionHandler classes. Doing so requires some care especially when policies are designed to work only under particular capacity or queuing policies. </p>
</li>
<li><p>Hook methods    </p>
<p>  提供了两个方法 beforeExecute 和 afterExecute 在每一个任务被执行的时候，这两个方法都会被调用。这些方法实现的通常目地可以是：调整任务的执行环境，例如：重新初始化 ThreadLocal, 收集统计信息, 添加任务执行日志等等。</p>
<p>  此外，可以 override terminated方法来执行当 executor 被终止的时候，执行一些特殊的资源清理操作等。</p>
</li>
<li><p>Queue maintenance </p>
<p>  getQueue 允许其它线程出于高度或者监控目地。如果将这个方法使用于其它目地是强烈不推荐的。</p>
<p>  如果需要调用 queue， 则应该使用 executor 提供的 remove 和 purge 方法，而不是直接操作 queue.</p>
</li>
<li><p>Finalization</p>
<p>  A pool that is no longer referenced in a program AND has no remaining threads will be shutdown automatically.</p>
<p>  当池对象不再被任何线程引用并且池中没有剩余的线程，则这个线程将会自动被关闭。</p>
</li>
</ul>
<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><h3 id="ctl-线程池的生命周期控制字段"><a href="#ctl-线程池的生命周期控制字段" class="headerlink" title="ctl: 线程池的生命周期控制字段"></a>ctl: 线程池的生命周期控制字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p>这个变量分为两个部分：</p>
<ul>
<li>workerCount: 后 29 个字节。表示当前线程池中有效的线程数。</li>
<li>runState:        前 3   个字节。表示当前线程池的运行状态。</li>
</ul>
<p>由初始化的参数可知，当线程池初始化之后的，默认状态是：RUNNING 表示当前线程池可以接受新的任务，并且可以处理queue中的任务。同时0表示线程池中当前的线程个数为0.</p>
<p>关于 ctl 的操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="comment">// 从 ctl 中取出 runState。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 从 ctl 中取出 workerCount。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 将 runState 和 wc 打包成 ctl 变量。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="workQueue-任务队列"><a href="#workQueue-任务队列" class="headerlink" title="workQueue: 任务队列"></a>workQueue: 任务队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br></pre></td></tr></table></figure>
<p>这个队列中用来持有（存储）任务和分发任务给 工作者线程（worker threads）。这个队列中使用过程中，并不会以 workQueue.poll 方法返回 null ，而认为队列是空的。而是使用 workQueue.isEmpty 方法来判断当前队列是否为空。</p>
<h3 id="workers-工作者线程"><a href="#workers-工作者线程" class="headerlink" title="workers: 工作者线程"></a>workers: 工作者线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br></pre></td></tr></table></figure>
<p>存储池中的所有线程。Set containing all worker threads in pool.</p>
<h2 id="Worker-内部类"><a href="#Worker-内部类" class="headerlink" title="Worker 内部类"></a>Worker 内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br></pre></td></tr></table></figure>
<p>表示executor中内部线程池中的线程。</p>
<h2 id="提交任务的过程"><a href="#提交任务的过程" class="headerlink" title="提交任务的过程"></a>提交任务的过程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提交任务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 任务为 null, 直接抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 开始尝试提交</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 1. 如果当前线程池中的线程数量 &lt; corePoolSize</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 开始将任务 command 直接进行添加</span></span><br><span class="line">        <span class="comment">// 添加成功，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 添加失败，有可能是存在其它线程也在使用当前的线程池</span></span><br><span class="line">        <span class="comment">// 所以，重新获取 ctl。</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 代码执行到这里，表明此时线程池中线程的数量 &gt;= corePoolSize 了。</span></span><br><span class="line">    <span class="comment">// 也就是当前线程数量已经到了 corePoolSize了，</span></span><br><span class="line">    <span class="comment">// 所以后面的 addWorker 中的第二个参数 都是 false,</span></span><br><span class="line">    <span class="comment">//  表明使用 maximumPoolSize 作为线程池数量的边界值。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 如果当前线程池是 RUNNING 状态(isRunning(c))，</span></span><br><span class="line">    <span class="comment">// 则将当前任务 command 入队列(workQueue.offer(command))</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 需要 recheck 的原因是，当前线程池可能被多个线程并发使用，</span></span><br><span class="line">        <span class="comment">// 所以必须重新获取 ctl.</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 如果当前线程池已经不在运行状态了，</span></span><br><span class="line">        <span class="comment">// 并且将command从队列中移除成功。</span></span><br><span class="line">        <span class="comment">// 则 reject 当前任务</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 4. (1) 线程池已经不处于 RUNNING 状态了， 但是 任务仍处于 队列中</span></span><br><span class="line">        <span class="comment">// 并且，当前线程池中的线程中没有任何线程了，则添加一个新的工作者线程</span></span><br><span class="line">        <span class="comment">// 这个工作者线程会执行会将队列中的任务取出来执行。</span></span><br><span class="line">        <span class="comment">// 因为之前已经将 command 入队列了，所以下面的</span></span><br><span class="line">        <span class="comment">// addWorker 中第一个参数是 null</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 线程不处于运行状态，且这个任务还没有入队列，</span></span><br><span class="line">    <span class="comment">//     将这个任务添加到一个工作者线程中去执行</span></span><br><span class="line">    <span class="comment">//     线程没有入队列，所以将 command 传入</span></span><br><span class="line">    <span class="comment">//     addWorker 参数，用新创建的线程来执行这个任务。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">         <span class="comment">// 6. 上面的添加失败，则 reject 这个任务。</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 检验和调整线程池的状态</span></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测 线程池的运行状态</span></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到这里表明当前线程池可以接受任务</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">// 判断线程池线程的数量是否超过配置的数量，如果超过了，则直接返回 false.</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 代码执行到此处，表明可以增加新的 worker, </span></span><br><span class="line">            <span class="comment">// 所以尝试增加 workerCount 计数，</span></span><br><span class="line">            <span class="comment">// 由于可以并发执行，所以使用 CAS 循环来保证线程安全。</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 在并发循环的过程中，有可能线程池的状态发生变化了，</span></span><br><span class="line">            <span class="comment">// 所以，重新获取 ctl 的值，如果 运行状态 确实发生的变化</span></span><br><span class="line">            <span class="comment">// 就重置整个循环，再次尝试。</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代码执行到这里，表明可以创建新的worker(线程)了，</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        <span class="comment">// 1. 创建新的 work</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 使用 mainLock 来保护 变量 workers, </span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 当线程获得锁的时候，有可能，线程池</span></span><br><span class="line">                <span class="comment">// 状态已经发生变化了，所以重新检测线程池的状态。</span></span><br><span class="line">                <span class="comment">// 线程池处于 RUNNING 状态，</span></span><br><span class="line">                <span class="comment">// 或者虽然线程池已经 SHUTDOWN，但是</span></span><br><span class="line">                <span class="comment">// firstTask == null，也可以启动线程。</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 线程是否已经被启动，如果被启动，</span></span><br><span class="line">                    <span class="comment">// 则直接抛异常</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                        </span><br><span class="line">                    <span class="comment">// 将当前线程添加到 workers</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 使用 largestPoolSize 来跟踪当前线程池，</span></span><br><span class="line">                    <span class="comment">// 所能够达到的最大的线程个数。这个字段，应该是线程池的运行</span></span><br><span class="line">                    <span class="comment">// 状态统计信息。</span></span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                        </span><br><span class="line">                    <span class="comment">// 表明线程添加成功</span></span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 线程添加成功，所以启动这个线程。</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                <span class="comment">// 表明线程启动成功</span></span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果线程启动失败，则调用 addWorkerFailed 方法来调整</span></span><br><span class="line">        <span class="comment">// 线程池的状态：（1）从 workers 移除 w, (2) 减少 workCount 字段的计数</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="runWorker"><a href="#runWorker" class="headerlink" title="runWorker"></a>runWorker</h2><p>上面的 addWorker 如果添加 worker 成功，则启动 worker 线程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker 的 run 方法</span></span><br><span class="line"><span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    runWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 工作者线程的主循环，不断的运行任务，</span></span><br><span class="line">        <span class="comment">// 任务的来源有： </span></span><br><span class="line">        <span class="comment">//       (1) 如果这个线程是第一次运行，则一般会有一个任务和其关联，就是 w.firstTask, </span></span><br><span class="line">        <span class="comment">//       (2) 当 firstTask 运行完毕之后，就从 BlockingQueue 中获取任务</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 获取 task 之后，开始执行 task.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 每一个任务在开始执行前的回调接口</span></span><br><span class="line">                <span class="comment">// 子类可以 override 这个方法，来调整 task 的执行环境，进行统计，日志分析</span></span><br><span class="line">                <span class="comment">// 调试等工作</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 运行任务.</span></span><br><span class="line">                    task.run();</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 如果任务运行过程中出现异常,</span></span><br><span class="line">                    <span class="comment">// 将导致,worker线程运行 throw 异常,而退出.</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 每一个任务在执行结束之后的回调接口</span></span><br><span class="line">                    <span class="comment">// 子类可以 override 这个方法，来调整 task 的执行环境，进行统计，日志分析</span></span><br><span class="line">                    <span class="comment">// 调试等工作,通过第二个参数 thrown == null,来判断任务是否执行成功,或是</span></span><br><span class="line">                    <span class="comment">// 执行过程中抛出异常了.</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 一个任务执行完毕之后 </span></span><br><span class="line">                <span class="comment">// 设置 task 为 null,</span></span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 工作者线程的执行 task 的个数统计.</span></span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果线程没有在执行 task 的过程中抛出异常</span></span><br><span class="line">        <span class="comment">// 也就是说线程是正常从上面的 main loop 退出的,</span></span><br><span class="line">        <span class="comment">// 则 设置 completedAbruptly 为 false.</span></span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// worker 退出了, 调用processWorkerExit调整线程池的状态.</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在线程退出之后会调用 processWorkerExit 方法，这个方法的第二个字段 completedAbruptly， 表示<br>线路退出的原因，如果是正常退出为 false, 如果线程异常退出为 ture, 在 processWorkerExit 方法<br>中将会将 workerCount - 1.</p>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><ul>
<li><p>RUNNING</p>
<p>  可以接受新的任务,同时可以处理队列中的任务.</p>
</li>
<li><p>SHUTDOWN</p>
<p>  不接受新的任务,但是仍然会处理队列中的任务.</p>
</li>
<li><p>STOP</p>
<p>  不接受新的任务,不处理队列中的任务了,将正在处理任务的线程中断.</p>
</li>
<li><p>TIDYING</p>
<p>  所有的任务被 terminated, 并且 workerCount == 0,线程状态就会变成这个状态, terminated 回调函数被调用.    </p>
</li>
<li><p>TERMINATED</p>
<p>  terminated 回调函数被调用完成之后, 线程池就处于这个状态.</p>
</li>
</ul>
<p>生命周期的转换:</p>
<ul>
<li><p>RUNNING -&gt; SHUTDOWN</p>
<p>  调用 shutdown 函数的时候, 同时 finalize 函数内部也调用了该函数.</p>
</li>
<li><p>(RUNNING or SHUTDOWN) -&gt; STOP</p>
<p>  调用 shutdownNow 函数的时候</p>
</li>
<li><p>SHUTDOWN -&gt; TIDYING</p>
<p>  当队列和线程池都为空时.</p>
</li>
<li><p>STOP -&gt; TIDYING</p>
<p>  当线程池为空时.    </p>
</li>
<li><p>TIDYING -&gt; TERMINATED</p>
<p>  When the terminated() hook method has completed</p>
</li>
</ul>
<h3 id="线程池的终止"><a href="#线程池的终止" class="headerlink" title="线程池的终止"></a>线程池的终止</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||    <span class="comment">// 当前线程池处于RUNNING状态</span></span><br><span class="line">            runStateAtLeast(c, TIDYING) ||     <span class="comment">// 当前线程池已经是 TIDYING 或 TERMINATED 状态了 </span></span><br><span class="line">            <span class="comment">// 线程处于 SHUTDOWN, 但是队列中仍然有任务存在</span></span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 执行到这里表示,线程可能处于 STOP 状态,</span></span><br><span class="line">        <span class="comment">// 或者是 SHUTDOWN 状态 且 workQueue 中 没有线程了.</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调整线程池的状态: ctl ==&gt; TIDYING ==&gt; TERMINATED</span></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="getTask"><a href="#getTask" class="headerlink" title="getTask"></a>getTask</h2><p>在 runWorker 的 main leep 中获取任务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数有三个出口， 查看  runWorker 函数中使用 getTask ,</span></span><br><span class="line"><span class="comment">// 当 getTask 这个函数返回 null 时，worker 主线程会退出主循环</span></span><br><span class="line"><span class="comment">// worker 线程就会退出。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 响应线程池的生命周期</span></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">// 下面的判断条件相当于：</span></span><br><span class="line">        <span class="comment">// if( (rs &gt;= SHUTDOWN &amp;&amp; workQueue.isEmpty()) || rs &gt;= STOP )</span></span><br><span class="line">        <span class="comment">// 就是 线程池状态处于 STOP 状态，</span></span><br><span class="line">        <span class="comment">// 或者 线程池状态处于 SHUTDOWN 状态 并且 workQueue 中 没有任务了。</span></span><br><span class="line">        <span class="comment">// 在这两种状态下 worker 线程将会退出。</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">			<span class="comment">// 当前线程要退出了，所以减少 workerCount 的计数。</span></span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否允许当前线程在当前线程池的状态下可以超时。</span></span><br><span class="line">        <span class="keyword">boolean</span> timed;      <span class="comment">// Are workers subject to culling?</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 线程是否超时判断。从这里可以看出，其实一个线程是否是</span></span><br><span class="line">			<span class="comment">// core 线程，还是非 core 线程，是没有固定的，也就是</span></span><br><span class="line">			<span class="comment">// 在线程池中的所有的worker线程，是依据当前线程池的状态</span></span><br><span class="line">			<span class="comment">// 来判断是超时，如果不可以超时，则认为它是 core 线程</span></span><br><span class="line">			<span class="comment">// 到第二次获取任务的时候，有可能变成 可以超时的，所以</span></span><br><span class="line">			<span class="comment">// 它变成了 非core 线程了。 </span></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (wc &lt;= maximumPoolSize &amp;&amp; ! (timedOut &amp;&amp; timed))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 1. 当前线程数量大于 maximumPoolSize</span></span><br><span class="line">            <span class="comment">// 2. 如果当前线程上次超时了，并且这次也允许超时</span></span><br><span class="line">            <span class="comment">// 这两种情况下，当前线程就应该从线程池中退出了。</span></span><br><span class="line">			<span class="comment">// 当前线程要退出了，所以减少 workerCount 的计数。</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果允许线程超时，使用 poll 来获取任务，否则使用 take 来阻塞获取任务。</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 这个设计非常好，这里并不会直接返回r，因为有可能，workQueue有可能超时</span></span><br><span class="line">            <span class="comment">// 返回 null, 所以如果直接返回 r 的时候，会使得当前线程直接退出，这会有问题，</span></span><br><span class="line">            <span class="comment">// 因为在上面的 poll 过程的 block 过程中有可能，线程池中的其它线程有可能已经</span></span><br><span class="line">            <span class="comment">// 退出，如果直接使得当前线程返回 null, 就有可能，导致线程池中的线程数量 小于</span></span><br><span class="line">            <span class="comment">// corePoolSize , 显然这不符合线程池对 corePoolSize 的语义。</span></span><br><span class="line">            <span class="comment">// 所以，这里使用 timedOut 字段标识，线程上次超了，然后，继续循环，</span></span><br><span class="line">            <span class="comment">// 在上面的代码中，会使用timedOut 状态判。然后作对应的处理。</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Executors-提供的几种线程池"><a href="#Executors-提供的几种线程池" class="headerlink" title="Executors 提供的几种线程池"></a>Executors 提供的几种线程池</h2><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这类线程池将创建线程数量最多为 nThreads 个线程，由于个这个原因， getTask 方法从队列中获取任务的方法将总是：</p>
<pre><code>workQueue.take();
</code></pre><p>所以，对于超时的配置，其实是用不到的，所以这里 keepAliveTime 参数的值是 0, 其实根本用不到。</p>
<p>这 nThreads 个线程将一直运行来执行任务。</p>
<h4 id="线程创建执行机制："><a href="#线程创建执行机制：" class="headerlink" title="线程创建执行机制："></a>线程创建执行机制：</h4><ul>
<li>前 nThreads 个任务的提交，将使当前线程中创建好 nThreads 个线程</li>
<li>后续提交的任务，将依时间顺序入队列，</li>
<li>然后由这 nThreads 个线程不继的循环消费。</li>
</ul>
<h4 id="线程超时"><a href="#线程超时" class="headerlink" title="线程超时"></a>线程超时</h4><p><strong>这个 nThreads 线程永远不会超时。</strong></p>
<h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个线程池内只有一个线程，当向这个线程池提交第一个任务时，创建这个线程。<br>提交第二个任务的时候，会直接将该任务，添加到 workerQueue 队列中。线程中的惟一那个<br>线路，开始从 workerQueue 中按添加顺序不断的执行任务。</p>
<p>同样，由于 corePoolSize == maximumPoolSize == 1, getTask 获取任务的方法是：</p>
<pre><code>workQueue.take();
</code></pre><p>所以其超时参数没有使用到。</p>
<h4 id="线程创建执行机制：-1"><a href="#线程创建执行机制：-1" class="headerlink" title="线程创建执行机制："></a>线程创建执行机制：</h4><ul>
<li>第一个任务的提交会创建这个线程池中的惟一个线程，然后任务被执行，</li>
<li>后续提交的任务，将依时间顺序直接入队列</li>
<li>线程池中的惟一线程将从队列中不断循环地取出任务，然后执行</li>
</ul>
<h4 id="线程超时-1"><a href="#线程超时-1" class="headerlink" title="线程超时"></a>线程超时</h4><p><strong>这一个线程永远不会超时。</strong></p>
<h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 corePoolSize = 0， maximumPoolSize = Integer.MAX_VALUE， 所以，<br>这个线程中的行为是，添加一个任务就会，创建一个对应的线程，当这个线程就执行<br>完毕，就等待 60 秒，如果这 60 秒内有其它任务被提交，则这个提交的任务将被这个线程<br>执行，否则，线程在 60 秒之后被回收。直接新的 任务被提交，然后重复上面的过程。</p>
<pre><code>workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)
</code></pre><p>由传入的参数，可知，在这个线程池中提交的任务执行完毕之后将等待 60 秒，然后退出。</p>
<h4 id="线程创建执行机制：-2"><a href="#线程创建执行机制：-2" class="headerlink" title="线程创建执行机制："></a>线程创建执行机制：</h4><ul>
<li><strong>如果第二个任务提交的时候，前一个任务还在执行，则这个任务会入队列失败，然后创建一个新的线程来执行</strong></li>
<li><strong>如果第二个任务提交的时候，前一个任务已经处于 poll 状态了，则这个任务将交由执行前一个任务的那个线程来执行，而不是创建新的线程</strong></li>
</ul>
<h4 id="线程超时-2"><a href="#线程超时-2" class="headerlink" title="线程超时"></a>线程超时</h4><p><strong>这个线路池中的每一个线程都是 60s 的超时时间，过了 60s 这个线程就会被回收。</strong></p>
<h2 id="关于-workerCount-状态的维护"><a href="#关于-workerCount-状态的维护" class="headerlink" title="关于 workerCount 状态的维护"></a>关于 workerCount 状态的维护</h2><h3 id="addWorker-1"><a href="#addWorker-1" class="headerlink" title="addWorker"></a>addWorker</h3><p>在每次调用 addWorker 的时候，如果一个worker(线程)可以被创建，则其在创建之后必然会调用 compareAndIncrementWorkerCount 方法来，增加 workCount ，表示线程池中增加了一个新的线程。</p>
<h3 id="getTask-1"><a href="#getTask-1" class="headerlink" title="getTask"></a>getTask</h3><p>线程通过轮询的方式来不断的执行任务。每次获取任务之前会判断是否可以线程执行。如果不行，则调用 compareAndDecrementWorkerCount， 表示当前线程将从线程池中被移除。</p>
<p>但是，存在一个问题，在 runWorker 的 main loop 中，用户代码有可能抛出异常，例如：run, beforeExecute, afterExecute 都有可能抛出异常。一旦出现异常，当前线程就会被 JVM 终止。而此时由于没有来得及调用循环中的 getTask 方法，所以，这个线程虽然已经异常终止了，但是在 workerCount 的计数中还占一位，所以必须，在处于 worker 退出的地方，进行判断，如果是异常终止，则调用 decrementWorkerCount 来清除这个异常终止的线程所占用的workerCount位。这也就是下面代码片断的原因：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当线程是异常终止的，completedAbruptly 就是 true.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn't adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.oschina.net/question/565065_86540" target="_blank" rel="noopener">Java线程池使用说明</a></p>
</div><div class="tags"><a href="/tags/ThreadPoolExecutor/">ThreadPoolExecutor</a></div><div class="post-nav"><a class="pre" href="/2016/08/15/线程池-ThreadPoolExecutor-ExecutorService/">线程池-ThreadPoolExecutor-ExecutorService</a><a class="next" href="/2016/08/11/线程池-Executor抽象/">线程池-Executor抽象</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/interface/" style="font-size: 15px;">interface</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/Collections/" style="font-size: 15px;">Collections</a> <a href="/tags/Collection/" style="font-size: 15px;">Collection</a> <a href="/tags/J-U-C/" style="font-size: 15px;">J.U.C</a> <a href="/tags/lock/" style="font-size: 15px;">lock</a> <a href="/tags/Semaphore/" style="font-size: 15px;">Semaphore</a> <a href="/tags/CyclicBarrier/" style="font-size: 15px;">CyclicBarrier</a> <a href="/tags/CountDownLatch/" style="font-size: 15px;">CountDownLatch</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/LinkedList/" style="font-size: 15px;">LinkedList</a> <a href="/tags/Queue/" style="font-size: 15px;">Queue</a> <a href="/tags/Set/" style="font-size: 15px;">Set</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/collection/" style="font-size: 15px;">collection</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/api/" style="font-size: 15px;">api</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/mvc/" style="font-size: 15px;">mvc</a> <a href="/tags/context/" style="font-size: 15px;">context</a> <a href="/tags/component-scan/" style="font-size: 15px;">component-scan</a> <a href="/tags/storm/" style="font-size: 15px;">storm</a> <a href="/tags/windows/" style="font-size: 15px;">windows</a> <a href="/tags/命令行/" style="font-size: 15px;">命令行</a> <a href="/tags/cmder/" style="font-size: 15px;">cmder</a> <a href="/tags/win/" style="font-size: 15px;">win</a> <a href="/tags/效率/" style="font-size: 15px;">效率</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/博客/" style="font-size: 15px;">博客</a> <a href="/tags/apache/" style="font-size: 15px;">apache</a> <a href="/tags/extends/" style="font-size: 15px;">extends</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/svn/" style="font-size: 15px;">svn</a> <a href="/tags/BlockingQueue/" style="font-size: 15px;">BlockingQueue</a> <a href="/tags/LinkedBlockingQueue/" style="font-size: 15px;">LinkedBlockingQueue</a> <a href="/tags/PriorityBlockingQueue/" style="font-size: 15px;">PriorityBlockingQueue</a> <a href="/tags/ConcurrentLinkedQueue/" style="font-size: 15px;">ConcurrentLinkedQueue</a> <a href="/tags/CopyOnWriteArrayList/" style="font-size: 15px;">CopyOnWriteArrayList</a> <a href="/tags/接口/" style="font-size: 15px;">接口</a> <a href="/tags/抽象类/" style="font-size: 15px;">抽象类</a> <a href="/tags/Executor/" style="font-size: 15px;">Executor</a> <a href="/tags/ExecutorService/" style="font-size: 15px;">ExecutorService</a> <a href="/tags/CompletionService/" style="font-size: 15px;">CompletionService</a> <a href="/tags/ThreadPoolExecutor/" style="font-size: 15px;">ThreadPoolExecutor</a> <a href="/tags/vim/" style="font-size: 15px;">vim</a> <a href="/tags/vundle/" style="font-size: 15px;">vundle</a> <a href="/tags/ArrayList/" style="font-size: 15px;">ArrayList</a> <a href="/tags/log/" style="font-size: 15px;">log</a> <a href="/tags/index/" style="font-size: 15px;">index</a> <a href="/tags/concepts/" style="font-size: 15px;">concepts</a> <a href="/tags/Timer/" style="font-size: 15px;">Timer</a> <a href="/tags/TimerTask/" style="font-size: 15px;">TimerTask</a> <a href="/tags/ConcurrentMap/" style="font-size: 15px;">ConcurrentMap</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 15px;">ConcurrentHashMap</a> <a href="/tags/HashMap/" style="font-size: 15px;">HashMap</a> <a href="/tags/ReentrantReadWriteLock/" style="font-size: 15px;">ReentrantReadWriteLock</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/SynchronousQueue/" style="font-size: 15px;">SynchronousQueue</a> <a href="/tags/ScheduledExecutorService/" style="font-size: 15px;">ScheduledExecutorService</a> <a href="/tags/AQS/" style="font-size: 15px;">AQS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/BigData-docker/">Windows 上安装 docker</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/mysql-0.路线/">Mysql学习路线</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/mysql-索引/">Mysql安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/Qunar基础框架-QSchedule/">Qunar基础框架-QSchedule</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/java集合构架中使用到的数据结构和算法/">java集合构架中使用到的数据结构和算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/20/reids-调试环境搭建/">redis-调试环境搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/31/OpenStack-安装/">OpenStack-安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/26/JVM-hotspot-GC机制/">JVM-hotspot-GC机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/11/netty-socketio + socket.io 实现消息推送/">netty-socketio + socket.io 实现消息推送</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/26/mongodb-安装/">mongodb-安装</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/a-ray-of-sunshine" title="github" target="_blank">github</a><ul></ul><a href="http://www.cnblogs.com/a-ray-of-sunshine" title="cnblog" target="_blank">cnblog</a><ul></ul><a href="http://blog.csdn.net/a_ray_of_sunshine" title="csdn" target="_blank">csdn</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Shawshank.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>