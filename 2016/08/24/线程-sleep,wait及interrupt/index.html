<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>线程-sleep,wait及interrupt | Shawshank</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">线程-sleep,wait及interrupt</h1><a id="logo" href="/.">Shawshank</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">线程-sleep,wait及interrupt</h1><div class="post-meta">Aug 24, 2016</div><div class="post-content"><h2 id="Thread-sleep"><a href="#Thread-sleep" class="headerlink" title="Thread.sleep"></a>Thread.sleep</h2><p>###　JVM_Sleep</p>
<p>jvm.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_Sleep(JNIEnv* env, jclass threadClass, jlong millis))</span><br><span class="line">  JVMWrapper(<span class="string">"JVM_Sleep"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), <span class="string">"timeout value is negative"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (Thread::is_interrupted (THREAD, <span class="literal">true</span>) &amp;&amp; !HAS_PENDING_EXCEPTION) &#123;</span><br><span class="line">    THROW_MSG(vmSymbols::java_lang_InterruptedException(), <span class="string">"sleep interrupted"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save current thread state and restore it at the end of this block.</span></span><br><span class="line">  <span class="comment">// And set new thread state to SLEEPING.</span></span><br><span class="line">  <span class="function">JavaThreadSleepState <span class="title">jtss</span><span class="params">(thread)</span></span>;</span><br><span class="line"></span><br><span class="line">  HS_DTRACE_PROBE1(hotspot, thread__sleep__begin, millis);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// When ConvertSleepToYield is on, this matches the classic VM implementation of</span></span><br><span class="line">    <span class="comment">// JVM_Sleep. Critical for similar threading behaviour (Win32)</span></span><br><span class="line">    <span class="comment">// It appears that in certain GUI contexts, it may be beneficial to do a short sleep</span></span><br><span class="line">    <span class="comment">// for SOLARIS</span></span><br><span class="line">    <span class="keyword">if</span> (ConvertSleepToYield) &#123;</span><br><span class="line">      os::yield();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ThreadState old_state = thread-&gt;osthread()-&gt;get_state();</span><br><span class="line">      thread-&gt;osthread()-&gt;set_state(SLEEPING);</span><br><span class="line">	  <span class="comment">// 线程在 sleep 过程中不响应中断</span></span><br><span class="line">      os::sleep(thread, MinSleepInterval, <span class="literal">false</span>);</span><br><span class="line">      thread-&gt;osthread()-&gt;set_state(old_state);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ThreadState old_state = thread-&gt;osthread()-&gt;get_state();</span><br><span class="line">    thread-&gt;osthread()-&gt;set_state(SLEEPING);</span><br><span class="line">    <span class="keyword">if</span> (os::sleep(thread, millis, <span class="literal">true</span>) == OS_INTRPT) &#123;</span><br><span class="line">	   <span class="comment">// 线程被中断了，</span></span><br><span class="line">      <span class="comment">// An asynchronous exception (e.g., ThreadDeathException) could have been thrown on</span></span><br><span class="line">      <span class="comment">// us while we were sleeping. We do not overwrite those.</span></span><br><span class="line">      <span class="keyword">if</span> (!HAS_PENDING_EXCEPTION) &#123;</span><br><span class="line">        HS_DTRACE_PROBE1(hotspot, thread__sleep__end,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// TODO-<span class="doctag">FIXME:</span> THROW_MSG returns which means we will not call set_state()</span></span><br><span class="line">        <span class="comment">// to properly restore the thread state.  That's likely wrong.</span></span><br><span class="line">		<span class="comment">// 抛出线程中断异常 InterruptedException</span></span><br><span class="line">        THROW_MSG(vmSymbols::java_lang_InterruptedException(), <span class="string">"sleep interrupted"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    thread-&gt;osthread()-&gt;set_state(old_state);</span><br><span class="line">  &#125;</span><br><span class="line">  HS_DTRACE_PROBE1(hotspot, thread__sleep__end,<span class="number">0</span>);</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure>
<p>由上面的代码可知，最终调用 os::sleep 。<br>os::sleep(thread, millis, true)</p>
<h3 id="os-sleep"><a href="#os-sleep" class="headerlink" title="os::sleep"></a>os::sleep</h3><p>os_windows.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> os::sleep(Thread* thread, jlong ms, <span class="keyword">bool</span> interruptable) &#123;</span><br><span class="line">  jlong limit = (jlong) MAXDWORD;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(ms &gt; limit) &#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">if</span> ((res = sleep(thread, limit, interruptable)) != OS_TIMEOUT)</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    ms -= limit;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert(thread == Thread::current(),  <span class="string">"thread consistency check"</span>);</span><br><span class="line">  OSThread* osthread = thread-&gt;osthread();</span><br><span class="line">  <span class="function">OSThreadWaitState <span class="title">osts</span><span class="params">(osthread, <span class="literal">false</span> <span class="comment">/* not Object.wait() */</span>)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> result;</span><br><span class="line">  <span class="keyword">if</span> (interruptable) &#123;</span><br><span class="line">    assert(thread-&gt;is_Java_thread(), <span class="string">"must be java thread"</span>);</span><br><span class="line">    JavaThread *jt = (JavaThread *) thread;</span><br><span class="line">    <span class="function">ThreadBlockInVM <span class="title">tbivm</span><span class="params">(jt)</span></span>;</span><br><span class="line"></span><br><span class="line">    jt-&gt;set_suspend_equivalent();</span><br><span class="line">    <span class="comment">// cleared by handle_special_suspend_equivalent_condition() or</span></span><br><span class="line">    <span class="comment">// java_suspend_self() via check_and_wait_while_suspended()</span></span><br><span class="line"></span><br><span class="line">    HANDLE events[<span class="number">1</span>];</span><br><span class="line">    events[<span class="number">0</span>] = osthread-&gt;interrupt_event();</span><br><span class="line">    HighResolutionInterval *phri=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(!ForceTimeHighResolution)</span><br><span class="line">      phri = <span class="keyword">new</span> HighResolutionInterval( ms );</span><br><span class="line">    <span class="keyword">if</span> (WaitForMultipleObjects(<span class="number">1</span>, events, FALSE, (DWORD)ms) == WAIT_TIMEOUT) &#123;</span><br><span class="line">      result = OS_TIMEOUT;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ResetEvent(osthread-&gt;interrupt_event());</span><br><span class="line">      osthread-&gt;set_interrupted(<span class="literal">false</span>);</span><br><span class="line">      result = OS_INTRPT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> phri; <span class="comment">//if it is NULL, harmless</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// were we externally suspended while we were waiting?</span></span><br><span class="line">    jt-&gt;check_and_wait_while_suspended();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    assert(!thread-&gt;is_Java_thread(), <span class="string">"must not be java thread"</span>);</span><br><span class="line">    Sleep((<span class="keyword">long</span>) ms);</span><br><span class="line">    result = OS_TIMEOUT;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 WaitForMultipleObjects(1, events, FALSE, (DWORD)ms) 实现等待。</p>
<h2 id="Thread-yield"><a href="#Thread-yield" class="headerlink" title="Thread.yield"></a>Thread.yield</h2><h3 id="JVM-Yield"><a href="#JVM-Yield" class="headerlink" title="JVM_Yield"></a>JVM_Yield</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_Yield(JNIEnv *env, jclass threadClass))</span><br><span class="line">  JVMWrapper(<span class="string">"JVM_Yield"</span>);</span><br><span class="line">  <span class="keyword">if</span> (os::dont_yield()) <span class="keyword">return</span>;</span><br><span class="line">  HS_DTRACE_PROBE0(hotspot, thread__yield);</span><br><span class="line">  <span class="comment">// When ConvertYieldToSleep is off (default), this matches the classic VM use of yield.</span></span><br><span class="line">  <span class="comment">// Critical for similar threading behaviour</span></span><br><span class="line">  <span class="keyword">if</span> (ConvertYieldToSleep) &#123;</span><br><span class="line">    os::sleep(thread, MinSleepInterval, <span class="literal">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    os::yield();</span><br><span class="line">  &#125;</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure>
<h3 id="os-yield"><a href="#os-yield" class="headerlink" title="os::yield"></a>os::yield</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">os::YieldResult os::NakedYield() &#123;</span><br><span class="line">  <span class="comment">// Use either SwitchToThread() or Sleep(0)</span></span><br><span class="line">  <span class="comment">// Consider passing back the return value from SwitchToThread().</span></span><br><span class="line">  <span class="keyword">if</span> (os::Kernel32Dll::SwitchToThreadAvailable()) &#123;</span><br><span class="line">    <span class="keyword">return</span> SwitchToThread() ? os::YIELD_SWITCHED : os::YIELD_NONEREADY ;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Sleep(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> os::YIELD_UNKNOWN ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> os::yield() &#123;  os::NakedYield(); &#125;</span><br></pre></td></tr></table></figure>
<p>调用 win32 API Sleep 来实现。</p>
<h3 id="Sleep-amp-WaitForMultipleObjects"><a href="#Sleep-amp-WaitForMultipleObjects" class="headerlink" title="Sleep &amp; WaitForMultipleObjects"></a>Sleep &amp; WaitForMultipleObjects</h3><p>这两个函数都是 windows 在实现 JVM 的线程 sleep 和 yelid 操作时使用的 win32 API.</p>
<p>对于实现，线程的挂起（sleep），等待（wait）这些都是由操作系统提供的线程调度功能实现。线程调度器如果提供了这样的接口，自然线程就可以 Sleep 或 wait. 如果操作系统的线程调度器没有提供这些功能，自然也就无法实现了。</p>
<p><a href="https://msdn.microsoft.com/zh-cn/library/windows/desktop/ms687025(v=vs.85" target="_blank" rel="noopener">WaitForMultipleObjects</a>.aspx) 函数的主要功能是使当前线程等待事件（lpHandles）的触发，然后在指定的时间段内如果没有触发，则该函数就返回。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">WaitForMultipleObjects</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_       DWORD  nCount,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ <span class="keyword">const</span> HANDLE *lpHandles,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_       BOOL   bWaitAll,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_       DWORD  dwMilliseconds</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>如果参数 dwMilliseconds 是 0：If dwMilliseconds is zero, the function does not enter a wait state if the specified objects are not signaled; it always returns immediately. 这个函数并不会进入 wait 状态，即使此时 lpHandles 指向的对象还没有被 signaled, 并且函数将立即返回。所以当<br>dwMilliseconds = 0 时，函数不会放弃当前的执行时间片，而会立即返回后，正常继续向下执行。</p>
<p><a href="https://msdn.microsoft.com/zh-cn/library/windows/desktop/ms686298(v=vs.85" target="_blank" rel="noopener">Sleep</a>.aspx) Suspends the execution of the current thread until the time-out interval elapses. 主要作用就是使当前线程等待这个时间段（dwMilliseconds）过去。然后返回。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID WINAPI <span class="title">Sleep</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ DWORD dwMilliseconds</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当参数 dwMilliseconds 是 0：<br>A value of zero causes the thread to relinquish the remainder of its time slice to any other thread that is ready to run. If there are no other threads ready to run, the function returns immediately, and the thread continues execution.</p>
<p>当导致当前线程放弃当前的执行时间片，而尝试重新竞争执行。所以 java.lang.Thread.yield 方法就使用这个方法（Sleeping）来实现放弃当前执行的时间片。</p>
<h2 id="Object-wait"><a href="#Object-wait" class="headerlink" title="Object.wait"></a>Object.wait</h2><h3 id="JVM-MonitorWait"><a href="#JVM-MonitorWait" class="headerlink" title="JVM_MonitorWait"></a>JVM_MonitorWait</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object.wait</span></span><br><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_MonitorWait(JNIEnv* env, jobject handle, jlong ms))</span><br><span class="line">  JVMWrapper(<span class="string">"JVM_MonitorWait"</span>);</span><br><span class="line">  <span class="comment">// THREAD 是一个全局变量定义在 runtime\sharedRuntime.cpp 文件中:</span></span><br><span class="line">  <span class="comment">// Thread* THREAD = JavaThread::current();</span></span><br><span class="line">  <span class="comment">// 由此可知 THREAD 表示当前线程。</span></span><br><span class="line">  <span class="function">Handle <span class="title">obj</span><span class="params">(THREAD, JNIHandles::resolve_non_null(handle))</span></span>;</span><br><span class="line">  assert(obj-&gt;is_instance() || obj-&gt;is_array(), <span class="string">"JVM_MonitorWait must apply to an object"</span>);</span><br><span class="line">  <span class="function">JavaThreadInObjectWaitState <span class="title">jtiows</span><span class="params">(thread, ms != <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (JvmtiExport::should_post_monitor_wait()) &#123;</span><br><span class="line">    JvmtiExport::post_monitor_wait((JavaThread *)THREAD, (oop)obj(), ms);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调用 ObjectSynchronizer 进行 wait.</span></span><br><span class="line">  ObjectSynchronizer::wait(obj, ms, CHECK);</span><br><span class="line">JVM_END</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.notify</span></span><br><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_MonitorNotify(JNIEnv* env, jobject handle))</span><br><span class="line">  JVMWrapper(<span class="string">"JVM_MonitorNotify"</span>);</span><br><span class="line">  <span class="function">Handle <span class="title">obj</span><span class="params">(THREAD, JNIHandles::resolve_non_null(handle))</span></span>;</span><br><span class="line">  assert(obj-&gt;is_instance() || obj-&gt;is_array(), <span class="string">"JVM_MonitorNotify must apply to an object"</span>);</span><br><span class="line">  ObjectSynchronizer::notify(obj, CHECK);</span><br><span class="line">JVM_END</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.notifyAll</span></span><br><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_MonitorNotifyAll(JNIEnv* env, jobject handle))</span><br><span class="line">  JVMWrapper(<span class="string">"JVM_MonitorNotifyAll"</span>);</span><br><span class="line">  <span class="function">Handle <span class="title">obj</span><span class="params">(THREAD, JNIHandles::resolve_non_null(handle))</span></span>;</span><br><span class="line">  assert(obj-&gt;is_instance() || obj-&gt;is_array(), <span class="string">"JVM_MonitorNotifyAll must apply to an object"</span>);</span><br><span class="line">  ObjectSynchronizer::notifyall(obj, CHECK);</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure>
<h3 id="ObjectSynchronizer-wait"><a href="#ObjectSynchronizer-wait" class="headerlink" title="ObjectSynchronizer::wait"></a>ObjectSynchronizer::wait</h3><p>openjdk\hotspot\src\share\vm\runtime\synchronizer.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ObjectSynchronizer::wait(Handle obj, jlong millis, TRAPS) &#123;</span><br><span class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    BiasedLocking::revoke_and_rebias(obj, <span class="literal">false</span>, THREAD);</span><br><span class="line">    assert(!obj-&gt;mark()-&gt;has_bias_pattern(), <span class="string">"biases should be revoked by now"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    TEVENT (wait - <span class="keyword">throw</span> IAX) ;</span><br><span class="line">    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), <span class="string">"timeout value is negative"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ObjectMonitor* monitor = ObjectSynchronizer::inflate(THREAD, obj());</span><br><span class="line">  DTRACE_MONITOR_WAIT_PROBE(monitor, obj(), THREAD, millis);</span><br><span class="line">  monitor-&gt;wait(millis, <span class="literal">true</span>, THREAD);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This dummy call is in place to get around dtrace bug 6254741.  Once</span></span><br><span class="line"><span class="comment">     that's fixed we can uncomment the following line and remove the call */</span></span><br><span class="line">  <span class="comment">// DTRACE_MONITOR_PROBE(waited, monitor, obj(), THREAD);</span></span><br><span class="line">  dtrace_waited_probe(monitor, obj, THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中调用 ObjectMonitor::wait 方法。</p>
<h3 id="ObjectMonitor-wait"><a href="#ObjectMonitor-wait" class="headerlink" title="ObjectMonitor::wait"></a>ObjectMonitor::wait</h3><p>openjdk\hotspot\src\share\vm\runtime\objectMonitor.cpp</p>
<p>这个文件中定义了 ObjectMonitor 实现了 wait ， notify 方法。 这个 ObjectMonitor 类应该就是 Object 进行同步时的 monitor, 每一个 java Object 都有一个 monitor.</p>
<p>ObjectMonitor类定义的一些方法和字段：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 获取 monitor(成为 monitor 的 owner) </span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span>      <span class="title">try_enter</span> <span class="params">(TRAPS)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">enter</span><span class="params">(TRAPS)</span></span>;</span><br><span class="line">  <span class="comment">// 释放 monitor</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">exit</span><span class="params">(TRAPS)</span></span>;</span><br><span class="line">  <span class="comment">// 在锁上等待。</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">wait</span><span class="params">(jlong millis, <span class="keyword">bool</span> interruptable, TRAPS)</span></span>;</span><br><span class="line">  <span class="comment">// 激发锁。</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">notify</span><span class="params">(TRAPS)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">notifyAll</span><span class="params">(TRAPS)</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">protected</span>:                         <span class="comment">// protected for jvmtiRawMonitor</span></span><br><span class="line">  <span class="keyword">void</span> *  <span class="keyword">volatile</span> _owner;          <span class="comment">// pointer to owning thread OR BasicLock</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">intptr_t</span>  _recursions;   <span class="comment">// recursion count, 0 for first entry</span></span><br></pre></td></tr></table></figure></p>
<p>这个类的实现和 JAVA 中的 java.util.concurrent.locks.AbstractQueuedSynchronizer.AbstractQueuedSynchronizer 类的实现非常相似。这些字段和方法都有相互对应的。</p>
<p>ObjectWaiter（objectMonitor.hpp 中定义） 对应  AbstractQueuedSynchronizer.Node 表示等待的线程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求锁时的阻塞队列</span></span><br><span class="line">ObjectWaiter * <span class="keyword">volatile</span> _EntryList ;     <span class="comment">// Threads blocked on entry or reentry.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// wait 的阻塞队列</span></span><br><span class="line">ObjectWaiter * <span class="keyword">volatile</span> _WaitSet; <span class="comment">// LL of threads wait()ing on the monitor</span></span><br></pre></td></tr></table></figure>
<p>这两个队列在 AbstractQueuedSynchronizer 类都有相应的实现。</p>
<h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h2><h3 id="JVM-Interrupt"><a href="#JVM-Interrupt" class="headerlink" title="JVM_Interrupt"></a>JVM_Interrupt</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_Interrupt(JNIEnv* env, jobject jthread))</span><br><span class="line">  JVMWrapper(<span class="string">"JVM_Interrupt"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ensure that the C++ Thread and OSThread structures aren't freed before we operate</span></span><br><span class="line">  oop java_thread = JNIHandles::resolve_non_null(jthread);</span><br><span class="line">  <span class="function">MutexLockerEx <span class="title">ml</span><span class="params">(thread-&gt;threadObj() == java_thread ? <span class="literal">NULL</span> : Threads_lock)</span></span>;</span><br><span class="line">  <span class="comment">// We need to re-resolve the java_thread, since a GC might have happened during the</span></span><br><span class="line">  <span class="comment">// acquire of the lock</span></span><br><span class="line">  JavaThread* thr = java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread));</span><br><span class="line">  <span class="keyword">if</span> (thr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    Thread::interrupt(thr);</span><br><span class="line">  &#125;</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure>
<h3 id="Thread-interrupt"><a href="#Thread-interrupt" class="headerlink" title="Thread::interrupt"></a>Thread::interrupt</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Thread::interrupt(Thread* thread) &#123;</span><br><span class="line">  trace(<span class="string">"interrupt"</span>, thread);</span><br><span class="line">  debug_only(check_for_dangling_thread_pointer(thread);)</span><br><span class="line">  os::interrupt(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="os-interrupt"><a href="#os-interrupt" class="headerlink" title="os::interrupt"></a>os::interrupt</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> os::interrupt(Thread* thread) &#123;</span><br><span class="line">  assert(!thread-&gt;is_Java_thread() || Thread::current() == thread || Threads_lock-&gt;owned_by_self(),</span><br><span class="line">         <span class="string">"possibility of dangling Thread pointer"</span>);</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 获得 thread 所对应的 win32 底层的线程对象</span></span><br><span class="line">  OSThread* osthread = thread-&gt;osthread();</span><br><span class="line">  <span class="comment">// 设置其中断状态。</span></span><br><span class="line">  osthread-&gt;set_interrupted(<span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// More than one thread can get here with the same value of osthread,</span></span><br><span class="line">  <span class="comment">// resulting in multiple notifications.  We do, however, want the store</span></span><br><span class="line">  <span class="comment">// to interrupted() to be visible to other threads before we post</span></span><br><span class="line">  <span class="comment">// the interrupt event.</span></span><br><span class="line">  OrderAccess::release();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面是三种不同的机制使得被中断的线程被唤醒</span></span><br><span class="line">  <span class="comment">// 确保那些被阻塞的线程能够被唤醒。</span></span><br><span class="line">  <span class="comment">// (1) win32 使用 interrupt_event 使用 signaled.</span></span><br><span class="line">  <span class="comment">// Thread.Sleep 方法就是在 osthread-&gt;interrupt_event() 上wait的</span></span><br><span class="line">  <span class="comment">// 所以如果。thread 调用了 Thread.sleep ，则此时下面的调用将会使用其</span></span><br><span class="line">  <span class="comment">// 被唤醒。</span></span><br><span class="line">  SetEvent(osthread-&gt;interrupt_event());</span><br><span class="line">  <span class="comment">// For JSR166:  unpark after setting status</span></span><br><span class="line">  <span class="comment">// (2) 对于 java 线程，有可能在其 parker 上 block</span></span><br><span class="line">  <span class="comment">// 所以使用 下面的语句唤醒。</span></span><br><span class="line">  <span class="keyword">if</span> (thread-&gt;is_Java_thread())</span><br><span class="line">    ((JavaThread*)thread)-&gt;parker()-&gt;unpark();</span><br><span class="line">  <span class="comment">// (3) 线程可能由于 synchronized 语句，处于 block</span></span><br><span class="line">  <span class="comment">// 所以 使用 ev-&gt;unpark() 来唤醒。</span></span><br><span class="line">  ParkEvent * ev = thread-&gt;_ParkEvent ;</span><br><span class="line">  <span class="keyword">if</span> (ev != <span class="literal">NULL</span>) ev-&gt;unpark() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的实现可知 java.lang.Thread.interrupt() 方法调用的功能是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前线程 T1</span></span><br><span class="line">T2.interrupt();</span><br></pre></td></tr></table></figure>
<p>如果 线程T1 在 线程 T2 上调用 interrupt 方法。则：</p>
<ol>
<li><p>T2线程的底层系统线程的 _interrupted 被设置成 ture</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osthread-&gt;set_interrupted(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>T1 线程将调用三种唤醒 T2 线程的方法，确保 可能 处于 block 状态的 T2 线程能够被唤醒。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SetEvent(osthread-&gt;interrupt_event());</span><br><span class="line">((JavaThread*)thread)-&gt;parker()-&gt;unpark();</span><br><span class="line">ev-&gt;unpark() ;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这两个件事做完之后，<code>T2.interrupt()</code>方法就返回了，T1线程继续向下执行，而此时 T2 就可能从 block 状态唤醒了（有可能 T1 本身就没有处于 block 状态），那么对于由于被T1线程中断的线程 T2 而醒来的线程，会怎样牌这个中断呢？这取决于不同的阻塞操作的实现。Thread.sleep , Object.wait 都是可中断的，线程T2唤醒之后，就会有不同的中断响应:</p>
<ul>
<li>sleep</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THROW_MSG(vmSymbols::java_lang_InterruptedException(), <span class="string">"sleep interrupted"</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>wait</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THROW(vmSymbols::java_lang_InterruptedException());</span><br></pre></td></tr></table></figure>
<p>两者都是抛出 java.lang.InterruptedException 异常，并且将中断状态位清除掉。</p>
<p>对于 java 线程这边，对于中断处理有两种机制：</p>
<ol>
<li>抛出 java.lang.InterruptedException 异常</li>
<li>isInterrupted 方法返回中断状态为 true.</li>
</ol>
<p>一般来说响应中断操作，可以使用上面的两种方法来表达，并且，是互斥的。例如 Thread.sleep 选择使用 抛出异常的方法来表达线程被中断了，所以就将线程的中断状态位设置成 false. 此时线程调用 isInterrupted 返回false.</p>
<p>对于可以被中断的方法如何响应中断，可以参考文档：java.lang.Thread.interrupt 的文档，其中有详细的描述。</p>
<h3 id="os-is-interrupted"><a href="#os-is-interrupted" class="headerlink" title="os::is_interrupted"></a>os::is_interrupted</h3><p>判断线程是否被中断<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bool os::is_interrupted(Thread* thread, bool clear_interrupted) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(!thread-&gt;is_Java_thread() || Thread::current() == thread || Threads_lock-&gt;owned_by_self(),</span><br><span class="line">         <span class="string">"possibility of dangling Thread pointer"</span>);</span><br><span class="line"></span><br><span class="line">  OSThread* osthread = thread-&gt;osthread();</span><br><span class="line">  <span class="comment">// 返回线程中断状态。</span></span><br><span class="line">  bool interrupted = osthread-&gt;interrupted();</span><br><span class="line">  <span class="comment">// There is no synchronization between the setting of the interrupt</span></span><br><span class="line">  <span class="comment">// and it being cleared here. It is critical - see 6535709 - that</span></span><br><span class="line">  <span class="comment">// we only clear the interrupt state, and reset the interrupt event,</span></span><br><span class="line">  <span class="comment">// if we are going to report that we were indeed interrupted - else</span></span><br><span class="line">  <span class="comment">// an interrupt can be "lost", leading to spurious wakeups or lost wakeups</span></span><br><span class="line">  <span class="comment">// depending on the timing</span></span><br><span class="line">  <span class="keyword">if</span> (interrupted &amp;&amp; clear_interrupted) &#123;</span><br><span class="line">    osthread-&gt;set_interrupted(<span class="keyword">false</span>);</span><br><span class="line">    ResetEvent(osthread-&gt;interrupt_event());</span><br><span class="line">  &#125; <span class="comment">// Otherwise leave the interrupted state alone</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> interrupted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>中断状态操作：</p>
<ul>
<li>获取 osthread-&gt;interrupted();</li>
<li>设置 osthread-&gt;set_interrupted(true);</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// osThread.hpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OSThread</span>:</span> <span class="keyword">public</span> CHeapObj &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">volatile</span> jint _interrupted;     <span class="comment">// Thread.isInterrupted state</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">volatile</span> <span class="keyword">bool</span> <span class="title">interrupted</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _interrupted != <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_interrupted</span><span class="params">(<span class="keyword">bool</span> z)</span> </span>&#123; _interrupted = z ? <span class="number">1</span> : <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="java-中断的本质"><a href="#java-中断的本质" class="headerlink" title="java 中断的本质"></a>java 中断的本质</h2><p>从中断的发生和中断状态的判断的实现来看，中断是 Java 平台 或者说是 JVM 提供的一种线程操作行为，和java线程对应的底层的操作系统线程没有任何关系。所以当一个 java 线程发生中断时，JVM 所做的就是记录这个状态位。系统底层线程的调度运行不会感知到 JVM 的中断行为。抛异常，也是 JVM 的行为。至于如何应对这个中断，就看具体的可中断方法（sleep, wait, join）是如何处理的。</p>
<p>所以 Thread.interrupt <strong>不会直接导致线程被终止运行</strong>，而只是 JVM 对线程的一种操作而已。</p>
<p>这篇文章 <a href="http://www.infoq.com/cn/articles/java-interrupt-mechanism" target="_blank" rel="noopener">详细分析Java中断机制</a> 对 Thread.interrupt 的功能描述：<strong>Java中断机制是一种协作机制，也就是说通过中断并不能直接终止另一个线程，而需要被中断的线程自己处理中断</strong></p>
<p><a href="http://www.ibm.com/developerworks/cn/java/j-jtp05236.html" target="_blank" rel="noopener">Java 理论与实践: 处理 InterruptedException</a></p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2016/08/25/native方法的调用及JNI/">native方法的调用及JNI</a><a class="next" href="/2016/08/23/Unsafe类/">Unsafe类</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/interface/" style="font-size: 15px;">interface</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/Collections/" style="font-size: 15px;">Collections</a> <a href="/tags/Collection/" style="font-size: 15px;">Collection</a> <a href="/tags/J-U-C/" style="font-size: 15px;">J.U.C</a> <a href="/tags/lock/" style="font-size: 15px;">lock</a> <a href="/tags/Semaphore/" style="font-size: 15px;">Semaphore</a> <a href="/tags/CyclicBarrier/" style="font-size: 15px;">CyclicBarrier</a> <a href="/tags/CountDownLatch/" style="font-size: 15px;">CountDownLatch</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/LinkedList/" style="font-size: 15px;">LinkedList</a> <a href="/tags/Queue/" style="font-size: 15px;">Queue</a> <a href="/tags/Set/" style="font-size: 15px;">Set</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/collection/" style="font-size: 15px;">collection</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/api/" style="font-size: 15px;">api</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/mvc/" style="font-size: 15px;">mvc</a> <a href="/tags/context/" style="font-size: 15px;">context</a> <a href="/tags/component-scan/" style="font-size: 15px;">component-scan</a> <a href="/tags/storm/" style="font-size: 15px;">storm</a> <a href="/tags/windows/" style="font-size: 15px;">windows</a> <a href="/tags/命令行/" style="font-size: 15px;">命令行</a> <a href="/tags/cmder/" style="font-size: 15px;">cmder</a> <a href="/tags/win/" style="font-size: 15px;">win</a> <a href="/tags/效率/" style="font-size: 15px;">效率</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/博客/" style="font-size: 15px;">博客</a> <a href="/tags/apache/" style="font-size: 15px;">apache</a> <a href="/tags/extends/" style="font-size: 15px;">extends</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/svn/" style="font-size: 15px;">svn</a> <a href="/tags/BlockingQueue/" style="font-size: 15px;">BlockingQueue</a> <a href="/tags/LinkedBlockingQueue/" style="font-size: 15px;">LinkedBlockingQueue</a> <a href="/tags/PriorityBlockingQueue/" style="font-size: 15px;">PriorityBlockingQueue</a> <a href="/tags/ConcurrentLinkedQueue/" style="font-size: 15px;">ConcurrentLinkedQueue</a> <a href="/tags/CopyOnWriteArrayList/" style="font-size: 15px;">CopyOnWriteArrayList</a> <a href="/tags/接口/" style="font-size: 15px;">接口</a> <a href="/tags/抽象类/" style="font-size: 15px;">抽象类</a> <a href="/tags/Executor/" style="font-size: 15px;">Executor</a> <a href="/tags/ExecutorService/" style="font-size: 15px;">ExecutorService</a> <a href="/tags/CompletionService/" style="font-size: 15px;">CompletionService</a> <a href="/tags/ThreadPoolExecutor/" style="font-size: 15px;">ThreadPoolExecutor</a> <a href="/tags/vim/" style="font-size: 15px;">vim</a> <a href="/tags/vundle/" style="font-size: 15px;">vundle</a> <a href="/tags/ArrayList/" style="font-size: 15px;">ArrayList</a> <a href="/tags/log/" style="font-size: 15px;">log</a> <a href="/tags/index/" style="font-size: 15px;">index</a> <a href="/tags/concepts/" style="font-size: 15px;">concepts</a> <a href="/tags/Timer/" style="font-size: 15px;">Timer</a> <a href="/tags/TimerTask/" style="font-size: 15px;">TimerTask</a> <a href="/tags/ConcurrentMap/" style="font-size: 15px;">ConcurrentMap</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 15px;">ConcurrentHashMap</a> <a href="/tags/HashMap/" style="font-size: 15px;">HashMap</a> <a href="/tags/ReentrantReadWriteLock/" style="font-size: 15px;">ReentrantReadWriteLock</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/SynchronousQueue/" style="font-size: 15px;">SynchronousQueue</a> <a href="/tags/ScheduledExecutorService/" style="font-size: 15px;">ScheduledExecutorService</a> <a href="/tags/AQS/" style="font-size: 15px;">AQS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/BigData-docker/">Windows 上安装 docker</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/mysql-0.路线/">Mysql学习路线</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/mysql-索引/">Mysql安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/Qunar基础框架-QSchedule/">Qunar基础框架-QSchedule</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/java集合构架中使用到的数据结构和算法/">java集合构架中使用到的数据结构和算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/20/reids-调试环境搭建/">redis-调试环境搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/31/OpenStack-安装/">OpenStack-安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/26/JVM-hotspot-GC机制/">JVM-hotspot-GC机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/11/netty-socketio + socket.io 实现消息推送/">netty-socketio + socket.io 实现消息推送</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/26/mongodb-安装/">mongodb-安装</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/a-ray-of-sunshine" title="github" target="_blank">github</a><ul></ul><a href="http://www.cnblogs.com/a-ray-of-sunshine" title="cnblog" target="_blank">cnblog</a><ul></ul><a href="http://blog.csdn.net/a_ray_of_sunshine" title="csdn" target="_blank">csdn</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Shawshank.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>