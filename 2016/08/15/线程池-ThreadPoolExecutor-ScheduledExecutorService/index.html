<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>线程池-ThreadPoolExecutor-ScheduledExecutorService | Shawshank</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">线程池-ThreadPoolExecutor-ScheduledExecutorService</h1><a id="logo" href="/.">Shawshank</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">线程池-ThreadPoolExecutor-ScheduledExecutorService</h1><div class="post-meta">Aug 15, 2016</div><div class="post-content"><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ScheduledExecutorService</span> <span class="keyword">extends</span> <span class="title">ExecutorService</span></span></span><br></pre></td></tr></table></figure>
<p>这个接口继承自 ExecutorService, 主要作用是提供 延时调度 和 周期性调度。</p>
<ul>
<li><p>schedule</p>
<p>  提供延时调度功能，并且返回一个 ScheduledFuture 对象，这个对象提供取消或检查任务的执行。</p>
</li>
<li><p>scheduleAtFixedRate</p>
<p>  调度机制：</p>
<ol>
<li>第一次延时 initialDelay 调用。</li>
<li>之后以 initialDelay + (n - 1) <em> period 的周期来循环调用。n 表示当前执行的次数。例如第二次时调用的间隔是： initialDelay + (2 - 1) </em> period，第三次调用的间隔是： initialDelay + (3 - 1) * period</li>
</ol>
</li>
<li><p>scheduleWithFixedDelay</p>
<p>  调度机制：</p>
<ol>
<li>第一次延时 initialDelay 调用。</li>
<li>之后以 period 的周期来循环调用。</li>
</ol>
</li>
</ul>
<p>注意，上面的 schedule 方法，延时参数，可以是 0 或者是负值，表示没有延时，立即执行。但是对于，    调用周期 period 这个参数，则不能 &lt;= 0, 如果 &lt;= 0, 则IllegalArgumentException。</p>
<p><strong>注意：这类方法接受参数 delay 和 period 都是相对时间，而不是直接使用绝对的日期或时间。</strong></p>
<p>也可以使用该类的 execute 和 submit 方法，这些方法调用，默认使用的延时为 0，也就是立即执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    schedule(command, <span class="number">0</span>, TimeUnit.NANOSECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ScheduledExecutorService</span></span></span><br><span class="line"><span class="class">        </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">// 构造函数</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">ScheduledThreadPoolExecutor</span>(<span class="title">int</span> <span class="title">corePoolSize</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, TimeUnit.NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数中使用的 BlockingQueue 是 DelayedWorkQueue 这个类是 ScheduledThreadPoolExecutor 的内部类。</p>
<h3 id="schedule-任务提交的过程。"><a href="#schedule-任务提交的过程。" class="headerlink" title="schedule 任务提交的过程。"></a>schedule 任务提交的过程。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br><span class="line">                                   <span class="keyword">long</span> delay,</span><br><span class="line">                                   TimeUnit unit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// decorateTask 方法直接返回</span></span><br><span class="line">    <span class="comment">//  new ScheduledFutureTask&lt;Void&gt;(command, </span></span><br><span class="line">    <span class="comment">//      null,triggerTime(delay, unit)</span></span><br><span class="line">    <span class="comment">// 这个任务。和 sumbit 方法类似，schedule对提交</span></span><br><span class="line">    <span class="comment">// 的任务（command）进行了包装，返回一个</span></span><br><span class="line">    <span class="comment">// RunnableFuture 对象。</span></span><br><span class="line">    RunnableScheduledFuture&lt;?&gt; t = decorateTask(command,</span><br><span class="line">        <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command, <span class="keyword">null</span>,</span><br><span class="line">                                      triggerTime(delay, unit)));</span><br><span class="line">                                      </span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 处理延迟时间</span></span><br><span class="line"><span class="comment">// triggerTime 将时间转换为 纳秒（ns）</span></span><br><span class="line"><span class="comment">// 然后调用内部的 triggerTime， 将这个相对时间</span></span><br><span class="line"><span class="comment">// 转换为绝对时间： now() + delay. 这样，这个值</span></span><br><span class="line"><span class="comment">// 将表示 当前这个任务触发（被调度）的时间。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">triggerTime</span><span class="params">(<span class="keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> triggerTime(unit.toNanos((delay &lt; <span class="number">0</span>) ? <span class="number">0</span> : delay));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">triggerTime</span><span class="params">(<span class="keyword">long</span> delay)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> now() +</span><br><span class="line">        ((delay &lt; (Long.MAX_VALUE &gt;&gt; <span class="number">1</span>)) ? delay : overflowFree(delay));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>// 2. 将任务添加到任务队列中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">delayedExecute</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isShutdown())</span><br><span class="line">        reject(task);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">// 1. 任务直接入队列。</span></span><br><span class="line">        <span class="keyword">super</span>.getQueue().add(task);</span><br><span class="line">        <span class="comment">// 处理线程池关闭的情况。</span></span><br><span class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp;</span><br><span class="line">            !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp;</span><br><span class="line">            remove(task))</span><br><span class="line">            task.cancel(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 这个调用非常重要。由于 task 直接入队列了</span></span><br><span class="line">        <span class="comment">// 所以 schedul 必须保证，能够启动 worker</span></span><br><span class="line">        <span class="comment">// 所以这里直接使用下面的方法来启动 worker.</span></span><br><span class="line">        <span class="comment">// 这些 worker 将作为消费者，来处理 </span></span><br><span class="line">        <span class="comment">// BlockingQueue 中的任务。</span></span><br><span class="line">            ensurePrestart();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="ScheduledFutureTask"><a href="#ScheduledFutureTask" class="headerlink" title="ScheduledFutureTask"></a>ScheduledFutureTask</h4><p>这个类对 task 进行包装。这上方法的核心是 run 方法，其实现了，周期性调度的功能。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 判断任务是否是周期性的。</span></span><br><span class="line">    <span class="keyword">boolean</span> periodic = isPeriodic();</span><br><span class="line">    <span class="keyword">if</span> (!canRunInCurrentRunState(periodic))</span><br><span class="line">        cancel(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 如果任务不是周期性的，则直接调用，</span></span><br><span class="line">    <span class="comment">// 然后直接返回</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!periodic)</span><br><span class="line">        ScheduledFutureTask.<span class="keyword">super</span>.run();</span><br><span class="line">    <span class="comment">// 如果任务是周期性的则，调用 runAndReset 方法</span></span><br><span class="line">    <span class="comment">// 这个方法执行完 task 之后会将当前 Future 的</span></span><br><span class="line">    <span class="comment">// state 恢复成 NEW 状态。使得这个 task 可以</span></span><br><span class="line">    <span class="comment">// 被再次调用。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ScheduledFutureTask.<span class="keyword">super</span>.runAndReset()) &#123;</span><br><span class="line">    	<span class="comment">// 如果上面调用成功：</span></span><br><span class="line">    	<span class="comment">// 1. 计算任务下次被调用的时间。</span></span><br><span class="line">        setNextRunTime();</span><br><span class="line">        <span class="comment">// 2. 因为当前任务已经被调用过一次了</span></span><br><span class="line">        <span class="comment">//    所以需要将任务，重新添加到队列中。</span></span><br><span class="line">        reExecutePeriodic(outerTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="任务的获取"><a href="#任务的获取" class="headerlink" title="任务的获取"></a>任务的获取</h2><p>任务获取是从 DelayedWorkQueue 这个队列中。使用 take 方法。take 方法的核心部分。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    RunnableScheduledFuture first = queue[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">        available.await();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> delay = first.getDelay(TimeUnit.NANOSECONDS);</span><br><span class="line">        <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> finishPoll(first);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">            available.await();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Thread thisThread = Thread.currentThread();</span><br><span class="line">            leader = thisThread;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                available.awaitNanos(delay);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                    leader = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="DelayedWorkQueue"><a href="#DelayedWorkQueue" class="headerlink" title="DelayedWorkQueue"></a>DelayedWorkQueue</h2><p>这是一个基于二叉堆的队列结构。同时这也是个最小堆，堆顶元素是当前队列中 delay time 最小的元素。正因为如此，队列的 take 操作将在堆顶进行，也就是 queue[0] 元素上进行，这个任务将是第一个需要出队列的任务。</p>
<h3 id="入队列操作"><a href="#入队列操作" class="headerlink" title="入队列操作"></a>入队列操作</h3><p>入队列是无阻塞的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(Runnable x) &#123;</span><br><span class="line">    if (x == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    RunnableScheduledFuture e = (RunnableScheduledFuture)x;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        int i = size;</span><br><span class="line">        if (i &gt;= queue.length)</span><br><span class="line">            grow();</span><br><span class="line">        size = i + 1;</span><br><span class="line">        if (i == 0) &#123;</span><br><span class="line">            queue[0] = e;</span><br><span class="line">            setIndex(e, 0);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">			// 入队列，并将最开始执行的任务，调整到队列头部。</span><br><span class="line">            siftUp(i, e);</span><br><span class="line">        &#125;</span><br><span class="line">		// queue[0] == e 表示 e 是队列中当前惟一一个元素</span><br><span class="line">		// 在此之前，有可能 worker 线程已经在 进行 take 操作了，</span><br><span class="line">		// 而由于队列中没有元素，所以 worker 线程会进入等待状态</span><br><span class="line">		// available.await();</span><br><span class="line">		// 所以，当队列中的第一个元素入队列成功之后，调用</span><br><span class="line">		// available.signal() 来唤醒 worker 线程。</span><br><span class="line">        if (queue[0] == e) &#123;</span><br><span class="line">            leader = null;</span><br><span class="line">            available.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="出队列操作"><a href="#出队列操作" class="headerlink" title="出队列操作"></a>出队列操作</h3><p>这个一个阻塞操作，并且也是线程安全的。线程池中的多个 worker 线程，可能同时调用 take 方法来获取任务。此时由于锁 lock 的保护，当且仅当 只有一个线程会获得锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RunnableScheduledFuture <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">			<span class="comment">// 队头元素 queue[0], 就是要执行的任务</span></span><br><span class="line">            RunnableScheduledFuture first = queue[<span class="number">0</span>];</span><br><span class="line">			<span class="comment">// 任务为null, 说明此时还没有任务被提交，所以 wait.</span></span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                available.await();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 任务不为空，则获取当前时间 到 任务开始执行的时间（getDelay）</span></span><br><span class="line">				<span class="comment">// 的时间间隔 delay</span></span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(TimeUnit.NANOSECONDS);</span><br><span class="line">				<span class="comment">// 如果 delay &lt;= 0 表示，任务已经可以运行了，所以调用</span></span><br><span class="line">				<span class="comment">// finishPoll(first) 方法将 first 出队列，获取到 first</span></span><br><span class="line">				<span class="comment">// 的 worker 线程将开始执行任务。</span></span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> finishPoll(first);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                    available.await();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="comment">// 开始进入等待状态，等待的时间就是 delay</span></span><br><span class="line">						<span class="comment">// 从逻辑上看，这个等待返回之后，delay 将</span></span><br><span class="line">						<span class="comment">// &lt;= 0，所以 first 任务可以被调度了</span></span><br><span class="line">						<span class="comment">// 所以这个循环将在上面的 return finishPoll(first);</span></span><br><span class="line">						<span class="comment">// 中退出。</span></span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; queue[<span class="number">0</span>] != <span class="keyword">null</span>)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="take-方法中-leader-的作用"><a href="#take-方法中-leader-的作用" class="headerlink" title="take 方法中 leader 的作用"></a>take 方法中 leader 的作用</h4><p>在上面的 take 方法的实现过程中还维护了一个 leader 字段，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private Thread leader = null;</span><br></pre></td></tr></table></figure>
<p>这个字段的作用应该<br>是，协调在 first 任务上等待的多个 worker 线程。<br>ScheduledThreadPoolExecutor.DelayedWorkQueue.leader<br>中有关于这个字段的注释。</p>
<p>Thread designated to wait for the task at the head of the queue.  This variant of the Leader-Follower pattern serves to minimize unnecessary timed waiting.</p>
<p>作用：最小化 worker 线程的等待时间。</p>
<p>take 过程：假设，有 T1, T2, T3 三个 worker 线程，在竞争获取 queue[0] 任务。</p>
<ul>
<li>当 T1 成功执行到 take 的循环中的最后一个 else 中的  available.awaitNanos(delay); 线程时， leader 就会被设置成 T1。</li>
<li>此时处于 wait 过程的线程 T1, 将放弃锁 lock, 所以 T2, T3 又开始竞争锁<br>假设 T2 获得锁，进行循环执行到 else if (leader != null) ，显然 leader 已经是 T1 了，所以这个判断成立，所以 T2 会进入  available.await();</li>
<li>此时 T1 因为 available.awaitNanos(delay) delay 时间已过，所以被唤醒，重新获取锁之后，将 leader 置为 null, 在 T1 返回之前，执行最后的 finally 语句，将通知 像 T2 这样的线程（处于 available.await()），使得 T2 可以立即参与到下一次获取 queue[0] 的过程中。</li>
<li>此时，T1 获取了任务，正在执行，T2 被 T1 唤醒，T2 和 T3 又开始了第一个步骤中的过程一样进行任务获取了。</li>
</ul>
<p>通过这三个 worker 线程获取任务的过程可知：leader 的使用，使得 worker 线程的 wait 最小化，尽量使得 worker 能够参与到任务的获取和执行中来。</p>
<p>试想如果不使用 leader， 则 T1, T2, T3 线程最终都进入  available.awaitNanos(delay); 的过程，而对于一个任务来说，多个线程在其上等待是没有意义的，因为最终只需要一个线程来执行任务，而不是所有在其上 wait 的线程，所以 leader 其实也可以认为是当前queue[0]最终可以被获成功的那个线程。显然应该只有一个，所以其它线程应该是直接available.await(); 而不是  available.awaitNanos(delay);</p>
<p><strong>注意：上面的描述分析完全要结合ScheduledThreadPoolExecutor.DelayedWorkQueue.take 的源代码来看</strong></p>
<h2 id="周期性调度方法的实现"><a href="#周期性调度方法的实现" class="headerlink" title="周期性调度方法的实现"></a>周期性调度方法的实现</h2><ul>
<li><p>scheduleAtFixedRate</p>
<p>  表示固定的调用周期，其对应的 task 是： </p>
<pre><code>new ScheduledFutureTask&lt;Void&gt;(command,
                              null,
                              triggerTime(initialDelay, unit),
                              unit.toNanos(period))
</code></pre></li>
<li><p>scheduleWithFixedDelay</p>
<p>  表示固定的调用频率，其对应的 task 是：</p>
<pre><code>new ScheduledFutureTask&lt;Void&gt;(command,
                              null,
                              triggerTime(initialDelay, unit),
                              unit.toNanos(-delay))
</code></pre></li>
</ul>
<p>注意到通过这两个方法提交的任务惟一不同的就是第四个参数 period.<br>scheduleWithFixedDelay 调用中将 period 设置成 -delay.</p>
<p>ScheduledThreadPoolExecutor.ScheduledFutureTask.period 字段的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Period in nanoseconds for repeating tasks.  A positive</span></span><br><span class="line"><span class="comment"> * value indicates fixed-rate execution.  A negative value</span></span><br><span class="line"><span class="comment"> * indicates fixed-delay execution.  A value of 0 indicates a</span></span><br><span class="line"><span class="comment"> * non-repeating task.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> period;</span><br></pre></td></tr></table></figure>
<p>由此：</p>
<ul>
<li>period &lt; 0 &lt;==&gt; fixed-delay execution 固定延时任务</li>
<li>period = 0 &lt;==&gt; non-repeating task    非周期性任务</li>
<li>period &gt; 0 &lt;==&gt; fixed-rate execution  固定频率任务</li>
</ul>
<p>对于周期性任务，在前面的分析可知，当该任务成功执行完毕之后，将会重新添加到 queue 中，此时就要重新设置 time ,也就是下次执行的时间，使用方法 setNextRunTime：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setNextRunTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> p = period;</span><br><span class="line">    <span class="keyword">if</span> (p &gt; <span class="number">0</span>) <span class="comment">// 固定频率，所以直接在上次执行的time上加 period.</span></span><br><span class="line">        time += p; <span class="comment">// time = time + period;</span></span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">// 固定延时，表示以后任务开始执行的时间，都是当前时间 加 period</span></span><br><span class="line">        time = triggerTime(-p); <span class="comment">// time = now() + period</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="定时调度的设计实现"><a href="#定时调度的设计实现" class="headerlink" title="定时调度的设计实现"></a>定时调度的设计实现</h2><p>ScheduledThreadPoolExecutor 线程池实现分析。</p>
<p>所谓定时调度就是：延迟调度和周期性循环调度。其实现过程分析如下：</p>
<p>不管是延迟调度，还是周期性调度，所有这类 任务(task) 最终都有其所对应的开始执行时间(enbaled time)，这个开始时间。ScheduledFutureTask 是这类任务的一个具体实现。其中有一个 time 字段，这个字段就表示，任务可以被调度的开始时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledFutureTask</span>&lt;<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableScheduledFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Sequence number to break ties FIFO */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The time the task is enabled to execute in nanoTime units */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time;</span><br></pre></td></tr></table></figure>
<p>所以对于每一个 任务(ScheduledFutureTask) 都有对应的开始时间。并且任务只有在这个时间点（time） 才可以运行。所以线程池的任务的执行，自然地就有了顺序，就是按照这个开始时间。所以 ScheduledThreadPoolExecutor 就应该将所有提交的任务进行排队（按开始执行时间排序），然后 worker 线程从队列中取出，时间最近的任务开始执行。这样就需要任务是可以排序的，所以 ScheduledFutureTask 实现了  java.lang.Comparable 接口。用任务的开始执行时间来确定任务的优先级。</p>
<p>compareTo 方法实现的基本思路就是：使用 开始执行时间 time 和 任务提交时的序号 sequenceNumber（体现任务的提交时间先后顺序），开确定任务的大小。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (other == <span class="keyword">this</span>) <span class="comment">// compare zero ONLY if same object</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (other <span class="keyword">instanceof</span> ScheduledFutureTask) &#123;</span><br><span class="line">        ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;</span><br><span class="line">        <span class="keyword">long</span> diff = time - x.time;</span><br><span class="line">        <span class="keyword">if</span> (diff &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> d = (getDelay(TimeUnit.NANOSECONDS) -</span><br><span class="line">              other.getDelay(TimeUnit.NANOSECONDS));</span><br><span class="line">    <span class="keyword">return</span> (d == <span class="number">0</span>) ? <span class="number">0</span> : ((d &lt; <span class="number">0</span>) ? -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法将被用在 任务（ScheduledFutureTask） 入队列的时候，也就是 DelayedWorkQueue 这个队列的 入队列操作（offer） 中。offer方法将以<br>此来确定堆顶元素。从而保证堆顶的元素是当前所有任务要最近执行的任务。</p>
</div><div class="tags"><a href="/tags/ThreadPoolExecutor/">ThreadPoolExecutor</a><a href="/tags/ScheduledExecutorService/">ScheduledExecutorService</a></div><div class="post-nav"><a class="pre" href="/2016/08/15/线程池-ThreadPoolExecutor-ExecutorService/">线程池-ThreadPoolExecutor-ExecutorService</a><a class="next" href="/2016/08/11/线程池-ThreadPoolExecutor/">线程池-ThreadPoolExecutor</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/interface/" style="font-size: 15px;">interface</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/Collections/" style="font-size: 15px;">Collections</a> <a href="/tags/Collection/" style="font-size: 15px;">Collection</a> <a href="/tags/J-U-C/" style="font-size: 15px;">J.U.C</a> <a href="/tags/lock/" style="font-size: 15px;">lock</a> <a href="/tags/Semaphore/" style="font-size: 15px;">Semaphore</a> <a href="/tags/CountDownLatch/" style="font-size: 15px;">CountDownLatch</a> <a href="/tags/CyclicBarrier/" style="font-size: 15px;">CyclicBarrier</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/LinkedList/" style="font-size: 15px;">LinkedList</a> <a href="/tags/Queue/" style="font-size: 15px;">Queue</a> <a href="/tags/Set/" style="font-size: 15px;">Set</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/collection/" style="font-size: 15px;">collection</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/api/" style="font-size: 15px;">api</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/mvc/" style="font-size: 15px;">mvc</a> <a href="/tags/context/" style="font-size: 15px;">context</a> <a href="/tags/component-scan/" style="font-size: 15px;">component-scan</a> <a href="/tags/storm/" style="font-size: 15px;">storm</a> <a href="/tags/windows/" style="font-size: 15px;">windows</a> <a href="/tags/命令行/" style="font-size: 15px;">命令行</a> <a href="/tags/cmder/" style="font-size: 15px;">cmder</a> <a href="/tags/win/" style="font-size: 15px;">win</a> <a href="/tags/效率/" style="font-size: 15px;">效率</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/博客/" style="font-size: 15px;">博客</a> <a href="/tags/apache/" style="font-size: 15px;">apache</a> <a href="/tags/extends/" style="font-size: 15px;">extends</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/svn/" style="font-size: 15px;">svn</a> <a href="/tags/BlockingQueue/" style="font-size: 15px;">BlockingQueue</a> <a href="/tags/LinkedBlockingQueue/" style="font-size: 15px;">LinkedBlockingQueue</a> <a href="/tags/PriorityBlockingQueue/" style="font-size: 15px;">PriorityBlockingQueue</a> <a href="/tags/ConcurrentLinkedQueue/" style="font-size: 15px;">ConcurrentLinkedQueue</a> <a href="/tags/CopyOnWriteArrayList/" style="font-size: 15px;">CopyOnWriteArrayList</a> <a href="/tags/接口/" style="font-size: 15px;">接口</a> <a href="/tags/抽象类/" style="font-size: 15px;">抽象类</a> <a href="/tags/Executor/" style="font-size: 15px;">Executor</a> <a href="/tags/ExecutorService/" style="font-size: 15px;">ExecutorService</a> <a href="/tags/CompletionService/" style="font-size: 15px;">CompletionService</a> <a href="/tags/ThreadPoolExecutor/" style="font-size: 15px;">ThreadPoolExecutor</a> <a href="/tags/vim/" style="font-size: 15px;">vim</a> <a href="/tags/vundle/" style="font-size: 15px;">vundle</a> <a href="/tags/ArrayList/" style="font-size: 15px;">ArrayList</a> <a href="/tags/log/" style="font-size: 15px;">log</a> <a href="/tags/index/" style="font-size: 15px;">index</a> <a href="/tags/concepts/" style="font-size: 15px;">concepts</a> <a href="/tags/Timer/" style="font-size: 15px;">Timer</a> <a href="/tags/TimerTask/" style="font-size: 15px;">TimerTask</a> <a href="/tags/ConcurrentMap/" style="font-size: 15px;">ConcurrentMap</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 15px;">ConcurrentHashMap</a> <a href="/tags/HashMap/" style="font-size: 15px;">HashMap</a> <a href="/tags/ReentrantReadWriteLock/" style="font-size: 15px;">ReentrantReadWriteLock</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/SynchronousQueue/" style="font-size: 15px;">SynchronousQueue</a> <a href="/tags/ScheduledExecutorService/" style="font-size: 15px;">ScheduledExecutorService</a> <a href="/tags/AQS/" style="font-size: 15px;">AQS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/BigData-docker/">Windows 上安装 docker</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/mysql-0.路线/">Mysql学习路线</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/mysql-索引/">Mysql安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/Qunar基础框架-QSchedule/">Qunar基础框架-QSchedule</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/java集合构架中使用到的数据结构和算法/">java集合构架中使用到的数据结构和算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/20/reids-调试环境搭建/">redis-调试环境搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/31/OpenStack-安装/">OpenStack-安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/26/JVM-hotspot-GC机制/">JVM-hotspot-GC机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/11/netty-socketio + socket.io 实现消息推送/">netty-socketio + socket.io 实现消息推送</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/26/mongodb-安装/">mongodb-安装</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/a-ray-of-sunshine" title="github" target="_blank">github</a><ul></ul><a href="http://www.cnblogs.com/a-ray-of-sunshine" title="cnblog" target="_blank">cnblog</a><ul></ul><a href="http://blog.csdn.net/a_ray_of_sunshine" title="csdn" target="_blank">csdn</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Shawshank.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>