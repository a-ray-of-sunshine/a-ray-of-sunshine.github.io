<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>线程-创建和启动 | Shawshank</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">线程-创建和启动</h1><a id="logo" href="/.">Shawshank</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">线程-创建和启动</h1><div class="post-meta">Aug 22, 2016</div><div class="post-content"><h2 id="线程类详解"><a href="#线程类详解" class="headerlink" title="线程类详解"></a>线程类详解</h2><h3 id="java-线程的启动。"><a href="#java-线程的启动。" class="headerlink" title="java 线程的启动。"></a>java 线程的启动。</h3><p>java 线程的启动是由内部的start0 这个native方法都是由 JVM 负责实现的</p>
<ul>
<li><p>java.lang.Thread</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is not invoked for the main method thread or "system"</span></span><br><span class="line"><span class="comment">     * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">     * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A zero status value corresponds to state "NEW".</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">     * so that it can be added to the group's list of threads</span></span><br><span class="line"><span class="comment">     * and the group's unstarted count can be decremented. */</span></span><br><span class="line">    group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="comment">// 调用下面的 native 方法。</span></span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">              it will be passed up the call stack */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Thread.c</p>
<p>  <a href="https://github.com/openjdk-mirror/jdk7u-jdk/blob/master/src/share/native/java/lang/Thread.c" target="_blank" rel="noopener">Thread 类的 JNI 接口</a></p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">   &#123;<span class="string">"start0"</span>,           <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_StartThread&#125;,</span><br><span class="line">   &#123;<span class="string">"stop0"</span>,            <span class="string">"("</span> OBJ <span class="string">")V"</span>, (<span class="keyword">void</span> *)&amp;JVM_StopThread&#125;,</span><br><span class="line">   &#123;<span class="string">"isAlive"</span>,          <span class="string">"()Z"</span>,        (<span class="keyword">void</span> *)&amp;JVM_IsThreadAlive&#125;,</span><br><span class="line">   &#123;<span class="string">"suspend0"</span>,         <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_SuspendThread&#125;,</span><br><span class="line">   &#123;<span class="string">"resume0"</span>,          <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_ResumeThread&#125;,</span><br><span class="line">   &#123;<span class="string">"setPriority0"</span>,     <span class="string">"(I)V"</span>,       (<span class="keyword">void</span> *)&amp;JVM_SetThreadPriority&#125;,</span><br><span class="line">   &#123;<span class="string">"yield"</span>,            <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_Yield&#125;,</span><br><span class="line">   &#123;<span class="string">"sleep"</span>,            <span class="string">"(J)V"</span>,       (<span class="keyword">void</span> *)&amp;JVM_Sleep&#125;,</span><br><span class="line">   &#123;<span class="string">"currentThread"</span>,    <span class="string">"()"</span> THD,     (<span class="keyword">void</span> *)&amp;JVM_CurrentThread&#125;,</span><br><span class="line">   &#123;<span class="string">"countStackFrames"</span>, <span class="string">"()I"</span>,        (<span class="keyword">void</span> *)&amp;JVM_CountStackFrames&#125;,</span><br><span class="line">   &#123;<span class="string">"interrupt0"</span>,       <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_Interrupt&#125;,</span><br><span class="line">   &#123;<span class="string">"isInterrupted"</span>,    <span class="string">"(Z)Z"</span>,       (<span class="keyword">void</span> *)&amp;JVM_IsInterrupted&#125;,</span><br><span class="line">   &#123;<span class="string">"holdsLock"</span>,        <span class="string">"("</span> OBJ <span class="string">")Z"</span>, (<span class="keyword">void</span> *)&amp;JVM_HoldsLock&#125;,</span><br><span class="line">   &#123;<span class="string">"getThreads"</span>,        <span class="string">"()["</span> THD,   (<span class="keyword">void</span> *)&amp;JVM_GetAllThreads&#125;,</span><br><span class="line">   &#123;<span class="string">"dumpThreads"</span>,      <span class="string">"(["</span> THD <span class="string">")[["</span> STE, (<span class="keyword">void</span> *)&amp;JVM_DumpThreads&#125;,</span><br><span class="line">   &#123;<span class="string">"setNativeName"</span>,    <span class="string">"("</span> STR <span class="string">")V"</span>, (<span class="keyword">void</span> *)&amp;JVM_SetNativeThreadName&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>jvm.cpp</p>
<p>  <a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/prims/jvm.cpp#L7" target="_blank" rel="noopener">jvm.cpp</a></p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_StartThread(JNIEnv* env, jobject jthread))</span><br><span class="line">	JVMWrapper(<span class="string">"JVM_StartThread"</span>);</span><br><span class="line">JavaThread *native_thread = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We cannot hold the Threads_lock when we throw an exception,</span></span><br><span class="line"><span class="comment">// due to rank ordering issues. Example:  we might need to grab the</span></span><br><span class="line"><span class="comment">// Heap_lock while we construct the exception.</span></span><br><span class="line"><span class="keyword">bool</span> throw_illegal_thread_state = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We must release the Threads_lock before we can post a jvmti event</span></span><br><span class="line"><span class="comment">// in Thread::start.</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Ensure that the C++ Thread and OSThread structures aren't freed before</span></span><br><span class="line"><span class="comment">// we operate.</span></span><br><span class="line"><span class="function">MutexLocker <span class="title">mu</span><span class="params">(Threads_lock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Since JDK 5 the java.lang.Thread threadStatus is used to prevent</span></span><br><span class="line"><span class="comment">// re-starting an already started thread, so we should usually find</span></span><br><span class="line"><span class="comment">// that the JavaThread is null. However for a JNI attached thread</span></span><br><span class="line"><span class="comment">// there is a small window between the Thread object being created</span></span><br><span class="line"><span class="comment">// (with its JavaThread set) and the update to its threadStatus, so we</span></span><br><span class="line"><span class="comment">// have to check for this</span></span><br><span class="line"><span class="keyword">if</span> (java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">  throw_illegal_thread_state = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// We could also check the stillborn flag to see if this thread was already stopped, but</span></span><br><span class="line">  <span class="comment">// for historical reasons we let the thread detect that itself when it starts running</span></span><br><span class="line"></span><br><span class="line">  jlong size =</span><br><span class="line">         java_lang_Thread::stackSize(JNIHandles::resolve_non_null(jthread));</span><br><span class="line">  <span class="comment">// Allocate the C++ Thread structure and create the native thread.  The</span></span><br><span class="line">  <span class="comment">// stack size retrieved from java is signed, but the constructor takes</span></span><br><span class="line">  <span class="comment">// size_t (an unsigned type), so avoid passing negative values which would</span></span><br><span class="line">  <span class="comment">// result in really large stacks.</span></span><br><span class="line">  <span class="keyword">size_t</span> sz = size &gt; <span class="number">0</span> ? (<span class="keyword">size_t</span>) size : <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// thread_entry 是一个获取线程入口点的函数（run）</span></span><br><span class="line">  native_thread = <span class="keyword">new</span> JavaThread(&amp;thread_entry, sz);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// At this point it may be possible that no osthread was created for the</span></span><br><span class="line">  <span class="comment">// JavaThread due to lack of memory. Check for this situation and throw</span></span><br><span class="line">  <span class="comment">// an exception if necessary. Eventually we may want to change this so</span></span><br><span class="line">  <span class="comment">// that we only grab the lock if the thread was created successfully -</span></span><br><span class="line">  <span class="comment">// then we can also do this check and throw the exception in the</span></span><br><span class="line">  <span class="comment">// JavaThread constructor.</span></span><br><span class="line">  <span class="keyword">if</span> (native_thread-&gt;osthread() != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// Note: the current thread is not being used within "prepare".</span></span><br><span class="line">    native_thread-&gt;prepare(jthread);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (throw_illegal_thread_state) &#123;</span><br><span class="line">THROW(vmSymbols::java_lang_IllegalThreadStateException());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assert(native_thread != <span class="literal">NULL</span>, <span class="string">"Starting null thread?"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (native_thread-&gt;osthread() == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">// No one should hold a reference to the 'native_thread'.</span></span><br><span class="line"><span class="keyword">delete</span> native_thread;</span><br><span class="line"><span class="keyword">if</span> (JvmtiExport::should_post_resource_exhausted()) &#123;</span><br><span class="line">  JvmtiExport::post_resource_exhausted(</span><br><span class="line">    JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR | JVMTI_RESOURCE_EXHAUSTED_THREADS,</span><br><span class="line">    <span class="string">"unable to create new native thread"</span>);</span><br><span class="line">&#125;</span><br><span class="line">THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(),</span><br><span class="line">          <span class="string">"unable to create new native thread"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread::start(native_thread);</span><br><span class="line"></span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thread_entry</span><span class="params">(JavaThread* thread, TRAPS)</span> </span>&#123;</span><br><span class="line"><span class="function">HandleMark <span class="title">hm</span><span class="params">(THREAD)</span></span>;</span><br><span class="line"><span class="function">Handle <span class="title">obj</span><span class="params">(THREAD, thread-&gt;threadObj()</span>)</span>;</span><br><span class="line"><span class="function">JavaValue <span class="title">result</span><span class="params">(T_VOID)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个调用应该就是 调用 Thread.run 方法。</span></span><br><span class="line">JavaCalls::call_virtual(&amp;result,</span><br><span class="line">                      obj,</span><br><span class="line">                      KlassHandle(THREAD, SystemDictionary::Thread_klass()),</span><br><span class="line">                      vmSymbols::run_method_name(),</span><br><span class="line">                      vmSymbols::void_method_signature(),</span><br><span class="line">                      THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

vmSymbols::run_method_name() 在其中 jdk7u-hotspot/src/share/vm/classfile/vmSymbols.hpp 文件中，其中就是 &quot;run&quot; 代表 java Thread 类中的 run 方法。

这份c++代码中使用到两个 c++ 类， JavaThread 和 Thread。
</code></pre><ul>
<li><p>JavaThread</p>
<p>  <a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/master/src/share/vm/runtime/thread.cpp" target="_blank" rel="noopener">JavaThread</a> 这个文件中定义的类有：</p>
<pre><code>// Class hierarchy
// - Thread
//   - NamedThread
//     - VMThread
//     - ConcurrentGCThread
//     - WorkerThread
//       - GangWorker
//       - GCTaskThread
//   - JavaThread
//   - WatcherThread
</code></pre><p>  其中 JavaThread 继承自 Thread 类。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Thread::start(Thread* thread) &#123;</span><br><span class="line">trace(<span class="string">"start"</span>, thread);</span><br><span class="line"><span class="comment">// Start is different from resume in that its safety is guaranteed by context or</span></span><br><span class="line"><span class="comment">// being called from a Java method synchronized on the Thread object.</span></span><br><span class="line"><span class="keyword">if</span> (!DisableStartThread) &#123;</span><br><span class="line"><span class="keyword">if</span> (thread-&gt;is_Java_thread()) &#123;</span><br><span class="line">  <span class="comment">// Initialize the thread state to RUNNABLE before starting this thread.</span></span><br><span class="line">  <span class="comment">// Can not set it after the thread started because we do not know the</span></span><br><span class="line">  <span class="comment">// exact thread state at that time. It could be in MONITOR_WAIT or</span></span><br><span class="line">  <span class="comment">// in SLEEPING or some other state.</span></span><br><span class="line">  java_lang_Thread::set_thread_status(((JavaThread*)thread)-&gt;threadObj(),</span><br><span class="line">                                      			java_lang_Thread::RUNNABLE);</span><br><span class="line">&#125;</span><br><span class="line">os::start_thread(thread);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>os::start_thread</p>
<p>  jdk7u-hotspot/src/share/vm/runtime/os.cpp</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> os::start_thread(Thread* thread) &#123;</span><br><span class="line"><span class="comment">// guard suspend/resume</span></span><br><span class="line"><span class="function">MutexLockerEx <span class="title">ml</span><span class="params">(thread-&gt;SR_lock(), Mutex::_no_safepoint_check_flag)</span></span>;</span><br><span class="line">OSThread* osthread = thread-&gt;osthread();</span><br><span class="line">osthread-&gt;set_state(RUNNABLE);</span><br><span class="line">pd_start_thread(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>pd_start_thread</p>
<p>  jdk7u-hotspot/src/os/windows/vm/os_windows.cpp</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> os::pd_start_thread(Thread* thread) &#123;</span><br><span class="line">	<span class="comment">// ResumeThread 是 win32 sdk 中提供的 API 用来唤醒线程。</span></span><br><span class="line">	DWORD ret = ResumeThread(thread-&gt;osthread()-&gt;thread_handle());</span><br><span class="line">	<span class="comment">// Returns previous suspend state:</span></span><br><span class="line">	<span class="comment">// 0:  Thread was not suspended</span></span><br><span class="line">	<span class="comment">// 1:  Thread is running now</span></span><br><span class="line">	<span class="comment">// &gt;1: Thread is still suspended.</span></span><br><span class="line">	<span class="keyword">assert</span>(ret != SYS_THREAD_ERROR, <span class="string">"StartThread failed"</span>); <span class="comment">// should propagate back</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>osthread 的创建</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">JavaThread::JavaThread(ThreadFunction entry_point, size_t stack_sz) :</span><br><span class="line">Thread()</span><br><span class="line">#ifndef SERIALGC</span><br><span class="line">, _satb_mark_queue(&amp;_satb_mark_queue_set),</span><br><span class="line">_dirty_card_queue(&amp;_dirty_card_queue_set)</span><br><span class="line">#endif // !SERIALGC</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (TraceThreadEvents) &#123;</span><br><span class="line">tty-&gt;print_cr(<span class="string">"creating thread %p"</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">initialize();</span><br><span class="line">_jni_attach_state = _not_attaching_via_jni;</span><br><span class="line">set_entry_point(entry_point);</span><br><span class="line"><span class="comment">// Create the native thread itself.</span></span><br><span class="line"><span class="comment">// %note runtime_23</span></span><br><span class="line">os::ThreadType thr_type = os::java_thread;</span><br><span class="line">thr_type = entry_point == &amp;compiler_thread_entry ? os::compiler_thread :</span><br><span class="line">                                                 os::java_thread;</span><br><span class="line">os::create_thread(<span class="keyword">this</span>, thr_type, stack_sz);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The _osthread may be NULL here because we ran out of memory (too many threads active).</span></span><br><span class="line"><span class="comment">// We need to throw and OutOfMemoryError - however we cannot do this here because the caller</span></span><br><span class="line"><span class="comment">// may hold a lock and all locks must be unlocked before throwing the exception (throwing</span></span><br><span class="line"><span class="comment">// the exception consists of creating the exception object &amp; initializing it, initialization</span></span><br><span class="line"><span class="comment">// will leave the VM via a JavaCall and then all locks must be unlocked).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The thread is still suspended when we reach here. Thread must be explicit started</span></span><br><span class="line"><span class="comment">// by creator! Furthermore, the thread must also explicitly be added to the Threads list</span></span><br><span class="line"><span class="comment">// by calling Threads:add. The reason why this is not done here, is because the thread</span></span><br><span class="line"><span class="comment">// object must be fully initialized (take a look at JVM_Start)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>其中使用到了  os::create_thread 来创建线程。
</code></pre><ul>
<li><p>os::create_thread</p>
<p>  jdk7u-hotspot/src/os/windows/vm/os_windows.cpp</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">bool os::create_thread(Thread* thread, ThreadType thr_type, size_t stack_size) &#123;</span><br><span class="line">unsigned thread_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate the OSThread object</span></span><br><span class="line">OSThread* osthread = <span class="keyword">new</span> OSThread(NULL, NULL);</span><br><span class="line"><span class="keyword">if</span> (osthread == NULL) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize support for Java interrupts</span></span><br><span class="line">HANDLE interrupt_event = CreateEvent(NULL, <span class="keyword">true</span>, <span class="keyword">false</span>, NULL);</span><br><span class="line"><span class="keyword">if</span> (interrupt_event == NULL) &#123;</span><br><span class="line">delete osthread;</span><br><span class="line"><span class="keyword">return</span> NULL;</span><br><span class="line">&#125;</span><br><span class="line">osthread-&gt;set_interrupt_event(interrupt_event);</span><br><span class="line">osthread-&gt;set_interrupted(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">thread-&gt;set_osthread(osthread);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (stack_size == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">switch</span> (thr_type) &#123;</span><br><span class="line"><span class="keyword">case</span> os::java_thread:</span><br><span class="line">  <span class="comment">// Java threads use ThreadStackSize which default value can be changed with the flag -Xss</span></span><br><span class="line">  <span class="keyword">if</span> (JavaThread::stack_size_at_create() &gt; <span class="number">0</span>)</span><br><span class="line">    stack_size = JavaThread::stack_size_at_create();</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> os::compiler_thread:</span><br><span class="line">  <span class="keyword">if</span> (CompilerThreadStackSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    stack_size = (size_t)(CompilerThreadStackSize * K);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125; <span class="comment">// else fall through:</span></span><br><span class="line">    <span class="comment">// use VMThreadStackSize if CompilerThreadStackSize is not defined</span></span><br><span class="line"><span class="keyword">case</span> os::vm_thread:</span><br><span class="line"><span class="keyword">case</span> os::pgc_thread:</span><br><span class="line"><span class="keyword">case</span> os::cgc_thread:</span><br><span class="line"><span class="keyword">case</span> os::watcher_thread:</span><br><span class="line">  <span class="keyword">if</span> (VMThreadStackSize &gt; <span class="number">0</span>) stack_size = (size_t)(VMThreadStackSize * K);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the Win32 thread</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Contrary to what MSDN document says, "stack_size" in _beginthreadex()</span></span><br><span class="line"><span class="comment">// does not specify stack size. Instead, it specifies the size of</span></span><br><span class="line"><span class="comment">// initially committed space. The stack size is determined by</span></span><br><span class="line"><span class="comment">// PE header in the executable. If the committed "stack_size" is larger</span></span><br><span class="line"><span class="comment">// than default value in the PE header, the stack is rounded up to the</span></span><br><span class="line"><span class="comment">// nearest multiple of 1MB. For example if the launcher has default</span></span><br><span class="line"><span class="comment">// stack size of 320k, specifying any size less than 320k does not</span></span><br><span class="line"><span class="comment">// affect the actual stack size at all, it only affects the initial</span></span><br><span class="line"><span class="comment">// commitment. On the other hand, specifying 'stack_size' larger than</span></span><br><span class="line"><span class="comment">// default value may cause significant increase in memory usage, because</span></span><br><span class="line"><span class="comment">// not only the stack space will be rounded up to MB, but also the</span></span><br><span class="line"><span class="comment">// entire space is committed upfront.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Finally Windows XP added a new flag 'STACK_SIZE_PARAM_IS_A_RESERVATION'</span></span><br><span class="line"><span class="comment">// for CreateThread() that can treat 'stack_size' as stack size. However we</span></span><br><span class="line"><span class="comment">// are not supposed to call CreateThread() directly according to MSDN</span></span><br><span class="line"><span class="comment">// document because JVM uses C runtime library. The good news is that the</span></span><br><span class="line"><span class="comment">// flag appears to work with _beginthredex() as well.</span></span><br><span class="line"></span><br><span class="line">#ifndef STACK_SIZE_PARAM_IS_A_RESERVATION</span><br><span class="line">#define STACK_SIZE_PARAM_IS_A_RESERVATION  (0x10000)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">HANDLE thread_handle =</span><br><span class="line">(HANDLE)_beginthreadex(NULL,</span><br><span class="line">                       (unsigned)stack_size,</span><br><span class="line">                       (unsigned (__stdcall *)(<span class="keyword">void</span>*)) java_start,</span><br><span class="line">                       thread,</span><br><span class="line">                       CREATE_SUSPENDED | STACK_SIZE_PARAM_IS_A_RESERVATION,</span><br><span class="line">                       &amp;thread_id);</span><br><span class="line"><span class="keyword">if</span> (thread_handle == NULL) &#123;</span><br><span class="line"><span class="comment">// perhaps STACK_SIZE_PARAM_IS_A_RESERVATION is not supported, try again</span></span><br><span class="line"><span class="comment">// without the flag.</span></span><br><span class="line">thread_handle =</span><br><span class="line">(HANDLE)_beginthreadex(NULL,</span><br><span class="line">                       (unsigned)stack_size,</span><br><span class="line">                       (unsigned (__stdcall *)(<span class="keyword">void</span>*)) java_start,</span><br><span class="line">                       thread,</span><br><span class="line">                       CREATE_SUSPENDED,</span><br><span class="line">                       &amp;thread_id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (thread_handle == NULL) &#123;</span><br><span class="line"><span class="comment">// Need to clean up stuff we've allocated so far</span></span><br><span class="line">CloseHandle(osthread-&gt;interrupt_event());</span><br><span class="line">thread-&gt;set_osthread(NULL);</span><br><span class="line">delete osthread;</span><br><span class="line"><span class="keyword">return</span> NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Atomic::inc_ptr((intptr_t*)&amp;os::win32::_os_thread_count);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Store info on the Win32 thread into the OSThread</span></span><br><span class="line">osthread-&gt;set_thread_handle(thread_handle);</span><br><span class="line">osthread-&gt;set_thread_id(thread_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initial thread state is INITIALIZED, not SUSPENDED</span></span><br><span class="line">osthread-&gt;set_state(INITIALIZED);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The thread is returned suspended (in state INITIALIZED), and is started higher up in the call chain</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>其中使用到了 _beginthreadex 来创建 windows 线程。这个函数的使用可以参考：[_beginthreadex](https://msdn.microsoft.com/zh-cn/library/kdzttdcb.aspx)

_beginthreadex 的第5个参数 initflag ： Set initflag to 0 to run immediately, or to CREATE_SUSPENDED to create the thread in a suspended state; use ResumeThread to execute the thread.

第三个参数 start_address：表示 Start address of a routine that begins execution of a new thread. 在这里是 java_start 函数。

第四个参数 arglist： 表示 Argument list to be passed to a new thread, or NULL. 就是 java_start 函数的参数，也就就是当前线程对象thread.

这里使用的是 CREATE_SUSPENDED， 所以需要调用 ResumeThread 来，唤醒线程。

关于 OSThread 类：jdk7u-hotspot/src/share/vm/runtime/osThread.cpp。
</code></pre><ul>
<li><p>java_start</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> unsigned __stdcall <span class="title">java_start</span><span class="params">(Thread* thread)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Try to randomize the cache line index of hot stack frames.</span></span><br><span class="line">	<span class="comment">// This helps when threads of the same stack traces evict each other's</span></span><br><span class="line">	<span class="comment">// cache lines. The threads can be either from the same JVM instance, or</span></span><br><span class="line">	<span class="comment">// from different JVM instances. The benefit is especially true for</span></span><br><span class="line">	<span class="comment">// processors with hyperthreading technology.</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> pid = os::current_process_id();</span><br><span class="line">	_alloca(((pid ^ counter++) &amp; <span class="number">7</span>) * <span class="number">128</span>);</span><br><span class="line">	</span><br><span class="line">	OSThread* osthr = thread-&gt;osthread();</span><br><span class="line">	<span class="keyword">assert</span>(osthr-&gt;get_state() == RUNNABLE, <span class="string">"invalid os thread state"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (UseNUMA) &#123;</span><br><span class="line">	<span class="keyword">int</span> lgrp_id = os::numa_get_group_id();</span><br><span class="line">	<span class="keyword">if</span> (lgrp_id != -<span class="number">1</span>) &#123;</span><br><span class="line">	  thread-&gt;set_lgrp_id(lgrp_id);</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (UseVectoredExceptions) &#123;</span><br><span class="line">	<span class="comment">// If we are using vectored exception we don't need to set a SEH</span></span><br><span class="line">	thread-&gt;run();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// Install a win32 structured exception handler around every thread created</span></span><br><span class="line">	<span class="comment">// by VM, so VM can genrate error dump when an exception occurred in non-</span></span><br><span class="line">	<span class="comment">// Java thread (e.g. VM thread).</span></span><br><span class="line">	__try &#123;</span><br><span class="line">	   thread-&gt;run();</span><br><span class="line">	&#125; __except(topLevelExceptionFilter(</span><br><span class="line">	           (_EXCEPTION_POINTERS*)_exception_info())) &#123;</span><br><span class="line">	    <span class="comment">// Nothing to do.</span></span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// One less thread is executing</span></span><br><span class="line">	<span class="comment">// When the VMThread gets here, the main thread may have already exited</span></span><br><span class="line">	<span class="comment">// which frees the CodeHeap containing the Atomic::add code</span></span><br><span class="line">	<span class="keyword">if</span> (thread != VMThread::vm_thread() &amp;&amp; VMThread::vm_thread() != NULL) &#123;</span><br><span class="line">	Atomic::dec_ptr((intptr_t*)&amp;os::win32::_os_thread_count);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  创建线程时使用 java_start 是线程的入口函数定义在 os_windows.cpp 中，其最终使用<br>  thread-&gt;run() 来调用 run 方法。 而这里的 thread 就是前面创建的 JavaThread，所以这这里调用的是 JavaThread::run 方法</p>
</li>
<li><p>JavaThread::run</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// The first routine called by a new Java thread</span></span><br><span class="line">	<span class="keyword">void</span> JavaThread::run() &#123;</span><br><span class="line">  <span class="comment">// initialize thread-local alloc buffer related fields</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;initialize_tlab();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// used to test validitity of stack trace backs</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;record_base_of_stack_pointer();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record real stack base and size.</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;record_stack_base_and_size();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize thread local storage; set before calling MutexLocker</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;initialize_thread_local_storage();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;create_stack_guard_pages();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;cache_global_variables();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Thread is now sufficient initialized to be handled by the safepoint code as being</span></span><br><span class="line">  <span class="comment">// in the VM. Change thread state from _thread_new to _thread_in_vm</span></span><br><span class="line">  ThreadStateTransition::transition_and_fence(<span class="keyword">this</span>, _thread_new, _thread_in_vm);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">assert</span>(JavaThread::current() == <span class="keyword">this</span>, <span class="string">"sanity check"</span>);</span><br><span class="line">  <span class="keyword">assert</span>(!Thread::current()-&gt;owns_locks(), <span class="string">"sanity check"</span>);</span><br><span class="line"></span><br><span class="line">  DTRACE_THREAD_PROBE(start, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This operation might block. We call that after all safepoint checks for a new thread has</span></span><br><span class="line">  <span class="comment">// been completed.</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;set_active_handles(JNIHandleBlock::allocate_block());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (JvmtiExport::should_post_thread_life()) &#123;</span><br><span class="line">    JvmtiExport::post_thread_start(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We call another function to do the rest so we are sure that the stack addresses used</span></span><br><span class="line">  <span class="comment">// from there will be lower than the stack base just computed</span></span><br><span class="line">  thread_main_inner();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Note, thread is no longer valid at this point!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> JavaThread::thread_main_inner() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(JavaThread::current() == <span class="keyword">this</span>, <span class="string">"sanity check"</span>);</span><br><span class="line">  <span class="keyword">assert</span>(<span class="keyword">this</span>-&gt;threadObj() != NULL, <span class="string">"just checking"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Execute thread entry point unless this thread has a pending exception</span></span><br><span class="line">  <span class="comment">// or has been stopped before starting.</span></span><br><span class="line">  <span class="comment">// Note: Due to JVM_StopThread we can have pending exceptions already!</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;has_pending_exception() &amp;&amp;</span><br><span class="line">      !java_lang_Thread::is_stillborn(<span class="keyword">this</span>-&gt;threadObj())) &#123;</span><br><span class="line">    <span class="function">HandleMark <span class="title">hm</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;entry_point()(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  DTRACE_THREAD_PROBE(stop, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;exit(<span class="keyword">false</span>);</span><br><span class="line">  delete <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  JavaThread::run 内部调用 JavaThread::thread_main_inner，然后，<br>   this-&gt;entry_point()(this, this);</p>
<p>  所以，最终上面的 thread_entry 函数的第一个参数将是 JavaThread 这个对象自身。</p>
<p>  注意这里的 this-&gt;exit(false); 调用非常重要。这个调用是 JavaThread::exit 方法，在这个方法中调用了一个全局静态函数 ensure_join ，</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ensure_join</span><span class="params">(JavaThread* thread)</span> </span>&#123;</span><br><span class="line"><span class="comment">// We do not need to grap the Threads_lock, since we are operating on ourself.</span></span><br><span class="line"><span class="function">Handle <span class="title">threadObj</span><span class="params">(thread, thread-&gt;threadObj()</span>)</span>;</span><br><span class="line"><span class="keyword">assert</span>(threadObj.not_null(), <span class="string">"java thread object must exist"</span>);</span><br><span class="line"><span class="function">ObjectLocker <span class="title">lock</span><span class="params">(threadObj, thread)</span></span>;</span><br><span class="line"><span class="comment">// Ignore pending exception (ThreadDeath), since we are exiting anyway</span></span><br><span class="line">thread-&gt;clear_pending_exception();</span><br><span class="line"><span class="comment">// Thread is exiting. So set thread_status field in  java.lang.Thread class to TERMINATED.</span></span><br><span class="line">java_lang_Thread::set_thread_status(threadObj(), java_lang_Thread::TERMINATED);</span><br><span class="line"><span class="comment">// Clear the native thread instance - this makes isAlive return false and allows the join()</span></span><br><span class="line"><span class="comment">// to complete once we've done the notify_all below</span></span><br><span class="line">java_lang_Thread::set_thread(threadObj(), NULL);</span><br><span class="line">lock.notify_all(thread);</span><br><span class="line"><span class="comment">// Ignore pending exception (ThreadDeath), since we are exiting anyway</span></span><br><span class="line">thread-&gt;clear_pending_exception();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>注意 lock.notify_all 调用的注释， allows the join() to complete once we&apos;ve done the notify_all below。 java.lang.Thread.join 函数就是在这个调用下被 notify, 所以才会被唤醒。
</code></pre><ul>
<li><p>JavaThread::entry_point</p>
<p>  这个函数在类 JavaThread 的声明中定义的</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">typedef <span class="title">void</span> <span class="params">(*ThreadFunction)</span><span class="params">(JavaThread*, TRAPS)</span></span>;</span><br><span class="line">ThreadFunction _entry_point;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set_entry_point</span><span class="params">(ThreadFunction entry_point)</span> </span>&#123; _entry_point = entry_point; &#125;</span><br><span class="line"><span class="function">ThreadFunction <span class="title">entry_point</span><span class="params">()</span> <span class="keyword">const</span>             </span>&#123; <span class="keyword">return</span> _entry_point; &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>java_lang_Thread: jdk7u-hotspot/src/share/vm/classfile/javaClasses.cpp</p>
<h2 id="java-lang-Thread-isAlive"><a href="#java-lang-Thread-isAlive" class="headerlink" title="java.lang.Thread.isAlive"></a>java.lang.Thread.isAlive</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk7u-hotspot/src/share/vm/prims/jvm.cpp</span></span><br><span class="line">JVM_ENTRY(jboolean, JVM_IsThreadAlive(JNIEnv* env, jobject jthread))</span><br><span class="line">  JVMWrapper(<span class="string">"JVM_IsThreadAlive"</span>);</span><br><span class="line"></span><br><span class="line">  oop thread_oop = JNIHandles::resolve_non_null(jthread);</span><br><span class="line">  <span class="keyword">return</span> java_lang_Thread::is_alive(thread_oop);</span><br><span class="line">JVM_END</span><br><span class="line"></span><br><span class="line"><span class="comment">// jdk7u-hotspot/src/share/vm/classfile/javaClasses.cpp</span></span><br><span class="line"><span class="keyword">bool</span> java_lang_Thread::is_alive(oop java_thread) &#123;</span><br><span class="line">  <span class="comment">// 当一个线程退出的时候，会将 thr 设置成 NULL</span></span><br><span class="line">  JavaThread* thr = java_lang_Thread::thread(java_thread);</span><br><span class="line">  <span class="keyword">return</span> (thr != <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JavaThread-和-OSThread"><a href="#JavaThread-和-OSThread" class="headerlink" title="JavaThread 和 OSThread"></a>JavaThread 和 OSThread</h3><p>JavaThread jni 对 java 线程的抽象。</p>
<p>OSThread 是 对不同平台的线程抽象。</p>
<p><a href="jdk7u-hotspot/src/share/vm/runtime/osThread.cpp">osThread.cpp</a></p>
<p><a href="jdk7u-hotspot/src/os/windows/vm/osThread_windows.hpp">osThread_windows.hpp</a></p>
<h2 id="java-线程启动的启动过程"><a href="#java-线程启动的启动过程" class="headerlink" title="java 线程启动的启动过程"></a>java 线程启动的启动过程</h2><h3 id="启动过程中涉及的组件"><a href="#启动过程中涉及的组件" class="headerlink" title="启动过程中涉及的组件"></a>启动过程中涉及的组件</h3><ul>
<li><p>java.lang.Thread</p>
<p>  线程启动函数 start 方法中，调用start0, 由 java 代码转入 JNI 层</p>
</li>
<li><p>JNI</p>
<p>  在 JNI 中将该方法实现为 JVM_StartThread，可见 start0 由 JVM 来实现</p>
</li>
<li><p>JVM</p>
<p>  调用 JVM_StartThread，创建一个 JavaThread 对象。创建好 JavaThread对象 native_thread 之后 ，调用 JavaThread::prepare 方法。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JavaThread::prepare(jobject jni_thread, ThreadPriority prio) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(Threads_lock-&gt;owner() == Thread::current(), <span class="string">"must have threads lock"</span>);</span><br><span class="line"><span class="comment">// Link Java Thread object &lt;-&gt; C++ Thread</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the C++ thread object (an oop) from the JNI handle (a jthread)</span></span><br><span class="line"><span class="comment">// and put it into a new Handle.  The Handle "thread_oop" can then</span></span><br><span class="line"><span class="comment">// be used to pass the C++ thread object to other methods.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the Java level thread object (jthread) field of the</span></span><br><span class="line"><span class="comment">// new thread (a JavaThread *) to C++ thread object using the</span></span><br><span class="line"><span class="comment">// "thread_oop" handle.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the thread field (a JavaThread *) of the</span></span><br><span class="line"><span class="comment">// oop representing the java_lang_Thread to the new thread (a JavaThread *).</span></span><br><span class="line"></span><br><span class="line"><span class="function">Handle <span class="title">thread_oop</span><span class="params">(Thread::current()</span>,</span></span><br><span class="line"><span class="function">                JNIHandles::<span class="title">resolve_non_null</span><span class="params">(jni_thread)</span>)</span>;</span><br><span class="line"><span class="keyword">assert</span>(instanceKlass::cast(thread_oop-&gt;klass())-&gt;is_linked(),</span><br><span class="line"><span class="string">"must be initialized"</span>);</span><br><span class="line">set_threadObj(thread_oop());</span><br><span class="line">java_lang_Thread::set_thread(thread_oop(), <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (prio == NoPriority) &#123;</span><br><span class="line">prio = java_lang_Thread::priority(thread_oop());</span><br><span class="line"><span class="keyword">assert</span>(prio != NoPriority, <span class="string">"A valid priority should be present"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Push the Java priority down to the native thread; needs Threads_lock</span></span><br><span class="line">Thread::set_priority(<span class="keyword">this</span>, prio);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add the new thread to the Threads list and set it in motion.</span></span><br><span class="line"><span class="comment">// We must have threads lock in order to call Threads::add.</span></span><br><span class="line"><span class="comment">// It is crucial that we do not block before the thread is</span></span><br><span class="line"><span class="comment">// added to the Threads list for if a GC happens, then the java_thread oop</span></span><br><span class="line"><span class="comment">// will not be visited by GC.</span></span><br><span class="line">Threads::add(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>这个方法的主要作用就是：Link Java Thread object &lt;-&gt; C++ Thread

jni_thread 代表的就是，`new Thread()` 后产生的 Java Thread object.
这个参数由 JNI 调用 JVM_StartThread    时的第二个参数。

然后在 prepare 函数中 
`Handle thread_oop(Thread::current(), JNIHandles::resolve_non_null(jni_thread));`
创建一个 thread_oop，通过 set_threadObj(thread_oop()); 调用将
其和 native_thread 关联了起来。

这样 native_thread 内部持有 jni_thread, 所有在后续的线程启动过程中，才可以使用 jni_thread 来更新其 状态信息，例如：threadStatus 字段。

同时在创建 JavaThread的 调用了  os::create_thread 这是给不同平台预留的创建线程的接口：在 windows 平台上使用 os_windows.cpp 中定义的  os::create_thread 方法，其中使用 win32 平台提供的 _beginthreadex 来创建一个线程，创建的线程默认是未启动状态。关键代码：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">OSThread* osthread = <span class="keyword">new</span> OSThread(NULL, NULL);</span><br><span class="line">thread-&gt;set_osthread(osthread);</span><br><span class="line"></span><br><span class="line">HANDLE thread_handle =</span><br><span class="line">(HANDLE)_beginthreadex(NULL,</span><br><span class="line">                       (unsigned)stack_size,</span><br><span class="line">                       (unsigned (__stdcall *)(<span class="keyword">void</span>*)) java_start,</span><br><span class="line">                       thread,</span><br><span class="line">                       CREATE_SUSPENDED | STACK_SIZE_PARAM_IS_A_RESERVATION,</span><br><span class="line">                       &amp;thread_id);</span><br><span class="line"></span><br><span class="line">osthread-&gt;set_thread_handle(thread_handle);</span><br><span class="line">osthread-&gt;set_thread_id(thread_id);</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>JVM Thread 共享层</p>
<p>  这一层，其实就是 Thread 和 JavaThread 类，上面的启动过程，最后调用<br>  Thread::start(native_thread); 从而转入这一层，这一层对不同平台的线程启动过程进行了封装处理。进行一些公共的初始化操作。之后 调用 os::start_thread 启动线程。</p>
</li>
<li><p>不同平台底层启动中</p>
<p>  在 windows 平台中启动线程。使用 os_windows.cpp 定义的 os::start_thread 开始唤醒线程并执行。</p>
</li>
</ul>
<h2 id="JVM-如果处理线程出现的异常"><a href="#JVM-如果处理线程出现的异常" class="headerlink" title="JVM 如果处理线程出现的异常"></a>JVM 如果处理线程出现的异常</h2><h3 id="Thread-UncaughtExceptionHandler"><a href="#Thread-UncaughtExceptionHandler" class="headerlink" title="Thread.UncaughtExceptionHandler"></a>Thread.UncaughtExceptionHandler</h3><blockquote>
<p>Interface for handlers invoked when a Thread abruptly terminates due to an uncaught exception. </p>
<p>When a thread is about to terminate due to an uncaught exception the Java Virtual Machine will query the thread for its UncaughtExceptionHandler using Thread.getUncaughtExceptionHandler() and will invoke the handler’s uncaughtException method, passing the thread and the exception as arguments. If a thread has not had its UncaughtExceptionHandler explicitly set, then its ThreadGroup object acts as its UncaughtExceptionHandler. If the ThreadGroup object has no special requirements for dealing with the exception, it can forward the invocation to the default uncaught exception handler.</p>
</blockquote>
<p>所以对于一个 uncaught exception 的异常，线程的处理过程是：</p>
<ul>
<li><p>getUncaughtExceptionHandler()</p>
<p>  获得线程的 uncaughtExceptionHandler，然后调用其 uncaughtException 方法</p>
</li>
<li><p>getThreadGroup</p>
<p>  获得线程组，调用其 uncaughtException 方法</p>
</li>
<li><p>getDefaultUncaughtExceptionHandler</p>
<p>  获得默认的 UncaughtExceptionHandler，调用其 uncaughtException 方法</p>
</li>
</ul>
<p>这个调用过程是由 JavaThread::exit 完成的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaThread::exit 实现片断</span></span><br><span class="line"><span class="comment">// JSR-166: change call from from ThreadGroup.uncaughtException to</span></span><br><span class="line"><span class="comment">// java.lang.Thread.dispatchUncaughtException</span></span><br><span class="line"><span class="keyword">if</span> (uncaught_exception.not_null()) &#123;</span><br><span class="line">  <span class="function">Handle <span class="title">group</span><span class="params">(<span class="keyword">this</span>, java_lang_Thread::threadGroup(threadObj()</span>))</span>;</span><br><span class="line">  Events::log(<span class="string">"uncaught exception INTPTR_FORMAT "</span> <span class="string">" INTPTR_FORMAT "</span> <span class="string">" INTPTR_FORMAT"</span>,</span><br><span class="line">    (address)uncaught_exception(), (address)threadObj(), (address)group());</span><br><span class="line">  &#123;</span><br><span class="line">    EXCEPTION_MARK;</span><br><span class="line">    <span class="comment">// Check if the method Thread.dispatchUncaughtException() exists. If so</span></span><br><span class="line">    <span class="comment">// call it.  Otherwise we have an older library without the JSR-166 changes,</span></span><br><span class="line">    <span class="comment">// so call ThreadGroup.uncaughtException()</span></span><br><span class="line">    <span class="function">KlassHandle <span class="title">recvrKlass</span><span class="params">(THREAD, threadObj-&gt;klass()</span>)</span>;</span><br><span class="line">    CallInfo callinfo;</span><br><span class="line">    <span class="function">KlassHandle <span class="title">thread_klass</span><span class="params">(THREAD, SystemDictionary::Thread_klass()</span>)</span>;</span><br><span class="line">    LinkResolver::resolve_virtual_call(callinfo, threadObj, recvrKlass, thread_klass,</span><br><span class="line">                                       vmSymbols::dispatchUncaughtException_name(),</span><br><span class="line">                                       vmSymbols::throwable_void_signature(),</span><br><span class="line">                                       KlassHandle(), <span class="keyword">false</span>, <span class="keyword">false</span>, THREAD);</span><br><span class="line">    CLEAR_PENDING_EXCEPTION;</span><br><span class="line">    methodHandle method = callinfo.selected_method();</span><br><span class="line">    <span class="keyword">if</span> (method.not_null()) &#123;</span><br><span class="line">      <span class="function">JavaValue <span class="title">result</span><span class="params">(T_VOID)</span></span>;</span><br><span class="line">	<span class="comment">// vmSymbols::dispatchUncaughtException_name </span></span><br><span class="line">	<span class="comment">// 对应的就是 Thread.dispatchUncaughtException 这个方法</span></span><br><span class="line">	<span class="comment">// 就是用来处理异常分发。</span></span><br><span class="line">      JavaCalls::call_virtual(&amp;result,</span><br><span class="line">                              threadObj, thread_klass,</span><br><span class="line">                              vmSymbols::dispatchUncaughtException_name(),</span><br><span class="line">                              vmSymbols::throwable_void_signature(),</span><br><span class="line">                              uncaught_exception,</span><br><span class="line">                              THREAD);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	  <span class="comment">// vmSymbols::uncaughtException_name() 对应 uncaughtException</span></span><br><span class="line">	  <span class="comment">// 也就是调用 线程组的 uncaughtException 方法。</span></span><br><span class="line">      <span class="function">KlassHandle <span class="title">thread_group</span><span class="params">(THREAD, SystemDictionary::ThreadGroup_klass()</span>)</span>;</span><br><span class="line">      <span class="function">JavaValue <span class="title">result</span><span class="params">(T_VOID)</span></span>;</span><br><span class="line">      JavaCalls::call_virtual(&amp;result,</span><br><span class="line">                              group, thread_group,</span><br><span class="line">                              vmSymbols::uncaughtException_name(),</span><br><span class="line">                              vmSymbols::thread_throwable_void_signature(),</span><br><span class="line">                              threadObj,           <span class="comment">// Arg 1</span></span><br><span class="line">                              uncaught_exception,  <span class="comment">// Arg 2</span></span><br><span class="line">                              THREAD);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (HAS_PENDING_EXCEPTION) &#123;</span><br><span class="line">      <span class="function">ResourceMark <span class="title">rm</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">      jio_fprintf(defaultStream::error_stream(),</span><br><span class="line">            <span class="string">"\nException: %s thrown from the UncaughtExceptionHandler"</span></span><br><span class="line">            <span class="string">" in thread \"%s\"\n"</span>,</span><br><span class="line">            Klass::cast(pending_exception()-&gt;klass())-&gt;external_name(),</span><br><span class="line">            get_thread_name());</span><br><span class="line">      CLEAR_PENDING_EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果线程遇到异常，则 JVM 在 JavaThread::exit 方法将调用 java.lang.Thread.dispatchUncaughtException 方法。这个方法的作用就是进行异常的分发。其分发过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dispatch an uncaught exception to the handler. This method is</span></span><br><span class="line"><span class="comment"> * intended to be called only by the JVM.</span></span><br><span class="line"><span class="comment"> * 这个方法将被 JVM 的 JavaThread:exit 方法调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchUncaughtException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">    getUncaughtExceptionHandler().uncaughtException(<span class="keyword">this</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> UncaughtExceptionHandler <span class="title">getUncaughtExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uncaughtExceptionHandler != <span class="keyword">null</span> ?</span><br><span class="line">        uncaughtExceptionHandler : group;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        parent.uncaughtException(t, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Thread.UncaughtExceptionHandler ueh =</span><br><span class="line">            Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">        <span class="keyword">if</span> (ueh != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ueh.uncaughtException(t, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> ThreadDeath)) &#123;</span><br><span class="line">            System.err.print(<span class="string">"Exception in thread \""</span></span><br><span class="line">                             + t.getName() + <span class="string">"\" "</span>);</span><br><span class="line">            e.printStackTrace(System.err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Java并发相关面试题"><a href="#Java并发相关面试题" class="headerlink" title="Java并发相关面试题"></a>Java并发相关面试题</h2><p><a href="http://jeffzzf.github.io/2015/07/04/Java%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" target="_blank" rel="noopener">Java并发面试题整理</a></p>
<p><a href="http://ifeve.com/java-multi-threading-concurrency-interview-questions-with-answers/" target="_blank" rel="noopener">JAVA多线程和并发基础面试问答</a></p>
<p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/jniTOC.html,JNI规范" target="_blank" rel="noopener">Java Native Interface Specification Contents</a></p>
<p><a href="http://linlinjava.org/2015/04/01/learning-jni.html" target="_blank" rel="noopener">官方JNI规范[翻译]</a></p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2016/08/23/Unsafe类/">Unsafe类</a><a class="next" href="/2016/08/22/IO/">IO</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/interface/" style="font-size: 15px;">interface</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/Collections/" style="font-size: 15px;">Collections</a> <a href="/tags/Collection/" style="font-size: 15px;">Collection</a> <a href="/tags/J-U-C/" style="font-size: 15px;">J.U.C</a> <a href="/tags/lock/" style="font-size: 15px;">lock</a> <a href="/tags/Semaphore/" style="font-size: 15px;">Semaphore</a> <a href="/tags/CyclicBarrier/" style="font-size: 15px;">CyclicBarrier</a> <a href="/tags/CountDownLatch/" style="font-size: 15px;">CountDownLatch</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/LinkedList/" style="font-size: 15px;">LinkedList</a> <a href="/tags/Queue/" style="font-size: 15px;">Queue</a> <a href="/tags/Set/" style="font-size: 15px;">Set</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/collection/" style="font-size: 15px;">collection</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/api/" style="font-size: 15px;">api</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/mvc/" style="font-size: 15px;">mvc</a> <a href="/tags/context/" style="font-size: 15px;">context</a> <a href="/tags/component-scan/" style="font-size: 15px;">component-scan</a> <a href="/tags/storm/" style="font-size: 15px;">storm</a> <a href="/tags/windows/" style="font-size: 15px;">windows</a> <a href="/tags/命令行/" style="font-size: 15px;">命令行</a> <a href="/tags/cmder/" style="font-size: 15px;">cmder</a> <a href="/tags/win/" style="font-size: 15px;">win</a> <a href="/tags/效率/" style="font-size: 15px;">效率</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/博客/" style="font-size: 15px;">博客</a> <a href="/tags/apache/" style="font-size: 15px;">apache</a> <a href="/tags/extends/" style="font-size: 15px;">extends</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/svn/" style="font-size: 15px;">svn</a> <a href="/tags/BlockingQueue/" style="font-size: 15px;">BlockingQueue</a> <a href="/tags/LinkedBlockingQueue/" style="font-size: 15px;">LinkedBlockingQueue</a> <a href="/tags/PriorityBlockingQueue/" style="font-size: 15px;">PriorityBlockingQueue</a> <a href="/tags/ConcurrentLinkedQueue/" style="font-size: 15px;">ConcurrentLinkedQueue</a> <a href="/tags/CopyOnWriteArrayList/" style="font-size: 15px;">CopyOnWriteArrayList</a> <a href="/tags/接口/" style="font-size: 15px;">接口</a> <a href="/tags/抽象类/" style="font-size: 15px;">抽象类</a> <a href="/tags/Executor/" style="font-size: 15px;">Executor</a> <a href="/tags/ExecutorService/" style="font-size: 15px;">ExecutorService</a> <a href="/tags/CompletionService/" style="font-size: 15px;">CompletionService</a> <a href="/tags/ThreadPoolExecutor/" style="font-size: 15px;">ThreadPoolExecutor</a> <a href="/tags/vim/" style="font-size: 15px;">vim</a> <a href="/tags/vundle/" style="font-size: 15px;">vundle</a> <a href="/tags/ArrayList/" style="font-size: 15px;">ArrayList</a> <a href="/tags/log/" style="font-size: 15px;">log</a> <a href="/tags/index/" style="font-size: 15px;">index</a> <a href="/tags/concepts/" style="font-size: 15px;">concepts</a> <a href="/tags/Timer/" style="font-size: 15px;">Timer</a> <a href="/tags/TimerTask/" style="font-size: 15px;">TimerTask</a> <a href="/tags/ConcurrentMap/" style="font-size: 15px;">ConcurrentMap</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 15px;">ConcurrentHashMap</a> <a href="/tags/HashMap/" style="font-size: 15px;">HashMap</a> <a href="/tags/ReentrantReadWriteLock/" style="font-size: 15px;">ReentrantReadWriteLock</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/SynchronousQueue/" style="font-size: 15px;">SynchronousQueue</a> <a href="/tags/ScheduledExecutorService/" style="font-size: 15px;">ScheduledExecutorService</a> <a href="/tags/AQS/" style="font-size: 15px;">AQS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/BigData-docker/">Windows 上安装 docker</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/mysql-0.路线/">Mysql学习路线</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/mysql-索引/">Mysql安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/Qunar基础框架-QSchedule/">Qunar基础框架-QSchedule</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/java集合构架中使用到的数据结构和算法/">java集合构架中使用到的数据结构和算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/20/reids-调试环境搭建/">redis-调试环境搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/31/OpenStack-安装/">OpenStack-安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/26/JVM-hotspot-GC机制/">JVM-hotspot-GC机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/11/netty-socketio + socket.io 实现消息推送/">netty-socketio + socket.io 实现消息推送</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/26/mongodb-安装/">mongodb-安装</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/a-ray-of-sunshine" title="github" target="_blank">github</a><ul></ul><a href="http://www.cnblogs.com/a-ray-of-sunshine" title="cnblog" target="_blank">cnblog</a><ul></ul><a href="http://blog.csdn.net/a_ray_of_sunshine" title="csdn" target="_blank">csdn</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Shawshank.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>