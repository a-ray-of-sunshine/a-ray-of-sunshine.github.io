<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Unsafe类 | Shawshank</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Unsafe类</h1><a id="logo" href="/.">Shawshank</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Unsafe类</h1><div class="post-meta">Aug 23, 2016</div><div class="post-content"><h2 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h2><p>unsafe.cpp</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// park</span></span><br><span class="line">UNSAFE_ENTRY(<span class="keyword">void</span>, Unsafe_Park(JNIEnv *env, jobject unsafe, jboolean isAbsolute, jlong time))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_Park"</span>);</span><br><span class="line">  HS_DTRACE_PROBE3(hotspot, thread__park__begin, thread-&gt;parker(), (<span class="keyword">int</span>) isAbsolute, time);</span><br><span class="line">  <span class="function">JavaThreadParkedState <span class="title">jtps</span><span class="params">(thread, time != <span class="number">0</span>)</span></span>;</span><br><span class="line">  thread-&gt;parker()-&gt;park(isAbsolute != <span class="number">0</span>, time);</span><br><span class="line">  HS_DTRACE_PROBE1(hotspot, thread__park__end, thread-&gt;parker());</span><br><span class="line">UNSAFE_END</span><br><span class="line"></span><br><span class="line"><span class="comment">// unpark</span></span><br><span class="line">UNSAFE_ENTRY(<span class="keyword">void</span>, Unsafe_Unpark(JNIEnv *env, jobject unsafe, jobject jthread))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_Unpark"</span>);</span><br><span class="line">  Parker* p = NULL;</span><br><span class="line">  <span class="keyword">if</span> (jthread != NULL) &#123;</span><br><span class="line">    oop java_thread = JNIHandles::resolve_non_null(jthread);</span><br><span class="line">    <span class="keyword">if</span> (java_thread != NULL) &#123;</span><br><span class="line">      jlong lp = java_lang_Thread::park_event(java_thread);</span><br><span class="line">      <span class="keyword">if</span> (lp != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// This cast is OK even though the jlong might have been read</span></span><br><span class="line">        <span class="comment">// non-atomically on 32bit systems, since there, one word will</span></span><br><span class="line">        <span class="comment">// always be zero anyway and the value set is always the same</span></span><br><span class="line">        p = (Parker*)addr_from_java(lp);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Grab lock if apparently null or using older version of library</span></span><br><span class="line">        <span class="function">MutexLocker <span class="title">mu</span><span class="params">(Threads_lock)</span></span>;</span><br><span class="line">        java_thread = JNIHandles::resolve_non_null(jthread);</span><br><span class="line">        <span class="keyword">if</span> (java_thread != NULL) &#123;</span><br><span class="line">          JavaThread* thr = java_lang_Thread::thread(java_thread);</span><br><span class="line">          <span class="keyword">if</span> (thr != NULL) &#123;</span><br><span class="line">            p = thr-&gt;parker();</span><br><span class="line">            <span class="keyword">if</span> (p != NULL) &#123; <span class="comment">// Bind to Java thread for next time.</span></span><br><span class="line">              java_lang_Thread::set_park_event(java_thread, addr_to_java(p));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (p != NULL) &#123;</span><br><span class="line">    HS_DTRACE_PROBE1(hotspot, thread__unpark, p);</span><br><span class="line">    p-&gt;unpark();</span><br><span class="line">  &#125;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>
<p>从上面的实现可知，park 和 unpark 最终都调用当前 JavaThread 对象的 parker() 方法返回一个 Parker 对象，然后调用这个 Parker 对象的 park 和 unpark 方法。</p>
<p>thread.hpp</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class JavaThread: public Thread &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">	  Parker*    _parker;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	  Parker*     parker() &#123; <span class="keyword">return</span> _parker; &#125;	</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JavaThread _parker 对象 在 JavaThread::initialize()  方法中被初始化，initialize 在 JavaThread 的构造函数中被调用。</p>
<p>thread.cpp</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JavaThread::initialize() &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	_parker = Parker::Allocate(<span class="keyword">this</span>) ;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Parker"><a href="#Parker" class="headerlink" title="Parker"></a>Parker</h2><p>Parker 对象定义在 openjdk\hotspot\src\share\vm\runtime\park.hpp &amp; park.cpp 文件中。其中 park 和 unpark 方法的实现依赖于具体的平台，所以分布在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Parker : public os::PlatformParker &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> _counter ;</span><br><span class="line">  Parker * FreeNext ;</span><br><span class="line">  JavaThread * AssociatedWith ; <span class="comment">// Current association</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Parker() : PlatformParker() &#123;</span><br><span class="line">    _counter       = <span class="number">0</span> ;</span><br><span class="line">    FreeNext       = NULL ;</span><br><span class="line">    AssociatedWith = NULL ;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  ~Parker() &#123; ShouldNotReachHere(); &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// For simplicity of interface with Java, all forms of park (indefinite,</span></span><br><span class="line">  <span class="comment">// relative, and absolute) are multiplexed into one call.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">park</span><span class="params">(bool isAbsolute, jlong time)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unpark</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Lifecycle operators</span></span><br><span class="line">  <span class="keyword">static</span> Parker * Allocate (JavaThread * t) ;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Release</span> <span class="params">(Parker * e)</span> </span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> Parker * <span class="keyword">volatile</span> FreeList ;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> ListLock ;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Parker 类继承自 os::PlatformParker 其定义在 os_windows.hpp</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class PlatformParker : public CHeapObj &#123;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    HANDLE _ParkEvent ;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ~PlatformParker () &#123; guarantee (<span class="number">0</span>, <span class="string">"invariant"</span>) ; &#125;</span><br><span class="line">    PlatformParker  () &#123;</span><br><span class="line">      _ParkEvent = CreateEvent (NULL, <span class="keyword">true</span>, <span class="keyword">false</span>, NULL) ;</span><br><span class="line">      guarantee (_ParkEvent != NULL, <span class="string">"invariant"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>hotspot\src\os\windows\vm\os_windows.cpp 文件中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Parker::park(bool isAbsolute, jlong time) &#123;</span><br><span class="line">  guarantee (_ParkEvent != NULL, <span class="string">"invariant"</span>) ;</span><br><span class="line">  <span class="comment">// First, demultiplex/decode time arguments</span></span><br><span class="line">  <span class="keyword">if</span> (time &lt; <span class="number">0</span>) &#123; <span class="comment">// don't wait</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (time == <span class="number">0</span> &amp;&amp; !isAbsolute) &#123;</span><br><span class="line">    time = INFINITE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>  (isAbsolute) &#123;</span><br><span class="line">    time -= os::javaTimeMillis(); <span class="comment">// convert to relative time</span></span><br><span class="line">    <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) <span class="comment">// already elapsed</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123; <span class="comment">// relative</span></span><br><span class="line">    time /= <span class="number">1000000</span>; <span class="comment">// Must coarsen from nanos to millis</span></span><br><span class="line">    <span class="keyword">if</span> (time == <span class="number">0</span>)   <span class="comment">// Wait for the minimal time unit if zero</span></span><br><span class="line">      time = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  JavaThread* thread = (JavaThread*)(Thread::current());</span><br><span class="line">  <span class="keyword">assert</span>(thread-&gt;is_Java_thread(), <span class="string">"Must be JavaThread"</span>);</span><br><span class="line">  JavaThread *jt = (JavaThread *)thread;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Don't wait if interrupted or already triggered</span></span><br><span class="line">  <span class="keyword">if</span> (Thread::is_interrupted(thread, <span class="keyword">false</span>) ||</span><br><span class="line">    WaitForSingleObject(_ParkEvent, <span class="number">0</span>) == WAIT_OBJECT_0) &#123;</span><br><span class="line">    ResetEvent(_ParkEvent);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="function">ThreadBlockInVM <span class="title">tbivm</span><span class="params">(jt)</span></span>;</span><br><span class="line">    <span class="function">OSThreadWaitState <span class="title">osts</span><span class="params">(thread-&gt;osthread()</span>, <span class="keyword">false</span> <span class="comment">/* not Object.wait() */</span>)</span>;</span><br><span class="line">    jt-&gt;set_suspend_equivalent();</span><br><span class="line"></span><br><span class="line">    WaitForSingleObject(_ParkEvent,  time);</span><br><span class="line">    ResetEvent(_ParkEvent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If externally suspended while waiting, re-suspend</span></span><br><span class="line">    <span class="keyword">if</span> (jt-&gt;handle_special_suspend_equivalent_condition()) &#123;</span><br><span class="line">      jt-&gt;java_suspend_self();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Parker::unpark() &#123;</span><br><span class="line">  guarantee (_ParkEvent != NULL, <span class="string">"invariant"</span>) ;</span><br><span class="line">  SetEvent(_ParkEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>park 和 unpark 在 windows 上的实现，采用 WaitForSingleObject 在 Events 对象 _ParkEvent 等待来实现。其核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">_ParkEvent = CreateEvent (NULL, <span class="keyword">true</span>, <span class="keyword">false</span>, NULL) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Parker::park(bool isAbsolute, jlong time) &#123;</span><br><span class="line">	<span class="comment">// 当前线程将在 _ParkEvent 事件对象上 等待</span></span><br><span class="line">	WaitForSingleObject(_ParkEvent,  time);</span><br><span class="line">	<span class="comment">// 上面的函数返回之后，调用 ResetEvent，</span></span><br><span class="line">	<span class="comment">// 使得 _ParkEvent 事件对象可以再次被使用。</span></span><br><span class="line">	<span class="comment">// 线程可以多次调用 park.</span></span><br><span class="line">    ResetEvent(_ParkEvent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Parker::unpark() &#123;</span><br><span class="line">	<span class="comment">// 激发 _ParkEvent，使得在其 wait 的线程从 wait 状态返回。</span></span><br><span class="line">	SetEvent(_ParkEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CreateEvent win32 平台上创建事件对象API.第二个参数为 true 表示创建一个手动重置事件，即当 event 对象被 signal 后，需要手动调用 ResetEvent，使其状态恢复到 nonsignaled. 第三个参数为 false,表示创建的这个 event 对象，初始状态是 nonsignaled 的。</p>
<p>当线程在事件对象 _ParkEvent 上调用 WaitForSingleObject 由于 _ParkEvent初始状态是 nonsignaled 所以当前线程将进入 blocking 状态，直到另一个线程在 _ParkEvent 上调用 SetEvent(_ParkEvent)，使得其 signed. 然后 wait 线程就会醒来，继续执行。调用 ResetEvent 恢复 _ParkEvent 的 nonsignaled 状态。这样 _ParkEvent 对象就可以重新被 park 方法使用了。</p>
<h2 id="Unsafe的-park-amp-unpark-方法在-win32-平台上的实现"><a href="#Unsafe的-park-amp-unpark-方法在-win32-平台上的实现" class="headerlink" title="Unsafe的 park &amp; unpark 方法在 win32 平台上的实现"></a>Unsafe的 park &amp; unpark 方法在 win32 平台上的实现</h2><p>对于每一个 java 线程，在 JVM 内部有一个 JavaThread 的对象与之相对应，这个对象内部有一个 Parker 对象，这个对象有 park 和 unpark 方法，这两个方法的实现依赖于具体的平台。在 windows 平台上使用 WaitForSingleObject 使得线程进入等待状态。这个方法最终在一个事件对象上等待。unpark 将激发这个事件对象，使得线程被唤醒。</p>
<p>当一个线程调用 Unsafe.park 方法时， Unsafe_Park 方法将使用当前线程的 JavaThread 对象中的 Parker 对象的 park 方法使得该线程处于 block 状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 摘自 Unsafe_Park （unsafe.cpp）</span></span><br><span class="line">thread-&gt;parker()-&gt;park(isAbsolute != <span class="number">0</span>, time);</span><br></pre></td></tr></table></figure>
<p>当一个线程调用 Unsafe.unpark 方法时，Unsafe_Unpark 将使用 unpark 的参数 jthread. 获得该 jthread 的 JavaThread 对象，然后调用该对象的 parker 的 unpark.使得 jthread 对应的线程 unblocking.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 摘自 Unsafe_Unpark （unsafe.cpp）</span></span><br><span class="line">java_thread = JNIHandles::resolve_non_null(jthread);</span><br><span class="line">JavaThread* thr = java_lang_Thread::thread(java_thread);</span><br><span class="line">p = thr-&gt;parker();</span><br><span class="line">p-&gt;unpark();</span><br></pre></td></tr></table></figure>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>Unsafe提供的 CAS 机制，用来实现 Atomic 类操作。</p>
<h3 id="objectFieldOffset"><a href="#objectFieldOffset" class="headerlink" title="objectFieldOffset"></a>objectFieldOffset</h3><p>这个方法来获取任意 java 类的某个字段 field 在内存中的相对于 这个 Java 类的所有字段的 偏移量:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 摘自 AtomicInteger 类</span></span><br><span class="line">valueOffset = unsafe.objectFieldOffset</span><br><span class="line">	(AtomicInteger.class.getDeclaredField(<span class="string">"value"</span>));</span><br></pre></td></tr></table></figure>
<p>表示 AtomicInteger 的 value 字段的内存中相对偏移量。</p>
<p>其实现过程如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/share/vm/prims/Unsafe.cpp</span></span><br><span class="line">UNSAFE_ENTRY(jlong, Unsafe_ObjectFieldOffset(JNIEnv *env, jobject unsafe, jobject field))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_ObjectFieldOffset"</span>);</span><br><span class="line">  <span class="comment">// field 参数是：</span></span><br><span class="line">  <span class="comment">// AtomicInteger.class.getDeclaredField("value")</span></span><br><span class="line">  <span class="comment">// 表示 value 字段的 Field 对象的地址</span></span><br><span class="line">  <span class="comment">// THREAD 参数是： 当前线程对象 JavaThread</span></span><br><span class="line">  <span class="keyword">return</span> find_field_offset(field, <span class="number">0</span>, THREAD);</span><br><span class="line">UNSAFE_END</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">jint <span class="title">find_field_offset</span><span class="params">(jobject field, <span class="keyword">int</span> must_be_static, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (field == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    THROW_0(vmSymbols::java_lang_NullPointerException());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// JNIHandles::resolve_non_null(field) 方法直接将 转换成 oop 对象</span></span><br><span class="line">  <span class="comment">// 也间接证明了 field 其实就是一个 指向 Field oop 对象的指针</span></span><br><span class="line">  <span class="comment">// 同时也说明 Field f = AtomicInteger.class.getDeclaredField("value")</span></span><br><span class="line">  <span class="comment">// 这个调用返回的所谓 f 对象，其实就是一个指向 Filed 底层 oop 对象的指针。</span></span><br><span class="line">  oop reflected   = JNIHandles::resolve_non_null(field);</span><br><span class="line">  oop mirror      = java_lang_reflect_Field::clazz(reflected);</span><br><span class="line">  klassOop k      = java_lang_Class::as_klassOop(mirror);</span><br><span class="line">  <span class="keyword">int</span> slot        = java_lang_reflect_Field::slot(reflected);</span><br><span class="line">  <span class="keyword">int</span> modifiers   = java_lang_reflect_Field::modifiers(reflected);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (must_be_static &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> really_is_static = ((modifiers &amp; JVM_ACC_STATIC) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (must_be_static != really_is_static) &#123;</span><br><span class="line">      THROW_0(vmSymbols::java_lang_IllegalArgumentException());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 到这里，其实可以看到，这个方法的实现，和 Java类及对象在vm层的实现有关</span></span><br><span class="line">  <span class="comment">// 也就是 oop-Klass 模型。依据这些底层结构之间的关联（指针）。自然可以</span></span><br><span class="line">  <span class="comment">// 字段所对应的 klass 找到 字段 在 类 内的偏移量。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在这里调用了字段所在类的 Klass 的 offset_from_fields 方法获取</span></span><br><span class="line">  <span class="comment">// 字段所在的偏移量。至于 offset_from_fields 这个方法的实现，就和</span></span><br><span class="line">  <span class="comment">// oop-klass 模型如何表示 Java 对象 及 类 相关了。</span></span><br><span class="line">  <span class="comment">// oop-klass 模型 约定了 内存布局及规范，offset_from_fields</span></span><br><span class="line">  <span class="comment">// 方法实现起来亦不难</span></span><br><span class="line">  <span class="keyword">int</span> offset = instanceKlass::cast(k)-&gt;offset_from_fields(slot);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// field_offset_from_byte_offset 这个方法调用是只是将 </span></span><br><span class="line">  <span class="comment">// 参数 offset 直接返回了。所以上面的 offset 就是最终的结果。</span></span><br><span class="line">  <span class="keyword">return</span> field_offset_from_byte_offset(offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="compareAndSwapInt"><a href="#compareAndSwapInt" class="headerlink" title="compareAndSwapInt"></a>compareAndSwapInt</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个一个 java 调用 </span></span><br><span class="line">unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line"><span class="comment">// 对应的JVM实现如下：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中 obj &lt;==&gt; this, offset &lt;==&gt; valueOffset, </span></span><br><span class="line"><span class="comment">//		e &lt;==&gt; expect, x &lt;==&gt; update</span></span><br><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapInt"</span>);</span><br><span class="line">  <span class="comment">// 获取 this 对象的底层 oop 对象</span></span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  <span class="comment">// 获取 this 对象的 offset 处的字段的地址。</span></span><br><span class="line">  <span class="comment">// index_oop_from_field_offset_long 方法实现的核心是：</span></span><br><span class="line">  <span class="comment">// p + offset; 就是 当前对象的地址 + 字段所处的偏移量</span></span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后真正完成功能就是下面的调用</span></span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>
<p>Atomic::cmpxchg 功能的实现则是利用具体系统和CPU硬件指令的支持来完成的<br>在 windows x86 架构下在其实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hotspot\src\os_cpu\windows_x86\vm\atomic_windows_x86.inline.hpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Adding a lock prefix to an instruction on MP machine</span></span><br><span class="line"><span class="comment">// VC++ doesn't like the lock prefix to be on a single line</span></span><br><span class="line"><span class="comment">// so we can't insert a label after the lock prefix.</span></span><br><span class="line"><span class="comment">// By emitting a lock prefix, we can define a label after it.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_IF_MP(mp) __asm cmp mp, 0  \</span></span><br><span class="line">                       __asm je L0      \</span><br><span class="line">                       __asm _emit <span class="number">0xF0</span> \</span><br><span class="line">                       __asm L0:</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> AMD64</span></span><br><span class="line"><span class="comment">// 如果是 AMD64 架构的CPU则使用下面的实现：</span></span><br><span class="line"><span class="keyword">inline</span> jint     Atomic::cmpxchg    (jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value) &#123;</span><br><span class="line">  <span class="keyword">return</span> (*os::atomic_cmpxchg_func)(exchange_value, dest, compare_value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">// !AMD64</span></span></span><br><span class="line"><span class="comment">// 如果不是 AMD64 架构的CPU则使用下面的实现：</span></span><br><span class="line"><span class="comment">// 其中使用到 cmpxchg 指令，这是 CPU 提供的完成 CAS 功能的指令。</span></span><br><span class="line"><span class="keyword">inline</span> jint     Atomic::cmpxchg    (jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value) &#123;</span><br><span class="line">  <span class="comment">// alternative for InterlockedCompareExchange</span></span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><br><span class="line">  __asm &#123;</span><br><span class="line">    mov edx, dest</span><br><span class="line">    mov ecx, exchange_value</span><br><span class="line">    mov eax, compare_value</span><br><span class="line">    LOCK_IF_MP(mp)</span><br><span class="line">    cmpxchg dword ptr [edx], ecx</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// AMD64</span></span></span><br></pre></td></tr></table></figure>
<p>从上面的实现可知，其实 Unsafe 提供的 CAS 机制，最终是由 CPU 和 系统协作完成的，如果 CPU 提供了 CAS 指令，则可以直接利用 CPU 的 CAS 指令。如果没有，则可以交由操作系统来实现。</p>
<p>cmpxchg：这个指令是CPU提供的用于支持 CAS 操作。</p>
<h2 id="有关内存的操作"><a href="#有关内存的操作" class="headerlink" title="有关内存的操作"></a>有关内存的操作</h2><h3 id="allocateMemory"><a href="#allocateMemory" class="headerlink" title="allocateMemory"></a>allocateMemory</h3><p>由 malloc 实现：</p>
<p><code>void* malloc (size_t size);</code></p>
<blockquote>
<p>Allocates a block of size bytes of memory, returning a pointer to the beginning of the block.</p>
<p>The content of the newly allocated block of memory is not initialized, remaining with indeterminate values.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* os::<span class="built_in">malloc</span>(<span class="keyword">size_t</span> size) &#123;</span><br><span class="line">  NOT_PRODUCT(inc_stat_counter(&amp;num_mallocs, <span class="number">1</span>));</span><br><span class="line">  NOT_PRODUCT(inc_stat_counter(&amp;alloc_bytes, size));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// return a valid pointer if size is zero</span></span><br><span class="line">    <span class="comment">// if NULL is returned the calling functions assume out of memory.</span></span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  NOT_PRODUCT(<span class="keyword">if</span> (MallocVerifyInterval &gt; <span class="number">0</span>) check_heap());</span><br><span class="line">  u_char* ptr = (u_char*)::<span class="built_in">malloc</span>(size + space_before + space_after);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">  <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span> (MallocCushion) &#123;</span><br><span class="line">    <span class="keyword">for</span> (u_char* p = ptr; p &lt; ptr + MallocCushion; p++) *p = (u_char)badResourceValue;</span><br><span class="line">    u_char* end = ptr + space_before + size;</span><br><span class="line">    <span class="keyword">for</span> (u_char* pq = ptr+MallocCushion; pq &lt; end; pq++) *pq = (u_char)uninitBlockPad;</span><br><span class="line">    <span class="keyword">for</span> (u_char* q = end; q &lt; end + MallocCushion; q++) *q = (u_char)badResourceValue;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// put size just before data</span></span><br><span class="line">  *size_addr_from_base(ptr) = size;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  u_char* memblock = ptr + space_before;</span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">intptr_t</span>)memblock == (<span class="keyword">intptr_t</span>)MallocCatchPtr) &#123;</span><br><span class="line">    tty-&gt;print_cr(<span class="string">"os::malloc caught, "</span> SIZE_FORMAT <span class="string">" bytes --&gt; "</span> PTR_FORMAT, size, memblock);</span><br><span class="line">    breakpoint();</span><br><span class="line">  &#125;</span><br><span class="line">  debug_only(<span class="keyword">if</span> (paranoid) verify_block(memblock));</span><br><span class="line">  <span class="keyword">if</span> (PrintMalloc &amp;&amp; tty != <span class="literal">NULL</span>) tty-&gt;print_cr(<span class="string">"os::malloc "</span> SIZE_FORMAT <span class="string">" bytes --&gt; "</span> PTR_FORMAT, size, memblock);</span><br><span class="line">  <span class="keyword">return</span> memblock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="reallocateMemory"><a href="#reallocateMemory" class="headerlink" title="reallocateMemory"></a>reallocateMemory</h3><p><code>void* realloc (void* ptr, size_t size);</code></p>
<blockquote>
<p>Changes the size of the memory block pointed to by ptr.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* os::<span class="built_in">realloc</span>(<span class="keyword">void</span> *memblock, <span class="keyword">size_t</span> size) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ASSERT</span></span><br><span class="line">  NOT_PRODUCT(inc_stat_counter(&amp;num_mallocs, <span class="number">1</span>));</span><br><span class="line">  NOT_PRODUCT(inc_stat_counter(&amp;alloc_bytes, size));</span><br><span class="line">  <span class="keyword">return</span> ::<span class="built_in">realloc</span>(memblock, size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">if</span> (memblock == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">intptr_t</span>)memblock == (<span class="keyword">intptr_t</span>)MallocCatchPtr) &#123;</span><br><span class="line">    tty-&gt;print_cr(<span class="string">"os::realloc caught "</span> PTR_FORMAT, memblock);</span><br><span class="line">    breakpoint();</span><br><span class="line">  &#125;</span><br><span class="line">  verify_block(memblock);</span><br><span class="line">  NOT_PRODUCT(<span class="keyword">if</span> (MallocVerifyInterval &gt; <span class="number">0</span>) check_heap());</span><br><span class="line">  <span class="keyword">if</span> (size == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">// always move the block</span></span><br><span class="line">  <span class="keyword">void</span>* ptr = <span class="built_in">malloc</span>(size);</span><br><span class="line">  <span class="keyword">if</span> (PrintMalloc) tty-&gt;print_cr(<span class="string">"os::remalloc "</span> SIZE_FORMAT <span class="string">" bytes, "</span> PTR_FORMAT <span class="string">" --&gt; "</span> PTR_FORMAT, size, memblock, ptr);</span><br><span class="line">  <span class="comment">// Copy to new memory if malloc didn't fail</span></span><br><span class="line">  <span class="keyword">if</span> ( ptr != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, memblock, MIN2(size, get_size(memblock)));</span><br><span class="line">    <span class="keyword">if</span> (paranoid) verify_block(ptr);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">intptr_t</span>)ptr == (<span class="keyword">intptr_t</span>)MallocCatchPtr) &#123;</span><br><span class="line">      tty-&gt;print_cr(<span class="string">"os::realloc caught, "</span> SIZE_FORMAT <span class="string">" bytes --&gt; "</span> PTR_FORMAT, size, ptr);</span><br><span class="line">      breakpoint();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(memblock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="setMemory"><a href="#setMemory" class="headerlink" title="setMemory"></a>setMemory</h3><p><code>void * memset ( void * ptr, int value, size_t num );</code></p>
<blockquote>
<p>Sets the first num bytes of the block of memory pointed by ptr to the specified value</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fill bytes; larger units are filled atomically if everything is aligned.</span></span><br><span class="line"><span class="keyword">void</span> Copy::fill_to_memory_atomic(<span class="keyword">void</span>* to, <span class="keyword">size_t</span> size, jubyte value) &#123;</span><br><span class="line">  address dst = (address) to;</span><br><span class="line">  <span class="keyword">uintptr_t</span> bits = (<span class="keyword">uintptr_t</span>) to | (<span class="keyword">uintptr_t</span>) size;</span><br><span class="line">  <span class="keyword">if</span> (bits % <span class="keyword">sizeof</span>(jlong) == <span class="number">0</span>) &#123;</span><br><span class="line">    jlong fill = (julong)( (jubyte)value ); <span class="comment">// zero-extend</span></span><br><span class="line">    <span class="keyword">if</span> (fill != <span class="number">0</span>) &#123;</span><br><span class="line">      fill += fill &lt;&lt; <span class="number">8</span>;</span><br><span class="line">      fill += fill &lt;&lt; <span class="number">16</span>;</span><br><span class="line">      fill += fill &lt;&lt; <span class="number">32</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Copy::fill_to_jlongs_atomic((jlong*) dst, size / sizeof(jlong));</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uintptr_t</span> off = <span class="number">0</span>; off &lt; size; off += <span class="keyword">sizeof</span>(jlong)) &#123;</span><br><span class="line">      *(jlong*)(dst + off) = fill;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bits % <span class="keyword">sizeof</span>(jint) == <span class="number">0</span>) &#123;</span><br><span class="line">    jint fill = (juint)( (jubyte)value ); <span class="comment">// zero-extend</span></span><br><span class="line">    <span class="keyword">if</span> (fill != <span class="number">0</span>) &#123;</span><br><span class="line">      fill += fill &lt;&lt; <span class="number">8</span>;</span><br><span class="line">      fill += fill &lt;&lt; <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Copy::fill_to_jints_atomic((jint*) dst, size / sizeof(jint));</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uintptr_t</span> off = <span class="number">0</span>; off &lt; size; off += <span class="keyword">sizeof</span>(jint)) &#123;</span><br><span class="line">      *(jint*)(dst + off) = fill;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bits % <span class="keyword">sizeof</span>(jshort) == <span class="number">0</span>) &#123;</span><br><span class="line">    jshort fill = (jushort)( (jubyte)value ); <span class="comment">// zero-extend</span></span><br><span class="line">    fill += fill &lt;&lt; <span class="number">8</span>;</span><br><span class="line">    <span class="comment">//Copy::fill_to_jshorts_atomic((jshort*) dst, size / sizeof(jshort));</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uintptr_t</span> off = <span class="number">0</span>; off &lt; size; off += <span class="keyword">sizeof</span>(jshort)) &#123;</span><br><span class="line">      *(jshort*)(dst + off) = fill;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Not aligned, so no need to be atomic.</span></span><br><span class="line">    <span class="comment">// 内部使用 memset 实现</span></span><br><span class="line">    Copy::fill_to_bytes(dst, size, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="copyMemory"><a href="#copyMemory" class="headerlink" title="copyMemory"></a>copyMemory</h3><p><code>void * memmove ( void * destination, const void * source, size_t num );</code></p>
<blockquote>
<p>Copies the values of num bytes from the location pointed by source to the memory block pointed by destination. Copying takes place as if an intermediate buffer were used, allowing the destination and source to overlap.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy bytes; larger units are filled atomically if everything is aligned.</span></span><br><span class="line"><span class="keyword">void</span> Copy::conjoint_memory_atomic(<span class="keyword">void</span>* from, <span class="keyword">void</span>* to, <span class="keyword">size_t</span> size) &#123;</span><br><span class="line">  address src = (address) from;</span><br><span class="line">  address dst = (address) to;</span><br><span class="line">  <span class="keyword">uintptr_t</span> bits = (<span class="keyword">uintptr_t</span>) src | (<span class="keyword">uintptr_t</span>) dst | (<span class="keyword">uintptr_t</span>) size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// (Note:  We could improve performance by ignoring the low bits of size,</span></span><br><span class="line">  <span class="comment">// and putting a short cleanup loop after each bulk copy loop.</span></span><br><span class="line">  <span class="comment">// There are plenty of other ways to make this faster also,</span></span><br><span class="line">  <span class="comment">// and it's a slippery slope.  For now, let's keep this code simple</span></span><br><span class="line">  <span class="comment">// since the simplicity helps clarify the atomicity semantics of</span></span><br><span class="line">  <span class="comment">// this operation.  There are also CPU-specific assembly versions</span></span><br><span class="line">  <span class="comment">// which may or may not want to include such optimizations.)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bits % <span class="keyword">sizeof</span>(jlong) == <span class="number">0</span>) &#123;</span><br><span class="line">    Copy::conjoint_jlongs_atomic((jlong*) src, (jlong*) dst, size / <span class="keyword">sizeof</span>(jlong));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bits % <span class="keyword">sizeof</span>(jint) == <span class="number">0</span>) &#123;</span><br><span class="line">    Copy::conjoint_jints_atomic((jint*) src, (jint*) dst, size / <span class="keyword">sizeof</span>(jint));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bits % <span class="keyword">sizeof</span>(jshort) == <span class="number">0</span>) &#123;</span><br><span class="line">    Copy::conjoint_jshorts_atomic((jshort*) src, (jshort*) dst, size / <span class="keyword">sizeof</span>(jshort));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Not aligned, so no need to be atomic.</span></span><br><span class="line">    <span class="comment">// 内部使用 memmove 实现</span></span><br><span class="line">    Copy::conjoint_jbytes((<span class="keyword">void</span>*) src, (<span class="keyword">void</span>*) dst, size);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="freeMemory"><a href="#freeMemory" class="headerlink" title="freeMemory"></a>freeMemory</h3><p><code>void free (void* ptr);</code></p>
<blockquote>
<p>A block of memory previously allocated by a call to malloc, calloc or realloc is deallocated, making it available again for further allocations.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>  os::<span class="built_in">free</span>(<span class="keyword">void</span> *memblock) &#123;</span><br><span class="line">  NOT_PRODUCT(inc_stat_counter(&amp;num_frees, <span class="number">1</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">  <span class="keyword">if</span> (memblock == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">intptr_t</span>)memblock == (<span class="keyword">intptr_t</span>)MallocCatchPtr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tty != <span class="literal">NULL</span>) tty-&gt;print_cr(<span class="string">"os::free caught "</span> PTR_FORMAT, memblock);</span><br><span class="line">    breakpoint();</span><br><span class="line">  &#125;</span><br><span class="line">  verify_block(memblock);</span><br><span class="line">  NOT_PRODUCT(<span class="keyword">if</span> (MallocVerifyInterval &gt; <span class="number">0</span>) check_heap());</span><br><span class="line">  <span class="comment">// Added by detlefs.</span></span><br><span class="line">  <span class="keyword">if</span> (MallocCushion) &#123;</span><br><span class="line">    u_char* ptr = (u_char*)memblock - space_before;</span><br><span class="line">    <span class="keyword">for</span> (u_char* p = ptr; p &lt; ptr + MallocCushion; p++) &#123;</span><br><span class="line">      guarantee(*p == badResourceValue,</span><br><span class="line">                <span class="string">"Thing freed should be malloc result."</span>);</span><br><span class="line">      *p = (u_char)freeBlockPad;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> size = get_size(memblock);</span><br><span class="line">    inc_stat_counter(&amp;free_bytes, size);</span><br><span class="line">    u_char* end = ptr + space_before + size;</span><br><span class="line">    <span class="keyword">for</span> (u_char* q = end; q &lt; end + MallocCushion; q++) &#123;</span><br><span class="line">      guarantee(*q == badResourceValue,</span><br><span class="line">                <span class="string">"Thing freed should be malloc result."</span>);</span><br><span class="line">      *q = (u_char)freeBlockPad;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (PrintMalloc &amp;&amp; tty != <span class="literal">NULL</span>)</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"os::free "</span> SIZE_FORMAT <span class="string">" bytes --&gt; "</span> PTR_FORMAT <span class="string">"\n"</span>, size, (<span class="keyword">uintptr_t</span>)memblock);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (PrintMalloc &amp;&amp; tty != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// tty-&gt;print_cr("os::free %p", memblock);</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"os::free "</span> PTR_FORMAT <span class="string">"\n"</span>, (<span class="keyword">uintptr_t</span>)memblock);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  ::<span class="built_in">free</span>((<span class="keyword">char</span>*)memblock - space_before);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2016/08/24/线程-sleep,wait及interrupt/">线程-sleep,wait及interrupt</a><a class="next" href="/2016/08/22/线程-创建和启动/">线程-创建和启动</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/interface/" style="font-size: 15px;">interface</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/Collections/" style="font-size: 15px;">Collections</a> <a href="/tags/Collection/" style="font-size: 15px;">Collection</a> <a href="/tags/J-U-C/" style="font-size: 15px;">J.U.C</a> <a href="/tags/lock/" style="font-size: 15px;">lock</a> <a href="/tags/Semaphore/" style="font-size: 15px;">Semaphore</a> <a href="/tags/CountDownLatch/" style="font-size: 15px;">CountDownLatch</a> <a href="/tags/CyclicBarrier/" style="font-size: 15px;">CyclicBarrier</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/LinkedList/" style="font-size: 15px;">LinkedList</a> <a href="/tags/Queue/" style="font-size: 15px;">Queue</a> <a href="/tags/Set/" style="font-size: 15px;">Set</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/collection/" style="font-size: 15px;">collection</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/api/" style="font-size: 15px;">api</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/mvc/" style="font-size: 15px;">mvc</a> <a href="/tags/context/" style="font-size: 15px;">context</a> <a href="/tags/component-scan/" style="font-size: 15px;">component-scan</a> <a href="/tags/storm/" style="font-size: 15px;">storm</a> <a href="/tags/windows/" style="font-size: 15px;">windows</a> <a href="/tags/命令行/" style="font-size: 15px;">命令行</a> <a href="/tags/cmder/" style="font-size: 15px;">cmder</a> <a href="/tags/win/" style="font-size: 15px;">win</a> <a href="/tags/效率/" style="font-size: 15px;">效率</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/博客/" style="font-size: 15px;">博客</a> <a href="/tags/apache/" style="font-size: 15px;">apache</a> <a href="/tags/extends/" style="font-size: 15px;">extends</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/svn/" style="font-size: 15px;">svn</a> <a href="/tags/BlockingQueue/" style="font-size: 15px;">BlockingQueue</a> <a href="/tags/LinkedBlockingQueue/" style="font-size: 15px;">LinkedBlockingQueue</a> <a href="/tags/PriorityBlockingQueue/" style="font-size: 15px;">PriorityBlockingQueue</a> <a href="/tags/ConcurrentLinkedQueue/" style="font-size: 15px;">ConcurrentLinkedQueue</a> <a href="/tags/CopyOnWriteArrayList/" style="font-size: 15px;">CopyOnWriteArrayList</a> <a href="/tags/接口/" style="font-size: 15px;">接口</a> <a href="/tags/抽象类/" style="font-size: 15px;">抽象类</a> <a href="/tags/Executor/" style="font-size: 15px;">Executor</a> <a href="/tags/ExecutorService/" style="font-size: 15px;">ExecutorService</a> <a href="/tags/CompletionService/" style="font-size: 15px;">CompletionService</a> <a href="/tags/ThreadPoolExecutor/" style="font-size: 15px;">ThreadPoolExecutor</a> <a href="/tags/vim/" style="font-size: 15px;">vim</a> <a href="/tags/vundle/" style="font-size: 15px;">vundle</a> <a href="/tags/ArrayList/" style="font-size: 15px;">ArrayList</a> <a href="/tags/log/" style="font-size: 15px;">log</a> <a href="/tags/index/" style="font-size: 15px;">index</a> <a href="/tags/concepts/" style="font-size: 15px;">concepts</a> <a href="/tags/Timer/" style="font-size: 15px;">Timer</a> <a href="/tags/TimerTask/" style="font-size: 15px;">TimerTask</a> <a href="/tags/ConcurrentMap/" style="font-size: 15px;">ConcurrentMap</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 15px;">ConcurrentHashMap</a> <a href="/tags/HashMap/" style="font-size: 15px;">HashMap</a> <a href="/tags/ReentrantReadWriteLock/" style="font-size: 15px;">ReentrantReadWriteLock</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/SynchronousQueue/" style="font-size: 15px;">SynchronousQueue</a> <a href="/tags/ScheduledExecutorService/" style="font-size: 15px;">ScheduledExecutorService</a> <a href="/tags/AQS/" style="font-size: 15px;">AQS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/BigData-docker/">Windows 上安装 docker</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/mysql-0.路线/">Mysql学习路线</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/mysql-索引/">Mysql安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/Qunar基础框架-QSchedule/">Qunar基础框架-QSchedule</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/java集合构架中使用到的数据结构和算法/">java集合构架中使用到的数据结构和算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/20/reids-调试环境搭建/">redis-调试环境搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/31/OpenStack-安装/">OpenStack-安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/26/JVM-hotspot-GC机制/">JVM-hotspot-GC机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/11/netty-socketio + socket.io 实现消息推送/">netty-socketio + socket.io 实现消息推送</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/26/mongodb-安装/">mongodb-安装</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/a-ray-of-sunshine" title="github" target="_blank">github</a><ul></ul><a href="http://www.cnblogs.com/a-ray-of-sunshine" title="cnblog" target="_blank">cnblog</a><ul></ul><a href="http://blog.csdn.net/a_ray_of_sunshine" title="csdn" target="_blank">csdn</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Shawshank.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>