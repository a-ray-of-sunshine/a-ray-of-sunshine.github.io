<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>SynchronousQueue | Shawshank</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">SynchronousQueue</h1><a id="logo" href="/.">Shawshank</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">SynchronousQueue</h1><div class="post-meta">Aug 4, 2016</div><div class="post-content"><p>SynchronousQueue 是 blocking queue 队列的一种，它的作用是，当一个线程执行插入操作（put）的时候，必须等待另一个线程执行对应的删除操作（take），反之，一个线程如果要执行删除操作则必须等待另一个线程执行插入操作。</p>
<p><strong>What We CAN’T DO IN SynchronousQueue:</strong></p>
<ul>
<li><p>SynchronousQueue内部实现中并没有容量的概念，所以不能执行 peek 操作，因为只有在线程试图执行remove操作的时候才有一个元素存在。</p>
</li>
<li><p>不能成功插入一个元素（add, off, put方法）除非另一个线程试图执行删除操作。</p>
</li>
<li><p>无法对 SynchronousQueue 进行 iterator, 因为返回的是一个空的iterator</p>
</li>
</ul>
<p>使用场景：</p>
<p>They are well suited for handoff designs, in which an object running in one thread must sync up with an object running in another thread in order to hand it some information, event, or task. </p>
<p>它们非常适用于越区切换的设计，其中在一个线程中运行的对象必须与一个对象在另一个线程以便把它的一些信息，事件或任务运行同步。</p>
<p>这个类被用在 java.util.concurrent.Executors.newCachedThreadPool 方法中，这个方法用来创建线程池，这个方法的作用是用来创建一个可以执行短暂的异步任务的线程池。（These pools will typically improve the performance of programs that <strong>execute many short-lived asynchronous tasks.</strong>）</p>
<p>具体实现，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ThreadPoolExecutor.ThreadPoolExecutor 查看文档，可以看到：<br>Direct handoffs. A good default choice for a work queue is a SynchronousQueue that hands off tasks to threads without otherwise holding them. Here, an attempt to queue a task will fail if no threads are immediately available to run it, so a new thread will be constructed. This policy avoids lockups when handling sets of requests that might have internal dependencies. Direct handoffs generally require unbounded maximumPoolSizes to avoid rejection of new submitted tasks. This in turn admits the possibility of unbounded thread growth when commands continue to arrive on average faster than they can be processed. </p>
<h2 id="构造过程"><a href="#构造过程" class="headerlink" title="构造过程"></a>构造过程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 无参数的构造函数默认是：</span></span><br><span class="line">	<span class="comment">// new TransferStack()</span></span><br><span class="line">	transferer = fair ? <span class="keyword">new</span> TransferQueue() : <span class="keyword">new</span> TransferStack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Transferer"><a href="#Transferer" class="headerlink" title="Transferer"></a>Transferer</h2><h2 id="TransferStack"><a href="#TransferStack" class="headerlink" title="TransferStack"></a>TransferStack</h2><h3 id="put过程"><a href="#put过程" class="headerlink" title="put过程"></a>put过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E o)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (transferer.transfer(o, <span class="keyword">false</span>, <span class="number">0</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Thread.interrupted();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">transfer</span><span class="params">(Object e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Basic algorithm is to loop trying one of three actions:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 1. If apparently empty or already containing nodes of same</span></span><br><span class="line"><span class="comment">         *    mode, try to push node on stack and wait for a match,</span></span><br><span class="line"><span class="comment">         *    returning it, or null if cancelled.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 2. If apparently containing node of complementary mode,</span></span><br><span class="line"><span class="comment">         *    try to push a fulfilling node on to stack, match</span></span><br><span class="line"><span class="comment">         *    with corresponding waiting node, pop both from</span></span><br><span class="line"><span class="comment">         *    stack, and return matched item. The matching or</span></span><br><span class="line"><span class="comment">         *    unlinking might not actually be necessary because of</span></span><br><span class="line"><span class="comment">         *    other threads performing action 3:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 3. If top of stack already holds another fulfilling node,</span></span><br><span class="line"><span class="comment">         *    help it out by doing its match and/or pop</span></span><br><span class="line"><span class="comment">         *    operations, and then continue. The code for helping</span></span><br><span class="line"><span class="comment">         *    is essentially the same as for fulfilling, except</span></span><br><span class="line"><span class="comment">         *    that it doesn't return the item.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// (1) 确定 s: mode = DATA, next = head, item = e,</span></span><br><span class="line">        SNode s = <span class="keyword">null</span>; <span class="comment">// constructed/reused as needed</span></span><br><span class="line">        <span class="keyword">int</span> mode = (e == <span class="keyword">null</span>) ? REQUEST : DATA;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            SNode h = head;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// (2) 第一次 put, 直到 （casHead） 执行成功之前，</span></span><br><span class="line">			<span class="comment">// h == null 始终成立，所以进入下面的if语句。</span></span><br><span class="line">            <span class="keyword">if</span> (h == <span class="keyword">null</span> || h.mode == mode) &#123;  <span class="comment">// empty or same-mode</span></span><br><span class="line">                <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>) &#123;      <span class="comment">// can't wait</span></span><br><span class="line">                    <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.isCancelled())</span><br><span class="line">                        casHead(h, h.next);     <span class="comment">// pop cancelled node</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">				<span class="comment">// (3) 创建 s = snode(s, e, h, mode)</span></span><br><span class="line">				<span class="comment">// 使用 casHead 进入设置 head,开始自旋，直到</span></span><br><span class="line">				<span class="comment">// 下面的 if 成立，</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s = snode(s, e, h, mode))) &#123;</span><br><span class="line">					<span class="comment">// 经过数次自旋尝试之后，当前线程进入 block 状态</span></span><br><span class="line">					<span class="comment">// 等待 一个线程的 take 操作。</span></span><br><span class="line">                    SNode m = awaitFulfill(s, timed, nanos);</span><br><span class="line">                    <span class="keyword">if</span> (m == s) &#123;               <span class="comment">// wait was cancelled</span></span><br><span class="line">                        clean(s);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((h = head) != <span class="keyword">null</span> &amp;&amp; h.next == s)</span><br><span class="line">                        casHead(h, s.next);     <span class="comment">// help s's fulfiller</span></span><br><span class="line">                    <span class="keyword">return</span> (mode == REQUEST) ? m.item : s.item;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isFulfilling(h.mode)) &#123; <span class="comment">// try to fulfill</span></span><br><span class="line">                <span class="keyword">if</span> (h.isCancelled())            <span class="comment">// already cancelled</span></span><br><span class="line">                    casHead(h, h.next);         <span class="comment">// pop and retry</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s=snode(s, e, h, FULFILLING|mode))) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (;;) &#123; <span class="comment">// loop until matched or waiters disappear</span></span><br><span class="line">                        SNode m = s.next;       <span class="comment">// m is s's match</span></span><br><span class="line">                        <span class="keyword">if</span> (m == <span class="keyword">null</span>) &#123;        <span class="comment">// all waiters are gone</span></span><br><span class="line">                            casHead(s, <span class="keyword">null</span>);   <span class="comment">// pop fulfill node</span></span><br><span class="line">                            s = <span class="keyword">null</span>;           <span class="comment">// use new node next time</span></span><br><span class="line">                            <span class="keyword">break</span>;              <span class="comment">// restart main loop</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        SNode mn = m.next;</span><br><span class="line">                        <span class="keyword">if</span> (m.tryMatch(s)) &#123;</span><br><span class="line">                            casHead(s, mn);     <span class="comment">// pop both s and m</span></span><br><span class="line">                            <span class="keyword">return</span> (mode == REQUEST) ? m.item : s.item;</span><br><span class="line">                        &#125; <span class="keyword">else</span>                  <span class="comment">// lost match</span></span><br><span class="line">                            s.casNext(m, mn);   <span class="comment">// help unlink</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                            <span class="comment">// help a fulfiller</span></span><br><span class="line">                SNode m = h.next;               <span class="comment">// m is h's match</span></span><br><span class="line">                <span class="keyword">if</span> (m == <span class="keyword">null</span>)                  <span class="comment">// waiter is gone</span></span><br><span class="line">                    casHead(h, <span class="keyword">null</span>);           <span class="comment">// pop fulfilling node</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    SNode mn = m.next;</span><br><span class="line">                    <span class="keyword">if</span> (m.tryMatch(h))          <span class="comment">// help match</span></span><br><span class="line">                        casHead(h, mn);         <span class="comment">// pop both h and m</span></span><br><span class="line">                    <span class="keyword">else</span>                        <span class="comment">// lost match</span></span><br><span class="line">                        h.casNext(m, mn);       <span class="comment">// help unlink</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">SNode <span class="title">awaitFulfill</span><span class="params">(SNode s, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * When a node/thread is about to block, it sets its waiter</span></span><br><span class="line"><span class="comment">             * field and then rechecks state at least one more time</span></span><br><span class="line"><span class="comment">             * before actually parking, thus covering race vs</span></span><br><span class="line"><span class="comment">             * fulfiller noticing that waiter is non-null so should be</span></span><br><span class="line"><span class="comment">             * woken.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * When invoked by nodes that appear at the point of call</span></span><br><span class="line"><span class="comment">             * to be at the head of the stack, calls to park are</span></span><br><span class="line"><span class="comment">             * preceded by spins to avoid blocking when producers and</span></span><br><span class="line"><span class="comment">             * consumers are arriving very close in time.  This can</span></span><br><span class="line"><span class="comment">             * happen enough to bother only on multiprocessors.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * The order of checks for returning out of main loop</span></span><br><span class="line"><span class="comment">             * reflects fact that interrupts have precedence over</span></span><br><span class="line"><span class="comment">             * normal returns, which have precedence over</span></span><br><span class="line"><span class="comment">             * timeouts. (So, on timeout, one last check for match is</span></span><br><span class="line"><span class="comment">             * done before giving up.) Except that calls from untimed</span></span><br><span class="line"><span class="comment">             * SynchronousQueue.&#123;poll/offer&#125; don't check interrupts</span></span><br><span class="line"><span class="comment">             * and don't wait at all, so are trapped in transfer</span></span><br><span class="line"><span class="comment">             * method rather than calling awaitFulfill.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">			<span class="comment">// lastTime = 0</span></span><br><span class="line">            <span class="keyword">long</span> lastTime = timed ? System.nanoTime() : <span class="number">0</span>;</span><br><span class="line">            Thread w = Thread.currentThread();</span><br><span class="line">			<span class="comment">// h 上面 put 的 s</span></span><br><span class="line">            SNode h = head;</span><br><span class="line">			<span class="comment">// 自旋次数： maxUntimedSpins</span></span><br><span class="line">            <span class="keyword">int</span> spins = (shouldSpin(s) ?</span><br><span class="line">                         (timed ? maxTimedSpins : maxUntimedSpins) : <span class="number">0</span>);</span><br><span class="line">			<span class="comment">// 开始自旋循环，次数就是上面的 spins.</span></span><br><span class="line">			<span class="comment">// 也就是执行spins下面的循环。</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (w.isInterrupted())</span><br><span class="line">                    s.tryCancel();</span><br><span class="line">                SNode m = s.match;</span><br><span class="line">				<span class="comment">// 当下面的 s.tryCancel 成功之后， m != null 就会成功</span></span><br><span class="line">                <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> m;</span><br><span class="line">				<span class="comment">// 如果设置了超时，则在自旋过程中判断</span></span><br><span class="line">				<span class="comment">// 是否在自旋过程中就已经，超时了，如果超时，尝试</span></span><br><span class="line">				<span class="comment">// 调用 tryCancel 来取消，当前结点在 队列中的等待</span></span><br><span class="line">                <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                    <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">                    nanos -= now - lastTime;</span><br><span class="line">                    lastTime = now;</span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">						<span class="comment">// 这个方法会在外层的 for 循环中不断循环执行</span></span><br><span class="line">						<span class="comment">// 直到 将 s 的 match 字段设置成功，</span></span><br><span class="line">						<span class="comment">// 当 match 字段设置成功之后，继续 continue</span></span><br><span class="line">						<span class="comment">// 执行到上面的 if (m != null) 处</span></span><br><span class="line">						<span class="comment">// 这个判断成功了，所以上面的 if (m != null) </span></span><br><span class="line">						<span class="comment">// 将成为 tryCancel 的出口，而不会因为 continue</span></span><br><span class="line">						<span class="comment">// 使当前线程陷入死循环</span></span><br><span class="line">                        s.tryCancel();</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 减小自旋计数，直到</span></span><br><span class="line">                <span class="keyword">if</span> (spins &gt; <span class="number">0</span>)</span><br><span class="line">                    spins = shouldSpin(s) ? (spins-<span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">				<span class="comment">// 自旋次数已经足够了，设置 s 的 waiter 为当前线程</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="keyword">null</span>)</span><br><span class="line">                    s.waiter = w; <span class="comment">// establish waiter so can park next iter</span></span><br><span class="line">				<span class="comment">// 没有设置超时，直接 park</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!timed)</span><br><span class="line">                    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">				<span class="comment">// 否则，依时间进行 park</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)</span><br><span class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="take-过程"><a href="#take-过程" class="headerlink" title="take 过程"></a>take 过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Object e = transferer.transfer(<span class="keyword">null</span>, <span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> (E)e;</span><br><span class="line">    Thread.interrupted();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">     <span class="function">Object <span class="title">transfer</span><span class="params">(Object e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1) s: mode = REQUEST, </span></span><br><span class="line">         SNode s = <span class="keyword">null</span>; <span class="comment">// constructed/reused as needed</span></span><br><span class="line">         <span class="keyword">int</span> mode = (e == <span class="keyword">null</span>) ? REQUEST : DATA;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">             SNode h = head;</span><br><span class="line">             <span class="keyword">if</span> (h == <span class="keyword">null</span> || h.mode == mode) &#123;  <span class="comment">// empty or same-mode</span></span><br><span class="line">                 <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>) &#123;      <span class="comment">// can't wait</span></span><br><span class="line">                     <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.isCancelled())</span><br><span class="line">                         casHead(h, h.next);     <span class="comment">// pop cancelled node</span></span><br><span class="line">                     <span class="keyword">else</span></span><br><span class="line">                         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                 &#125; <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s = snode(s, e, h, mode))) &#123;</span><br><span class="line">			<span class="comment">// B. 在 A 处的 tryMatch 会将 fulfill 的结点唤醒</span></span><br><span class="line">			<span class="comment">// 下面的方法将会返回</span></span><br><span class="line">                     SNode m = awaitFulfill(s, timed, nanos);</span><br><span class="line">			<span class="comment">// 如果是正常返回的话，m = s.next, </span></span><br><span class="line">			<span class="comment">// 所以 应该有 m != s， 但是，如果 m==s, 则说明</span></span><br><span class="line">			<span class="comment">// awaitFulfill 这个方法返回的原因是 s 结点被cancell</span></span><br><span class="line">			<span class="comment">// 而不是被 fulfill , 所以 调用 clean 进行清理。</span></span><br><span class="line">                     <span class="keyword">if</span> (m == s) &#123;               <span class="comment">// wait was cancelled</span></span><br><span class="line">                         clean(s);</span><br><span class="line">                         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">if</span> ((h = head) != <span class="keyword">null</span> &amp;&amp; h.next == s)</span><br><span class="line">                         casHead(h, s.next);     <span class="comment">// help s's fulfiller</span></span><br><span class="line">			<span class="comment">// 返回 数据</span></span><br><span class="line">                     <span class="keyword">return</span> (mode == REQUEST) ? m.item : s.item;</span><br><span class="line">                 &#125;</span><br><span class="line">	<span class="comment">// h.mode = DATA , isFulfilling 返回 false,</span></span><br><span class="line">	<span class="comment">// 所以进入下面的循环，进入下面循环之后，会将 head 指向正在</span></span><br><span class="line">	<span class="comment">// fulfill 的结点，而这个结点的 mode 将会是 FULFILLING|mode</span></span><br><span class="line">	<span class="comment">// 则此时下面的调用 isFulfilling 将返回 true, </span></span><br><span class="line">	<span class="comment">// 所以这个if也不会进入。执行流程跳转到了最后的 else 语句</span></span><br><span class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isFulfilling(h.mode)) &#123; <span class="comment">// try to fulfill</span></span><br><span class="line">	<span class="comment">// 在开始 take （取元素之前判断，head元素是否已经被 cancell）</span></span><br><span class="line">	<span class="comment">// 如果被 cancell, 则调整head,</span></span><br><span class="line">                 <span class="keyword">if</span> (h.isCancelled())            <span class="comment">// already cancelled</span></span><br><span class="line">			<span class="comment">// 因为在 外层的循环中，所以casHead最终会执行成功，</span></span><br><span class="line">                     casHead(h, h.next);         <span class="comment">// pop and retry</span></span><br><span class="line">		<span class="comment">// 经过上面的head调整，将所有已经被 cancell的结点全部</span></span><br><span class="line">		<span class="comment">// 移除了，此时的 h 指向的一定不是被标记为移除的结点</span></span><br><span class="line">		<span class="comment">// FULFILLING|mode = 2|0 = 2</span></span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s=snode(s, e, h, FULFILLING|mode))) &#123;</span><br><span class="line">                     <span class="keyword">for</span> (;;) &#123; <span class="comment">// loop until matched or waiters disappear</span></span><br><span class="line">                         SNode m = s.next;       <span class="comment">// m is s's match</span></span><br><span class="line">                         <span class="keyword">if</span> (m == <span class="keyword">null</span>) &#123;        <span class="comment">// all waiters are gone</span></span><br><span class="line">                             casHead(s, <span class="keyword">null</span>);   <span class="comment">// pop fulfill node</span></span><br><span class="line">                             s = <span class="keyword">null</span>;           <span class="comment">// use new node next time</span></span><br><span class="line">                             <span class="keyword">break</span>;              <span class="comment">// restart main loop</span></span><br><span class="line">                         &#125;</span><br><span class="line">				<span class="comment">// 将当前结点与下一个结点，组合，</span></span><br><span class="line">                         SNode mn = m.next;</span><br><span class="line">				<span class="comment">// 如果 match成功，其实就是一个 put 和 take 操作</span></span><br><span class="line">				<span class="comment">// s &lt;==&gt; take, m &lt;==&gt; put 操作</span></span><br><span class="line">				<span class="comment">// 其实 s 和 m,到底谁是 take ,put</span></span><br><span class="line">				<span class="comment">// 并不一定，可以由其 mode 字段来判定，</span></span><br><span class="line">				<span class="comment">// A. 这里 tryMatch 会将 block的线程unpark</span></span><br><span class="line">				<span class="comment">// m 结点对应的线程，将在上面的 awaitFulfill 方法</span></span><br><span class="line">				<span class="comment">// 处被唤醒</span></span><br><span class="line">                         <span class="keyword">if</span> (m.tryMatch(s)) &#123;</span><br><span class="line">				<span class="comment">// 将 s 结点 和 m 结点，一起 pop 出 stack</span></span><br><span class="line">                             casHead(s, mn);     <span class="comment">// pop both s and m</span></span><br><span class="line">                             <span class="keyword">return</span> (mode == REQUEST) ? m.item : s.item;</span><br><span class="line">                         &#125; <span class="keyword">else</span>                  <span class="comment">// lost match</span></span><br><span class="line">                             s.casNext(m, mn);   <span class="comment">// help unlink</span></span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">	<span class="comment">// 这个 else中头部的结点正在被 fulfill ,</span></span><br><span class="line">	<span class="comment">// 当前线程，并不会，将当前 s 结点 入栈，而是</span></span><br><span class="line">	<span class="comment">// 帮助， h ,进行 match,可以看到下面的代码和</span></span><br><span class="line">	<span class="comment">// 和上面的 for 循环类似，最后，当前的 fulfill 一定会成功，</span></span><br><span class="line">	<span class="comment">// 成功之后，s 结点，才会开始被处理，处理流程类似</span></span><br><span class="line">	<span class="comment">// 其实就是上面的两个过程： 如果 mode 相同，则 block</span></span><br><span class="line">	<span class="comment">// 否则开始 fulfill.</span></span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;                            <span class="comment">// help a fulfiller</span></span><br><span class="line">                 SNode m = h.next;               <span class="comment">// m is h's match</span></span><br><span class="line">                 <span class="keyword">if</span> (m == <span class="keyword">null</span>)                  <span class="comment">// waiter is gone</span></span><br><span class="line">                     casHead(h, <span class="keyword">null</span>);           <span class="comment">// pop fulfilling node</span></span><br><span class="line">                 <span class="keyword">else</span> &#123;</span><br><span class="line">                     SNode mn = m.next;</span><br><span class="line">                     <span class="keyword">if</span> (m.tryMatch(h))          <span class="comment">// help match</span></span><br><span class="line">                         casHead(h, mn);         <span class="comment">// pop both h and m</span></span><br><span class="line">                     <span class="keyword">else</span>                        <span class="comment">// lost match</span></span><br><span class="line">                         h.casNext(m, mn);       <span class="comment">// help unlink</span></span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>transfer的过程</p>
<p>队列中的block元素mode一定是全部都是相同的，只有栈顶的 node 有可能不同，如果栈顶的node的mode和栈内的node不同，则，此时，可以进行 fulfill 了，fulfill 成功之后，一对 put 和 take 操作将出栈。线程就从 transfer 方法退出了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123; <span class="comment">// loop until matched or waiters disappear</span></span><br><span class="line"></span><br><span class="line">    SNode m = s.next;       <span class="comment">// m is s's match</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 表示已经循环到栈底了，所以</span></span><br><span class="line">	<span class="comment">// all waiters are gone pop fulfill node</span></span><br><span class="line">	<span class="comment">// 所以使用 casHead 将 stack 重置（head 设置成 null）</span></span><br><span class="line">	<span class="comment">// s = null 这条语句应该是 help for GC</span></span><br><span class="line">    <span class="keyword">if</span> (m == <span class="keyword">null</span>) &#123;        <span class="comment">// all waiters are gone</span></span><br><span class="line">        casHead(s, <span class="keyword">null</span>);   <span class="comment">// pop fulfill node</span></span><br><span class="line">        s = <span class="keyword">null</span>;           <span class="comment">// use new node next time</span></span><br><span class="line">        <span class="keyword">break</span>;              <span class="comment">// restart main loop</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找到 m 的 next 结点</span></span><br><span class="line">    SNode mn = m.next;</span><br><span class="line">    <span class="keyword">if</span> (m.tryMatch(s)) &#123; <span class="comment">// 尝试匹配 m 和 s</span></span><br><span class="line">		<span class="comment">// 如果成功，将 s 和 m 弹出栈，</span></span><br><span class="line">        casHead(s, mn);     <span class="comment">// pop both s and m</span></span><br><span class="line">		<span class="comment">// 如果 s.mode == REQUEST, 则 m 结点应该是 put 操作，</span></span><br><span class="line">		<span class="comment">// 所以 返回 m.item, 否则 s 是 put 结点，则返回 s.item</span></span><br><span class="line">		<span class="comment">// 由此可知，不管是 put 还是 take 的 transfer 操作都将</span></span><br><span class="line">		<span class="comment">// 返回 操作的 item</span></span><br><span class="line">        <span class="keyword">return</span> (mode == REQUEST) ? m.item : s.item;</span><br><span class="line">    &#125; <span class="keyword">else</span>                  <span class="comment">// lost match</span></span><br><span class="line">        s.casNext(m, mn);   <span class="comment">// help unlink</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryMatch</span><span class="params">(SNode s)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 所有并发调用 put 和 take 的线程，最终将按照调用的时间顺序</span></span><br><span class="line">	<span class="comment">// 进入 stack 中，所以，其实对于下面的方法，对于具体的某个结点</span></span><br><span class="line">	<span class="comment">// 是没有竞争的，所以下面的compareAndSwapObject方法调用一般都会直接成功</span></span><br><span class="line">    <span class="keyword">if</span> (match == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, matchOffset, <span class="keyword">null</span>, s)) &#123;</span><br><span class="line">        Thread w = waiter;</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="keyword">null</span>) &#123;    <span class="comment">// waiters need at most one unpark</span></span><br><span class="line">            waiter = <span class="keyword">null</span>;</span><br><span class="line">			<span class="comment">// 唤醒线程 w</span></span><br><span class="line">            LockSupport.unpark(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> match == s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用场景参考：</p>
<p><a href="http://www.oschina.net/translate/implementing-producer-consumer-using-synchronousqueue" target="_blank" rel="noopener">使用 SynchronousQueue 实现生产者/消费者模型</a></p>
</div><div class="tags"><a href="/tags/BlockingQueue/">BlockingQueue</a><a href="/tags/SynchronousQueue/">SynchronousQueue</a></div><div class="post-nav"><a class="pre" href="/2016/08/08/并发容器-BlockingQueue(4)-PriorityBlockingQueue/">PriorityBlockingQueue</a><a class="next" href="/2016/08/03/并发容器-BlockingQueue(2)-LinkedBlockingQueue/">并发容器-BlockingQueue(2)-LinkedBlockingQueue</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/interface/" style="font-size: 15px;">interface</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/Collections/" style="font-size: 15px;">Collections</a> <a href="/tags/Collection/" style="font-size: 15px;">Collection</a> <a href="/tags/J-U-C/" style="font-size: 15px;">J.U.C</a> <a href="/tags/lock/" style="font-size: 15px;">lock</a> <a href="/tags/Semaphore/" style="font-size: 15px;">Semaphore</a> <a href="/tags/CountDownLatch/" style="font-size: 15px;">CountDownLatch</a> <a href="/tags/CyclicBarrier/" style="font-size: 15px;">CyclicBarrier</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/LinkedList/" style="font-size: 15px;">LinkedList</a> <a href="/tags/Queue/" style="font-size: 15px;">Queue</a> <a href="/tags/Set/" style="font-size: 15px;">Set</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/collection/" style="font-size: 15px;">collection</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/api/" style="font-size: 15px;">api</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/mvc/" style="font-size: 15px;">mvc</a> <a href="/tags/context/" style="font-size: 15px;">context</a> <a href="/tags/component-scan/" style="font-size: 15px;">component-scan</a> <a href="/tags/storm/" style="font-size: 15px;">storm</a> <a href="/tags/windows/" style="font-size: 15px;">windows</a> <a href="/tags/命令行/" style="font-size: 15px;">命令行</a> <a href="/tags/cmder/" style="font-size: 15px;">cmder</a> <a href="/tags/win/" style="font-size: 15px;">win</a> <a href="/tags/效率/" style="font-size: 15px;">效率</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/博客/" style="font-size: 15px;">博客</a> <a href="/tags/apache/" style="font-size: 15px;">apache</a> <a href="/tags/extends/" style="font-size: 15px;">extends</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/svn/" style="font-size: 15px;">svn</a> <a href="/tags/BlockingQueue/" style="font-size: 15px;">BlockingQueue</a> <a href="/tags/LinkedBlockingQueue/" style="font-size: 15px;">LinkedBlockingQueue</a> <a href="/tags/PriorityBlockingQueue/" style="font-size: 15px;">PriorityBlockingQueue</a> <a href="/tags/ConcurrentLinkedQueue/" style="font-size: 15px;">ConcurrentLinkedQueue</a> <a href="/tags/CopyOnWriteArrayList/" style="font-size: 15px;">CopyOnWriteArrayList</a> <a href="/tags/接口/" style="font-size: 15px;">接口</a> <a href="/tags/抽象类/" style="font-size: 15px;">抽象类</a> <a href="/tags/Executor/" style="font-size: 15px;">Executor</a> <a href="/tags/ExecutorService/" style="font-size: 15px;">ExecutorService</a> <a href="/tags/CompletionService/" style="font-size: 15px;">CompletionService</a> <a href="/tags/ThreadPoolExecutor/" style="font-size: 15px;">ThreadPoolExecutor</a> <a href="/tags/vim/" style="font-size: 15px;">vim</a> <a href="/tags/vundle/" style="font-size: 15px;">vundle</a> <a href="/tags/ArrayList/" style="font-size: 15px;">ArrayList</a> <a href="/tags/log/" style="font-size: 15px;">log</a> <a href="/tags/index/" style="font-size: 15px;">index</a> <a href="/tags/concepts/" style="font-size: 15px;">concepts</a> <a href="/tags/Timer/" style="font-size: 15px;">Timer</a> <a href="/tags/TimerTask/" style="font-size: 15px;">TimerTask</a> <a href="/tags/ConcurrentMap/" style="font-size: 15px;">ConcurrentMap</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 15px;">ConcurrentHashMap</a> <a href="/tags/HashMap/" style="font-size: 15px;">HashMap</a> <a href="/tags/ReentrantReadWriteLock/" style="font-size: 15px;">ReentrantReadWriteLock</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/SynchronousQueue/" style="font-size: 15px;">SynchronousQueue</a> <a href="/tags/ScheduledExecutorService/" style="font-size: 15px;">ScheduledExecutorService</a> <a href="/tags/AQS/" style="font-size: 15px;">AQS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/BigData-docker/">Windows 上安装 docker</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/mysql-0.路线/">Mysql学习路线</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/mysql-索引/">Mysql安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/Qunar基础框架-QSchedule/">Qunar基础框架-QSchedule</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/java集合构架中使用到的数据结构和算法/">java集合构架中使用到的数据结构和算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/20/reids-调试环境搭建/">redis-调试环境搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/31/OpenStack-安装/">OpenStack-安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/26/JVM-hotspot-GC机制/">JVM-hotspot-GC机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/11/netty-socketio + socket.io 实现消息推送/">netty-socketio + socket.io 实现消息推送</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/26/mongodb-安装/">mongodb-安装</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/a-ray-of-sunshine" title="github" target="_blank">github</a><ul></ul><a href="http://www.cnblogs.com/a-ray-of-sunshine" title="cnblog" target="_blank">cnblog</a><ul></ul><a href="http://blog.csdn.net/a_ray_of_sunshine" title="csdn" target="_blank">csdn</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Shawshank.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>