<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>J.U.C(3)-AQS实现 | Shawshank</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">J.U.C(3)-AQS实现</h1><a id="logo" href="/.">Shawshank</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">J.U.C(3)-AQS实现</h1><div class="post-meta">Jul 19, 2016</div><div class="post-content"><p>AbstractQueuedSynchronizer是实现锁的关键，Doug Lea关于实现这个类的论文： <a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf" target="_blank" rel="noopener">The java.util.concurrent Synchronizer Framework</a></p>
<p>论文中的第3节描述了，AbstractQueuedSynchronizer 的设计和实现过程。</p>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>对于一个同步器（synchronzier），最基本的操作有两个：acquired(获取锁) 和 release（释放锁）</p>
<ul>
<li><p>acquired</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while (synchronization state does not allow acquire) &#123;</span><br><span class="line">	enqueue current thread if not already queued;</span><br><span class="line">	possibly block current thread;</span><br><span class="line">&#125;</span><br><span class="line">dequeue current thread if it was queued;</span><br></pre></td></tr></table></figure>
</li>
<li><p>release</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update synchronization state;</span><br><span class="line">if (state may permit a blocked thread to acquire)</span><br><span class="line">unblock one or more queued threads;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这实现上面的功能，则必须有三个基本的组件（component）:</p>
<ul>
<li><p>Atomically　managing synchronization state</p>
</li>
<li><p>Blocking and unblocking threads</p>
</li>
<li><p>Maintaining queues</p>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="Synchronization-State"><a href="#Synchronization-State" class="headerlink" title="Synchronization State"></a>Synchronization State</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">        state = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>state 字段是 volatile 的，保证的其内存可见性，使用 compareAndSetState 方法（CAS）来保证原子性，所以使用 state 是线程安全的。</p>
<p>对于改变 state 字段其实有两个方法：</p>
<ul>
<li><p>setState</p>
</li>
<li><p>compareAndSetState</p>
</li>
</ul>
<p>其实，提供两个更新 state 的方法是，基于 同步 和 性能 的考虑：当在确定当前线程是锁的拥有者时，直接使用 setState 方法可以提高性能（例如：tryRelease方法中，可以直接使用setState，因为此时，当前线程一定是锁的owner。还有就是请求锁重入的时候，也可以直接使用），当无法确定当前线程是否拥有锁时，使用 compareAndSetState，来保证 state 是同步的。</p>
<p>基于 AbstractQueuedSynchronizer 类的 同步器 的实现，必须 override 其 tryAcquire 和 tryRelease 方法。这两个方法都有一个 int 类型的参数，可以根据这个参数和当前 state 字段的值 来确定 同步器 对锁的获取和释放的行为，从而使用不同功能的同步器。</p>
<h3 id="Blocking"><a href="#Blocking" class="headerlink" title="Blocking"></a>Blocking</h3><p>在 jdk1.5 之前惟一能让一个线程 block 和 unblock 的方法就是：Thread.suspend 和 Thread.resume，但是这两个方法有可能导致线程死锁，所以已经不能使用了。</p>
<p>jdk1.5 中提供了一个支持线程挂起的类：<br>java.util.concurrent.locks.LockSupport</p>
<p>LockSupport会将使用过它（LockSupport）的线程都会关联一个 permit. 如果当前线程的 permit 是 available 的，则 park 方法的调用将立即返回，    consuming it in the process; 否则线程会 block.</p>
<p>如果线程的 permit 不是 avilable 的，则 unpark 的调用则会使用 permit 变成  avilable 的。</p>
<ul>
<li><p>park</p>
<p>  block 当前线程</p>
<p>  park有以下几种：</p>
<ul>
<li><p>park(Object blocker)</p>
</li>
<li><p>parkNanos(Object blocker, long nanos) </p>
</li>
<li><p>parkUntil(Object blocker, long deadline)</p>
</li>
<li><p>park() </p>
</li>
<li><p>parkNanos(long nanos) </p>
</li>
<li><p>parkUntil(long deadline) </p>
<p>前三个 park 与 后三个惟一不同的就是：多一个 blocker 参数，这个参数的作用是：This object is recorded while the thread is blocked to permit monitoring and diagnostic tools to identify the reasons that threads are blocked. 这个参数用来给调试工具使用。文档中推荐使用前三个API。</p>
<p>调用这个方法</p>
</li>
</ul>
</li>
<li><p>unpark(Thread thread)</p>
<p>  unblock 指定的线程</p>
<p>  使用指定的线程的 permit 变成 available 的。如果线程因为 park 而 block,则此时会 unblock.此外，由于 该线程的 permis is available, 所以 在线程上再次调用 park 将立即返回，而不是 block.</p>
</li>
</ul>
<p>The park method also supports optional relative and absolute timeouts, and is integrated with JVM Thread.interrupt support — interrupting a thread unparks it.</p>
<p>park方法是可以被中断的。中断之后，线程会 unpark.</p>
<h3 id="Queues"><a href="#Queues" class="headerlink" title="Queues"></a>Queues</h3><p>同步框架的核心就是 阻塞线程队列 的维护。这个队列是 FIFO的，同步框架不支持基于优先级的同步。</p>
<p>实现使用 CLH queue</p>
<h3 id="Conditions-Queues"><a href="#Conditions-Queues" class="headerlink" title="Conditions Queues"></a>Conditions Queues</h3><h2 id="ReentrantLock-实现"><a href="#ReentrantLock-实现" class="headerlink" title="ReentrantLock 实现"></a>ReentrantLock 实现</h2><h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h3><ul>
<li><p>java.util.concurrent.locks.ReentrantLock.NonfairSync.lock</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>首先，尝试立即获取锁，如果，注意参数 compareAndSetState(0, 1)， 表示这个调用返回true的，惟一条件就是：这个锁lock的 state 字段是0，才会成功，否则，调用 acquire 获取锁。
</code></pre><ul>
<li>java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这个方法接受一个int参数，这个参数对于AbstractQueuedSynchronizer来说并没有具体的含义，此参数会直接传递给，具体的 Synchronizer 实现类的 override 的 tryAcquire 方法。所以，这个参数其实就是由具体的实现类决定其含义的。</p>
<p>文档描述：以独占模式请求锁，忽略中断。至少调用一次 tryAcquire，如果成功则这个方法直接返回。否则，当前线程（调用acquire方法的线程）将会进入请求队列，并可能重复的 blocking and unblocking, 直到 tryAcquire 调用成功。</p>
<p><strong>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</strong></p>
<p><strong>addWaiter 是 lock-free 的方法，所以对于 上面的调用，acuireQueued中 addWaiter(Node.EXCLUSIVE) 中返回的node其实有可能已经不是处于 tail 了（在 addWaiter 方法中始终将当前的node 放置到queue的 tail. 由于 addWaiter的并发，），所以当 acquireQueued 执行的时候传递进去的 node ，其实已经不在 tail 位置了。</strong></p>
<ul>
<li><p>tryAcquire</p>
<p>  <strong>AbstractQueuedSynchronizer类定义了这个方法，但是没有实现，这个方法就是实现各个功能的锁的核心，这个方法的作用就是，判定当前线程是否应该获得锁 ，如果可以返回 true, 否则返回 false。子类通过不同的逻辑判定线程是否可以获取锁，就可以实现各种功能的锁。</strong></p>
</li>
</ul>
<pre><code>ReentrantLock 的内部类Sync实现的  tryAcquire 直接调用了下面的方法

java.util.concurrent.locks.ReentrantLock.Sync.nonfairTryAcquire

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 尝试一次，是否可以直接获取</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否是同一个线程再次获取锁，支持可重入</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// 由此可知在 ReentrantLock 的实现中，</span></span><br><span class="line">        <span class="comment">// state 字段还表示，当前持有锁的线程的重入次数</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上面两种尝试都未成功表示，线程获取锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><p>由上面的代码可知，ReentrantLock 支持可重入，所以对于 AbstractQueuedSynchronizer 所维护的 queue 中的 Node 和 所以 请求锁的线程是1：1（一一对应）。每一个Thread在queue只有惟一一个node和其对应。</p>
<p>由 acquire 的实现可知：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br></pre></td></tr></table></figure>
<p>如果 tryAcquire 方法获取锁成功，则返回 true, 上面的表达将不再执行，acquire方法就返回。如果锁获取失败，则将使用 addWaiter 方法将当前请求线程以 exclusive 模式的 Node 结点添加到 请求队列的尾部。然后，将返回代表当前线程的Node 对象，作为参数传递给 acquireQueued 方法，而这个方法将会使用当前线程在queue中等待获取锁。具体分析，如下：</p>
<ul>
<li><p>java.util.concurrent.locks.AbstractQueuedSynchronizer.addWaiter</p>
<p>  将当前线程添加到请求队列的 tail 处。整个添加过程使用 CAS 来确保线程安全。添加成功之后将这个 node 返回。</p>
</li>
<li><p>java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued</p>
</li>
</ul>
<p>这个方法有两个参数：</p>
<ol>
<li><p>node: 这个 node 始终代表当前线程。node.thread == Thread.currentThread()</p>
</li>
<li><p>arg 传递给 tryAcquire</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        	<span class="comment">// 获得 当前线程 node 的上一个 node.</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 因为 head 指向的 node 是 dummy 的，所以如果 p == head, 则说明当前 queue 中 node结点已经到头部（但是并不能证明只有当前线程在请求lock,与此同时可能还有其它线程刚好请求锁，所以这个条件判断成功之后，并不会直接将锁给当前线程，而是使用tryAcquire方法来获取锁）, 然后调用 tryAcquire，如果成功进入if代码块中</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 把当前node从队列中移除</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 因为当前结点（在队列中的最后一个结点）已经获取了锁，所以不需要处理了（调用cancelAcquire方法）</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法其实就是 CLH 锁(是一个 FIFO 的 queue)的一个实现：</p>
<ol start="0">
<li><p>获得当前 node 的前驱结点 p.</p>
<p>  final Node p = node.predecessor();</p>
</li>
<li><p>判断 p == head, 如果相同，则表示，当前结点已经到了这个queue的头部，按照 CLH queue 的算法，这时候，这个线程应该就是锁的拥有者了，但是，存在一种可能就是，当前正有一个线程也在请求锁，但这个线程还未入queue（例如：一个线程正在执行，acquire 方法中的 tryAcquire去获取锁，而这个线程尚未入 queue）,所以不能直接将锁交给 node, 而是调用 tryAcquire 去获取。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">	<span class="comment">// 获取锁成功，当前 node 出队列，</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 p 对 node 的引用 next 断开，for help GC</span></span><br><span class="line">    <span class="comment">// 虽然，上面通过 setHead 将 node 设置为新的 head</span></span><br><span class="line">    <span class="comment">// 但 这里 p 仍旧指向，以前的 head(也就是被移出队列的head)</span></span><br><span class="line">    <span class="comment">// 把它的 next 设置成 null, 减少对 当前 head (node) 的引用</span></span><br><span class="line">    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取锁，成功了，没失败，所以 failed = false</span></span><br><span class="line">    failed = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// interrupted 表示 阻塞返回的原因，也就是</span></span><br><span class="line">    <span class="comment">// parkAndCheckInterrupt 调用返回的原因，当这个方法返回后到</span></span><br><span class="line">    <span class="comment">// acquire中，acquire会根据这个状态，如果 ture,则中断当前线程，</span></span><br><span class="line">    <span class="comment">// 否则，直接成功返回，由此可知锁的获取是可以被中断的。</span></span><br><span class="line">    <span class="keyword">return</span> interrupted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据前驱结点 p 的 waitStatus 状态位来判定是否park</p>
<p> shouldParkAfterFailedAcquire(p, node)</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park. 如果前驱结点，已经被设置成 Node.SIGNAL， 则直接返回 true 表示 node 可以安全park了。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry. 表示 ws == Node.CANCELLED node的前驱结点自身被取消了。所以下面通过循环来进行前向遍历，直到找到未被取消的结点。然后把这个结点作为 node 的新的前驱。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         	</span></span><br><span class="line"><span class="comment">         	waitStatus &lt;= 0 , 则 waitStatus 是 0 或者是 PROPAGATE(-3),</span></span><br><span class="line"><span class="comment">			CONDITION(-2)的结点在 同步队列中是不存在的。将 pred 的 ws 设置成 Node.SIGNAL， 调用者下次调用的时候，直接返回 true. node就会被 block.</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 shouldParkAfterFailedAcquire 是在 acquireQueued 的循环内部调用的，所以 shouldParkAfterFailedAcquire 这执行逻辑应该是这样的。</p>
<ul>
<li><p>第一次循环，调用前继可能被取消了也就是 ws &gt; 0 的情况，这时候，从前继向前遍历，将所以被取消的前继从队列中移除。<strong>这时候，其实 sync queue 发生了结构性修改，所有的 Node.CANCELLED 结点被移出</strong></p>
</li>
<li><p>第二次循环，基本可以确定 ws &lt;= 0了，其实在并发的情况下有可能，上次调整的结点也被取消了。所以，第二次循环的时候，有可能还会出现 ws &gt; 0 的情况，那就继续循环呗。</p>
</li>
</ul>
<ol start="3">
<li><p>如果上面返回 true 则表示，当前线程应该 park，调用parkAndCheckInterrupt方法，使得当前线程 block.</p>
<p> if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</p>
<pre><code>parkAndCheckInterrupt())
</code></pre><p> 到此为止，<strong>所有在 queue 中，但没在头部的 node</strong>（线程者是并发执行的，而且Lock的实现是 lock-free 的，所以，所有的线程都开始进行自旋等待了） 都将进入 park 状态，直到头部的 node 的释放锁。</p>
</li>
</ol>
<p>获取锁的流程：</p>
<ol>
<li><p>尝试锁是否可以被获取，如果可以直接获取返回，否则，进入步骤2.</p>
</li>
<li><p>再次尝试是否可以直接被获取，可以则获取成功。</p>
</li>
<li><p>尝试是否，是同一个线程再次获取，如果是，则成功。</p>
</li>
<li><p>将当前线程添加到请求队列中。</p>
</li>
<li><p>依据 前一个结点 的状态位来，判定是否进行 park</p>
</li>
<li><p>直到 unpark, 然后返回</p>
</li>
</ol>
<h3 id="unlock"><a href="#unlock" class="headerlink" title="unlock"></a>unlock</h3><ul>
<li>java.util.concurrent.locks.AbstractQueuedSynchronizer.release<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>由于，lock方法返回的时候，已经将当前线程，设置为 head, 所以，如果一个线程将持有的锁释放了，就应该通知 queue 中的 head 元素，让其后继结点，参与到锁的竞争中来。由于 后继通常是在 blocking 状态，所以要 调用 unparkSuccessor 对后继结点进行 唤醒 操作。</p>
<ul>
<li>java.util.concurrent.locks.ReentrantLock.Sync.tryRelease<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>ReentrantLock 由于 支持可重入，所以 state 字段，也表示，锁的持有线程的对锁的重入次数，如上面所示，直到，重入为0，时才释放锁，否则unlock，只将是调整重入次数（state）,并不释放锁。返回值代表，锁是否被成功释放。</p>
<ul>
<li><p>unparkSuccessor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread. 如果有后继在当前 node 上等待，则这个状态应该是 Node.SIGNAL ，如果当前 node 没有后继，则这个 状态字段应该是 0. 但是对于这个操作是否成功已经不重要了，因为，随着下面的 unpark 的调用，这个 node 将被 永远地移除，因为它的作用已经完成了：0. 成功获取锁（node 由 head.next 变成 head） 1.下面 unpark 调用 将通知在其上 wait 的 node ( node将被其next取代，node被移除 ), 这两个功能完成，这个 node 就 head 处移除。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor. 如果后继结点是null或者后继被取消了，则从同步队列的 tail 处开始 前向遍历 直到 node 处，找到 node 的真正的后继结点。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最终经过上面的查找，如果后继不为空，则通知后继可以unpark了。后继 unpark 之后，再一次参与到锁的竞争中去。</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>cancelAcquire</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Ignore if node doesn't exist</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// help for GC</span></span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Skip cancelled predecessors</span></span><br><span class="line">    <span class="comment">// 跳过已经被取消的前继，直到 pred.waitStatus &lt;= 0</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line">    <span class="comment">// 上面的代码执行完成之后，node.prev 被直接改成了 pred,</span></span><br><span class="line">    <span class="comment">// 而这个 pred 的 next 元素该如果处理。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// predNext is the apparent node to unsplice. CASes below will</span></span><br><span class="line">    <span class="comment">// fail if not, in which case, we lost race vs another cancel</span></span><br><span class="line">    <span class="comment">// or signal, so no further action is necessary.</span></span><br><span class="line">    <span class="comment">// 如果按照上面的循环处理的话，其实 predNex这个</span></span><br><span class="line">    <span class="comment">// 结点本身是被取消（CANCELLED）的，但是其前继却</span></span><br><span class="line">    <span class="comment">// 是 &lt;= 0 的，所以这个元素，需要特殊处理。</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Can use unconditional write instead of CAS here.</span></span><br><span class="line">    <span class="comment">// After this atomic step, other Nodes can skip past us.</span></span><br><span class="line">    <span class="comment">// Before, we are free of interference（干扰） from other threads.</span></span><br><span class="line">    <span class="comment">// 将 node 结点设置成 取消的。</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are the tail, remove ourselves.</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">    	<span class="comment">// 如果 node 是 最后一个结点，则直接将 pred</span></span><br><span class="line">    	<span class="comment">// 设置成 tail,然后，将其 tail 的 next 域</span></span><br><span class="line">    	<span class="comment">// 设置成 null</span></span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If successor needs signal, try to set pred's next-link</span></span><br><span class="line">        <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></span><br><span class="line">        <span class="comment">// 由于 node 不是 tail,所以其后面还有结点</span></span><br><span class="line">        <span class="comment">// 需要被通知，所以 1. 设置 pred 的域为</span></span><br><span class="line">        <span class="comment">// Node.SIGNAL, </span></span><br><span class="line">        <span class="comment">// 2. 将 node 的 next 接到 pred 的 next 域</span></span><br><span class="line">        <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">// 唤醒后继</span></span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>Node 中的 waitStatus 字段，5个字段。</p>
<ul>
<li><p>SIGNAL（-1）: 表示线程的successor线程需要被unparking </p>
<p>  表示这个node的后继者（successor）是(将会是)blocked的（通过使用 park 方法），所以当前node在release或cancel锁的时候，必须unpark它的successor。</p>
<p>  To avoid races, acquire methods must first indicate they need a signal, then retry the atomic acquire, and then, on failure, block.</p>
</li>
<li><p>CANCELLED（1）: 表示线程被取消</p>
<p>  因为超时或者中断，这个node被取消了。</p>
</li>
<li><p>CONDITION（-2）： 表示线程在条件上等待</p>
<p>  这个node当前在一个condition 队列中。它不会被当作同步队列结点（sync queue node）,直到被 transferred（转移，调动），与此同时这个结点的 waitStatus 会被设置成 0.</p>
</li>
<li><p>PROPAGATE（传播，-3）： 表示下一个 acquireShared 应该被无条件的传播。</p>
</li>
</ul>
<p>Status field, taking on only the values: </p>
<p>SIGNAL: The successor of this node is (or will soon be) blocked (via park), so the current node must unpark its successor when it releases or cancels. <strong>To avoid races, acquire methods must first indicate they need a signal, then retry the atomic acquire, and then, on failure, block.</strong> </p>
<p>SIGNAL: 当前结点的后继结点正在（或将会）被阻塞（通过park）,所以当 当前结点 在 release 或者 cancel 锁时，必须 unpark 其后继结点。</p>
<p>CANCELLED: This node is cancelled due to timeout or interrupt. Nodes never leave this state. In particular, a thread with cancelled node never again blocks. </p>
<p>CANCELLED: 这个结点因为超时或者中断被取消了。结点一般不会保留这个状态状态。事实上，被取消的线程将不会再被 block. </p>
<p>CONDITION: This node is currently on a condition queue. It will not be used as a sync queue node until transferred, at which time the status will be set to 0. (Use of this value here has nothing to do with the other uses of the field, but simplifies mechanics.) </p>
<p>CONDITION: 这个结点当前处于条件队列中。在被 transferred 之前，它不会被当前 同步队列 中的结点。transferred 之后，这个状态位会被设置成 0</p>
<p>PROPAGATE: A releaseShared should be propagated to other nodes. This is set (for head node only) in doReleaseShared to ensure propagation continues, even if other operations have since intervened. </p>
<p>PROPAGATE: </p>
<p>0: None of the above </p>
<p>The values are arranged numerically to simplify use. Non-negative values mean that a node doesn’t need to signal. So, most code doesn’t need to check for particular values, just for sign. </p>
<p>waitStatus的取值都是数字类型是为了简化操作。当一个结点的该值为 waitStatus &gt; 0 时，表示这个结点不需要被 signal. 所以在代码中一般不需要检查某个特殊的值，只需要判断其符号即可。</p>
<p>The field is initialized to 0 for normal sync nodes, and CONDITION for condition nodes. It is modified using CAS (or when possible, unconditional volatile writes).</p>
<p>对于普通的 sync node 这个字段的默认初始值是 0.<br>对于 condition node 这个字段的默认初始值是 CONDITION. 这个字段在被修改时使用CAS，保证原子性。</p>
<h2 id="java-util-concurrent-locks-AbstractQueuedSynchronizer-ConditionObject"><a href="#java-util-concurrent-locks-AbstractQueuedSynchronizer-ConditionObject" class="headerlink" title="java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject"></a>java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p>这个类实现了 Condition 接口</p>
<h3 id="java-util-concurrent-locks-Condition"><a href="#java-util-concurrent-locks-Condition" class="headerlink" title="java.util.concurrent.locks.Condition"></a>java.util.concurrent.locks.Condition</h3><p>Condition 接口将原来的 Object 的 monitor 方法（wait, notify and notifyAll）分离了出来，使得其和 Lock 对象独立。Lock 接口替代了 synchronized 方法和语句块，而 Condition 接口替代了 Object 对象的 monitor methods。</p>
<p>Conditions（也被称为 condition queue 或者 condition variables）提供了一种挂起线程的操作，直到其它的线程通知它可以继续了。</p>
<p>The key property that waiting for a condition provides is that it atomically releases the associated lock and suspends the current thread, just like Object.wait. </p>
<p>当在一个 condition 等待（wait）的时候，它其自动释放相关联的锁，然后挂起线程。就像 Object.wait 的行为那样。</p>
<p>condition的实例是内置于 lock中的。所以要获取一个condition,就需要调用 Lock 的 newCondition 方法。</p>
<h4 id="对象结构"><a href="#对象结构" class="headerlink" title="对象结构"></a>对象结构</h4><p><strong>ConditionObject在使用时是天然线程安全的，因为它在lock的包围之中</strong></p>
<p>关于 ConditionObject 的结构：ConditionObject 一个的使用在锁内部使用的，当一个对象调用 await 进行等待时，当前线程会放弃锁，而其它获得锁的线程，也有可以调用 锁的 ConditionObject 的方法，这样就会有多个线程在一个 条件对象 上等待，那这多个 等待对象 如果安置呢？ Node 对象有一个 </p>
<pre><code>Node nextWaiter;
</code></pre><p>这个字段用来，构成一个单向链表，按时间顺序保存所有在这个条件对象上等待的线程。</p>
<p>ConditionObject对象中的 </p>
<ul>
<li><p>firstWaiter 指向 First node of condition queue.</p>
</li>
<li><p>lastWaiter 指向 Last node of condition queue. </p>
</li>
</ul>
<h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><p>使用当前线程处于，等待状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 将当前线程放置到 condition queue 的lastWaiter</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将当前线程拥有的锁释放</span></span><br><span class="line">    <span class="comment">// 返回的线程当前的 state 状态的字段</span></span><br><span class="line">    <span class="comment">// 这个字段必须保存起来，将来等 await</span></span><br><span class="line">    <span class="comment">// 醒来之后，必须恢复这个state字段</span></span><br><span class="line">    <span class="comment">// 这线程的同步状态就正常了。</span></span><br><span class="line">    <span class="comment">// 这里会把，拥有的锁释放！！！</span></span><br><span class="line">    <span class="comment">// 当前线程在 sync 队列中的 node 被移除</span></span><br><span class="line">    <span class="comment">// 相当于将当前的node 从 sync queue转移到 condition queue，当某个线程调用 signal 时，则会</span></span><br><span class="line">    <span class="comment">// 把 node 从 condition queue 再转移到</span></span><br><span class="line">    <span class="comment">// sync queue 中。</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// isOnSyncQueue 方法 返回 false</span></span><br><span class="line">    <span class="comment">// 所以进入下面的循环, </span></span><br><span class="line">    <span class="comment">// 当其它线程调用 signal 方法,方法</span></span><br><span class="line">    <span class="comment">// park 方法返回，node的状态也应该</span></span><br><span class="line">    <span class="comment">// 发生变化了，然后 isOnSyncQueue 返回 ture</span></span><br><span class="line">    <span class="comment">// 这个 while 循环结束，</span></span><br><span class="line">    <span class="comment">// 退出，等待了。</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">    	<span class="comment">// block 当前线程</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 如果 park 是正常被某个线程signal而</span></span><br><span class="line">        <span class="comment">// 唤醒的话，node 结点应该已经从 condition</span></span><br><span class="line">       <span class="comment">// queue 中转换到 sync queue 中，</span></span><br><span class="line">       <span class="comment">// 所以在上面，要进行判断 node 的状态判断</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检测在 wait 过程中当前线程是否被</span></span><br><span class="line">        <span class="comment">// 中断，如果被中断，则 break;</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 前面，释放了锁，而对于 await 方法来说</span></span><br><span class="line">    <span class="comment">// 醒来之后必须，重新获取锁才可以，继续执行</span></span><br><span class="line">    <span class="comment">// 因为，await 方法调用是在，lock 保护的临界区</span></span><br><span class="line">    <span class="comment">// 所以，需要调用 acquireQueued ，方法将当前</span></span><br><span class="line">    <span class="comment">// 线程重新进入 sync queue 进行锁竞争，</span></span><br><span class="line">    <span class="comment">// savedState 非常重要，使用当前线程恢复到原来</span></span><br><span class="line">    <span class="comment">// (await方法调用之前)的状态，后续可以使用 </span></span><br><span class="line">    <span class="comment">// unlock 解锁线程。不然，后面代码的 unlock </span></span><br><span class="line">    <span class="comment">// 调用会出问题</span></span><br><span class="line">    <span class="comment">// acquireQueued 相当于 lock,此时线程，参与</span></span><br><span class="line">    <span class="comment">// sync queue 中线程的锁竞争。</span></span><br><span class="line">    <span class="comment">// 在 condition queue 中，wait 的线程，不会</span></span><br><span class="line">    <span class="comment">// 更改全局锁的 state ，wait 之后将其恢复。</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果在这个 condition 上，还有其它 waiter</span></span><br><span class="line">    <span class="comment">// 则将其中已经 cancelled 的 node,从 condition</span></span><br><span class="line">    <span class="comment">// queue 中移除。</span></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>addConditionWaiter</li>
</ul>
<p>Node node = new Node(Thread.currentThread(), Node.CONDITION);</p>
<p>其中，新添加的 node 的 waitStates 是 Node.CONDITION</p>
<ul>
<li>fullyRelease</li>
</ul>
<p>核心代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> savedState = getState();</span><br><span class="line">release(savedState)</span><br><span class="line"><span class="keyword">return</span> savedState</span><br></pre></td></tr></table></figure></p>
<p>release通过传递参数 savedState，使得当前线程拥有的锁释放。注意，如果是重入的锁，这个调用也会将其release所以这个方法名为： fullyRelase.</p>
<ul>
<li>isOnSyncQueue</li>
</ul>
<p>判断 node 是否已经被转移到 sync queue 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 0. 未被被 signal 之前，node.waitStatus 始终是</span></span><br><span class="line">	<span class="comment">// Node.CONDITION</span></span><br><span class="line">	<span class="comment">// 1. 如果 node 被 入队列了，则其 prev 字段</span></span><br><span class="line">	<span class="comment">// 一定不是空的</span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 有后继也表明，一定已经在队列中了。    </span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) <span class="comment">// If has successor, it must be on queue</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * node.prev can be non-null, but not yet on queue because</span></span><br><span class="line"><span class="comment">     * the CAS to place it on queue can fail. So we have to</span></span><br><span class="line"><span class="comment">     * traverse from tail to make sure it actually made it.  It</span></span><br><span class="line"><span class="comment">     * will always be near the tail in calls to this method, and</span></span><br><span class="line"><span class="comment">     * unless the CAS failed (which is unlikely), it will be</span></span><br><span class="line"><span class="comment">     * there, so we hardly ever traverse much.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">// node.prev 是 非空的时候，并不能确保，node</span></span><br><span class="line">     <span class="comment">// 已经在 queue 中了，原因如上。所以使用</span></span><br><span class="line">     <span class="comment">// 调用 findNodeFromTail 从尾到头，查找 node</span></span><br><span class="line">     <span class="comment">// 是否存在，如果存在返回true,否则返回false.</span></span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果当前线程不是锁的拥有者，返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">   <span class="comment">// 通知在 conditon queue 中的第一个</span></span><br><span class="line">   <span class="comment">// wait 的线程可以 unpark 了，然后可以可以参与锁</span></span><br><span class="line">   <span class="comment">// 的竞争。</span></span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="doSignal"><a href="#doSignal" class="headerlink" title="doSignal"></a>doSignal</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 first 结点开始后向遍历，直到，某一个结点上 transferForSignal 方法调用成功。最终，firstWaiter字段指向前面被通知的结点的 nextWaiter.</p>
<h4 id="transferForSignal"><a href="#transferForSignal" class="headerlink" title="transferForSignal"></a>transferForSignal</h4><p><strong>signal要做的惟一的事就是将node从 condition queue 中 转移到 sync queue.</strong></p>
<p>signal的逻辑应该是：</p>
<ol>
<li><p>将当前 在 condition queue 中的 node 转移到 sync<br>queue 中</p>
</li>
<li><p>设置 node 的前继的 waitStates，为 Node.SIGNAL 表示，其后继结点 需要在其上自旋等待。其实就是当前node需要重新请求锁了。</p>
</li>
<li><p>如果 node 的前继，被取消了（ws&gt;0）或者 2 中的设置失败，直接强制 unpark 线程。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If cannot change waitStatus, the node has been cancelled.</span></span><br><span class="line"><span class="comment">     * 如果不能改变当前 node 的 status, 直接返回 false,惟一的原因应该是 这个结点被 取消了</span></span><br><span class="line"><span class="comment">     将 node 的 waitStatus 设置成0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Splice onto queue and try to set waitStatus of predecessor to</span></span><br><span class="line"><span class="comment">     * indicate that thread is (probably) waiting. If cancelled or</span></span><br><span class="line"><span class="comment">     * attempt to set waitStatus fails, wake up to resync (in which</span></span><br><span class="line"><span class="comment">     * case the waitStatus can be transiently and harmlessly wrong).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">// 如果代码，执行到这里则，则 node 一定是</span></span><br><span class="line">     <span class="comment">// 没有被取消</span></span><br><span class="line">    <span class="comment">// 将 node 加入到 sync queue 队列，并返回 node 的前继</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="comment">// 返回的p是node的前继</span></span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果 node 的前继，被取消了（ws&gt;0）</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/J-U-C/">J.U.C</a><a href="/tags/AQS/">AQS</a></div><div class="post-nav"><a class="pre" href="/2016/07/21/接口和抽象类/">接口和抽象类</a><a class="next" href="/2016/07/18/J.U.C(2)-锁/">J.U.C(2)-锁</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/interface/" style="font-size: 15px;">interface</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/Collections/" style="font-size: 15px;">Collections</a> <a href="/tags/Collection/" style="font-size: 15px;">Collection</a> <a href="/tags/J-U-C/" style="font-size: 15px;">J.U.C</a> <a href="/tags/lock/" style="font-size: 15px;">lock</a> <a href="/tags/Semaphore/" style="font-size: 15px;">Semaphore</a> <a href="/tags/CountDownLatch/" style="font-size: 15px;">CountDownLatch</a> <a href="/tags/CyclicBarrier/" style="font-size: 15px;">CyclicBarrier</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/LinkedList/" style="font-size: 15px;">LinkedList</a> <a href="/tags/Queue/" style="font-size: 15px;">Queue</a> <a href="/tags/Set/" style="font-size: 15px;">Set</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/collection/" style="font-size: 15px;">collection</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/api/" style="font-size: 15px;">api</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/mvc/" style="font-size: 15px;">mvc</a> <a href="/tags/context/" style="font-size: 15px;">context</a> <a href="/tags/component-scan/" style="font-size: 15px;">component-scan</a> <a href="/tags/storm/" style="font-size: 15px;">storm</a> <a href="/tags/windows/" style="font-size: 15px;">windows</a> <a href="/tags/命令行/" style="font-size: 15px;">命令行</a> <a href="/tags/cmder/" style="font-size: 15px;">cmder</a> <a href="/tags/win/" style="font-size: 15px;">win</a> <a href="/tags/效率/" style="font-size: 15px;">效率</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/博客/" style="font-size: 15px;">博客</a> <a href="/tags/apache/" style="font-size: 15px;">apache</a> <a href="/tags/extends/" style="font-size: 15px;">extends</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/svn/" style="font-size: 15px;">svn</a> <a href="/tags/BlockingQueue/" style="font-size: 15px;">BlockingQueue</a> <a href="/tags/LinkedBlockingQueue/" style="font-size: 15px;">LinkedBlockingQueue</a> <a href="/tags/PriorityBlockingQueue/" style="font-size: 15px;">PriorityBlockingQueue</a> <a href="/tags/ConcurrentLinkedQueue/" style="font-size: 15px;">ConcurrentLinkedQueue</a> <a href="/tags/CopyOnWriteArrayList/" style="font-size: 15px;">CopyOnWriteArrayList</a> <a href="/tags/接口/" style="font-size: 15px;">接口</a> <a href="/tags/抽象类/" style="font-size: 15px;">抽象类</a> <a href="/tags/Executor/" style="font-size: 15px;">Executor</a> <a href="/tags/ExecutorService/" style="font-size: 15px;">ExecutorService</a> <a href="/tags/CompletionService/" style="font-size: 15px;">CompletionService</a> <a href="/tags/ThreadPoolExecutor/" style="font-size: 15px;">ThreadPoolExecutor</a> <a href="/tags/vim/" style="font-size: 15px;">vim</a> <a href="/tags/vundle/" style="font-size: 15px;">vundle</a> <a href="/tags/ArrayList/" style="font-size: 15px;">ArrayList</a> <a href="/tags/log/" style="font-size: 15px;">log</a> <a href="/tags/index/" style="font-size: 15px;">index</a> <a href="/tags/concepts/" style="font-size: 15px;">concepts</a> <a href="/tags/Timer/" style="font-size: 15px;">Timer</a> <a href="/tags/TimerTask/" style="font-size: 15px;">TimerTask</a> <a href="/tags/ConcurrentMap/" style="font-size: 15px;">ConcurrentMap</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 15px;">ConcurrentHashMap</a> <a href="/tags/HashMap/" style="font-size: 15px;">HashMap</a> <a href="/tags/ReentrantReadWriteLock/" style="font-size: 15px;">ReentrantReadWriteLock</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/SynchronousQueue/" style="font-size: 15px;">SynchronousQueue</a> <a href="/tags/ScheduledExecutorService/" style="font-size: 15px;">ScheduledExecutorService</a> <a href="/tags/AQS/" style="font-size: 15px;">AQS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/BigData-docker/">Windows 上安装 docker</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/mysql-0.路线/">Mysql学习路线</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/mysql-索引/">Mysql安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/Qunar基础框架-QSchedule/">Qunar基础框架-QSchedule</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/java集合构架中使用到的数据结构和算法/">java集合构架中使用到的数据结构和算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/20/reids-调试环境搭建/">redis-调试环境搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/31/OpenStack-安装/">OpenStack-安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/26/JVM-hotspot-GC机制/">JVM-hotspot-GC机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/11/netty-socketio + socket.io 实现消息推送/">netty-socketio + socket.io 实现消息推送</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/26/mongodb-安装/">mongodb-安装</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/a-ray-of-sunshine" title="github" target="_blank">github</a><ul></ul><a href="http://www.cnblogs.com/a-ray-of-sunshine" title="cnblog" target="_blank">cnblog</a><ul></ul><a href="http://blog.csdn.net/a_ray_of_sunshine" title="csdn" target="_blank">csdn</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Shawshank.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>