<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>HashMap | Shawshank</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">HashMap</h1><a id="logo" href="/.">Shawshank</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">HashMap</h1><div class="post-meta">Jul 11, 2016</div><div class="post-content"><h2 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<h2 id="Map-接口"><a href="#Map-接口" class="headerlink" title="Map 接口"></a>Map 接口</h2><ul>
<li><p>map 中不能有相同的key,每一个key最多对应一个value </p>
<p>  An object that maps keys to values. A map cannot contain duplicate keys; each key can map to at most one value.</p>
</li>
<li><p>map 接口提供了三个Collection视图，分别是： keys, values, entrys</p>
<p>  The Map interface provides three collection views, which allow a map’s contents to be viewed as a set of keys, collection of values, or set of key-value mappings. </p>
</li>
<li><p><strong>当可变对象(mutable object)做key时需要注意</strong></p>
<p>  great care must be exercised if mutable objects are used as map keys. The behavior of a map is not specified if the value of an object is changed in a manner that affects equals comparisons while the object is a key in the map. </p>
</li>
</ul>
<h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><ul>
<li><p>EMPTY_TABLE: An empty table instance to share when the table is not inflated.</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>table: The table, resized as necessary. Length MUST Always be a power of two.</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br></pre></td></tr></table></figure>
</li>
<li><p>size: The number of key-value mappings contained in this map.</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>
</li>
<li><p>threshold: 阈值 The next size value at which to resize (capacity * load factor).</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> threshold;</span><br></pre></td></tr></table></figure>
</li>
<li><p>loadFactor: 负载因子 The load factor for the hash table.</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>
</li>
<li><p>capacity: 容量 The length of the table</p>
<p>  就是 table 数组的长度。这个 table 数组并不会完全存储完，而是达到 threshold 之后，重新分配。</p>
</li>
</ul>
<h2 id="HashMap-的构造函数"><a href="#HashMap-的构造函数" class="headerlink" title="HashMap 的构造函数"></a>HashMap 的构造函数</h2><ul>
<li>HashMap(int initialCapacity, float loadFactor)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 MAXIMUM_CAPACITY 是 1 &gt;&gt; 30, 也就是 2 的 30 次方。</p>
<p>无参数的构造函数，使用默认的 loadFactor 和 initialCapacity，分别是 DEFAULT_INITIAL_CAPACITY： 16，DEFAULT_LOAD_FACTOR：0.75f</p>
<ul>
<li>public HashMap(Map&lt;? extends K, ? extends V&gt; m) </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>,</span><br><span class="line">                  DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span><br><span class="line">    inflateTable(threshold);</span><br><span class="line"></span><br><span class="line">    putAllForCreate(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用已有的Map来初始化当前的对象，其中的 inflateTable 方法，用来分配当前table的空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">      <span class="comment">// 将 threshold 调整到 capacity</span></span><br><span class="line">      <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重设阈值</span></span><br><span class="line">      threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 创建 capacity 大小的 Entry 数组。</span></span><br><span class="line">      table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">      <span class="comment">// 初始化 hash 掩码（mark）值: hashSeed</span></span><br><span class="line">      initHashSeedAsNeeded(capacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>所以当使用默认的参数初始化HashMap后，HashMap，内部的状态是：</p>
<p>loadFactor: 0.75</p>
<p>threashold: 16 * 0.75 = 12</p>
<p>table = new Entry[16]</p>
<p>capacity = table.length = 16</p>
<p>size = 0</p>
<h2 id="HashMap-的-put-元素的过程中使用的关键方法"><a href="#HashMap-的-put-元素的过程中使用的关键方法" class="headerlink" title="HashMap 的 put 元素的过程中使用的关键方法"></a>HashMap 的 put 元素的过程中使用的关键方法</h2><h3 id="public-V-put-K-key-V-value-方法"><a href="#public-V-put-K-key-V-value-方法" class="headerlink" title="public V put(K key, V value) 方法"></a>public V put(K key, V value) 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">          inflateTable(threshold);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">      <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">      <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 查找 key 是否在 table[i] 这个 entry 链</span></span><br><span class="line">      <span class="comment">// 上存在，如果存在，则直接进行替换。</span></span><br><span class="line">      <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">          Object k;</span><br><span class="line">          <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">              V oldValue = e.value;</span><br><span class="line">              e.value = value;</span><br><span class="line">              e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">              <span class="keyword">return</span> oldValue;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码执行到这里说明，key 在 table[i]中</span></span><br><span class="line"><span class="comment">// 并不存在，所以，进行添加操作</span></span><br><span class="line">      modCount++;</span><br><span class="line">      addEntry(hash, key, value, i);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>上面put过程中比较关键的几个方法：</p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>根据 key 值，计算 key 的 hashCode.</p>
<h3 id="indexFor"><a href="#indexFor" class="headerlink" title="indexFor"></a>indexFor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意： h &amp; (length-1) &lt;= (length-1) </p>
<h3 id="addEntry"><a href="#addEntry" class="headerlink" title="addEntry"></a>addEntry</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 对 table 进行 resize 的条件：size 超过 阈值 并且 table 中的 bucketIndex entry 已经被使用过</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// 对 table 进行 resize</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 由于进行了 resize, 所以要对 hash和index</span></span><br><span class="line">        <span class="comment">// 重新进行计算</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">// 如果当前的容量已经到上限，</span></span><br><span class="line">    <span class="comment">// 则调整阈值成最大值，后直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重新计算 hashSeed,然后，对当前的 table 的</span></span><br><span class="line">    <span class="comment">// Entry 重新进行 hash 散列，放置到新的 table 中</span></span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调整 table</span></span><br><span class="line">    table = newTable;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调整 阈值</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            <span class="comment">// newTable[i] 处的 Entry，放置到新的 Entry的后部，</span></span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            <span class="comment">// 当前新的 Entry ，放到队头。</span></span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个过程，将原来table中的Entry，重新进行了 散列，分布到 newTable 中。</p>
<h3 id="createEntry"><a href="#createEntry" class="headerlink" title="createEntry"></a>createEntry</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 获得位置为 bucketIndex 处的链表头部的Entry</span></span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将头部的Entry置为新插入的Entry。</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HashMap-的-get-过程"><a href="#HashMap-的-get-过程" class="headerlink" title="HashMap 的 get 过程"></a>HashMap 的 get 过程</h2><p>根据 key 计算出 Entry 在 table 中索引，然后循环，Entry链表，找到 key 所对应的 value.</p>
<p>详见： java.util.HashMap.getEntry(Object key)</p>
<h2 id="HashMap-的-remove-过程"><a href="#HashMap-的-remove-过程" class="headerlink" title="HashMap 的 remove 过程"></a>HashMap 的 remove 过程</h2><p>根据 key 计算出 Entry 在 table 中索引，然后循环，Entry链表，找到 key 所对应的 Entry, 然后将这个Entry的 prev Entry 的 next 值，指向，当前 Entry的next,这样就完成了将 当前 Entry 从list 移除的动作。</p>
<h2 id="HashMap-的-clear-过程"><a href="#HashMap-的-clear-过程" class="headerlink" title="HashMap 的 clear 过程"></a>HashMap 的 clear 过程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    Arrays.fill(table, <span class="keyword">null</span>);</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<p>详见： java.util.HashMap.removeEntryForKey(Object key)</p>
<h2 id="hashSeed-和-hash-方法"><a href="#hashSeed-和-hash-方法" class="headerlink" title="hashSeed 和 hash 方法"></a>hashSeed 和 hash 方法</h2><h2 id="java-util-HashMap-Entry-lt-K-V-gt"><a href="#java-util-HashMap-Entry-lt-K-V-gt" class="headerlink" title="java.util.HashMap.Entry&lt;K, V&gt;"></a>java.util.HashMap.Entry&lt;K, V&gt;</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个类有四个字段：</p>
<pre><code>final K key;
V value;
Entry&lt;K,V&gt; next;
int hash;
</code></pre><h2 id="和-gt-gt-gt-运算"><a href="#和-gt-gt-gt-运算" class="headerlink" title="^ 和 &gt;&gt;&gt; 运算"></a>^ 和 &gt;&gt;&gt; 运算</h2><ul>
<li><p>^ 按位异或操作符</p>
<p>  按位异或操作符，两个操作数的某一位不相同时候结果的该位就为1。</p>
</li>
<li><p>‘&gt;&gt;&gt;’按位右移补零操作符</p>
<p>  按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。</p>
</li>
</ul>
<h2 id="HashMap-的三个-Collection-视图"><a href="#HashMap-的三个-Collection-视图" class="headerlink" title="HashMap 的三个 Collection 视图"></a>HashMap 的三个 Collection 视图</h2><ul>
<li><p>values</p>
<p>  这个 values 是一个继承了AbstractCollection的类。这个类不支持 add 操作，如果调用这个视图的 add, addAll 方法，将会抛出 UnsupportedOperationException 异常。但是它支持：    Iterator.remove, Collection.remove, removeAll, retainAll and clear operations</p>
</li>
<li><p>keySet</p>
<p>  同上，不支持 add, addAll。 但是它 支持：Iterator.remove, Set.remove, removeAll, retainAll and clear operations.</p>
</li>
<li><p>entrySet</p>
<p>  同上，不支持 add, addAll。但是它 支持：Iterator.remove, Set.remove, removeAll, retainAll and clear operations.</p>
</li>
</ul>
<p>这三个视图所对应的 iterator 都是 fail-fast 的。</p>
<h2 id="HashMap-对-null-的支持"><a href="#HashMap-对-null-的支持" class="headerlink" title="HashMap 对 null 的支持"></a>HashMap 对 null 的支持</h2><p>add: HashMap 支持 key 为 null 的操作，它会将 key 为 null 的 放置到 table[0] 的 Entry 链中，其 hash = 0. </p>
<p>get: 从 table[0]中，获取 key 为 null 的 value.</p>
<h2 id="HashMap-vs-Hashtable"><a href="#HashMap-vs-Hashtable" class="headerlink" title="HashMap vs Hashtable"></a>HashMap vs Hashtable</h2><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>Hashtable 是线程安全的，而 HashMap 是非线程安全的。而 Hashtable 的线程同步实现的非常简洁，对于一般方法直接在方法上使用 synchronized 关键字，来实现同步，其实就是一种粗粒度的同步。在并发状况下使用，性能必然是问题。</p>
<p>而其对应的三个视图的同步，则是通过，Collections 类的同步方法。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (values==<span class="keyword">null</span>)</span><br><span class="line">        values = Collections.synchronizedCollection(<span class="keyword">new</span> ValueCollection(), <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ValueCollection 的实现并不是线程安全的。</p>
<p>keySet 和 entrySet 也是如此。</p>
<p><a href="http://www.cnblogs.com/wuchanming/p/4762390.html" target="_blank" rel="noopener">关于几个Map的线程安全问题</a></p>
<p><a href="http://blog.csdn.net/zhangerqing/article/details/8193118" target="_blank" rel="noopener">HashMap, Hashtable, ConcurrentHashMap 比较</a></p>
<h3 id="hash散列算法"><a href="#hash散列算法" class="headerlink" title="hash散列算法"></a>hash散列算法</h3><ul>
<li><p>Hashtable 使用： 让length为素数，然后用hashCode(key) mod length的方法得到索引</p>
</li>
<li><p>HashMap 使用：让length为2的指数倍，然后用hashCode(key) &amp; (length-1)的方法得到索引</p>
</li>
</ul>
<p><strong>参考：</strong></p>
<p><a href="http://my.oschina.net/u/2400412/blog/506477" target="_blank" rel="noopener">哈希函数的设计原理</a></p>
<p><a href="http://www.vvbin.com/?p=376" target="_blank" rel="noopener">为什么求模运算要用素数（质数）—— 哈希表设计</a></p>
<p><a href="http://planetmath.org/goodhashtableprimes" target="_blank" rel="noopener">good hash table primes</a></p>
<p><a href="http://stackoverflow.com/questions/9335169/understanding-strange-java-hash-function" target="_blank" rel="noopener">Understanding strange Java hash function</a></p>
<p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">数据结构可视化</a></p>
<h3 id="对-key-或-value-为-null-的支持"><a href="#对-key-或-value-为-null-的支持" class="headerlink" title="对 key 或 value 为 null 的支持"></a>对 key 或 value 为 null 的支持</h3><p>Hashtable 不支持 null 的 key 和 value, 在进行 put 操作时，会直接抛出 NullPointerException</p>
<p>HashMap 支持</p>
<p><a href="http://www.codeceo.com/article/java-hashmap-hashtable-differ.html" target="_blank" rel="noopener">HashMap 和 HashTable 比较</a></p>
<h3 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h3><p>HashMap 的 iterator 是 fail-fast 的</p>
<p>Hashtable 的 iterator 的实现类是：java.util.Hashtable.Enumerator<t>， 它除实现接口：java.util.Iterator<t>，还实现也java.util.Enumeration<t>接口。在 Jdk7 中 Enumerator 实现的 iterator 也是 fail-fast 的。貌似在以前的版本中这个 iterator 不是 fail-fast.</t></t></t></p>
<h2 id="其它的-Map-实现"><a href="#其它的-Map-实现" class="headerlink" title="其它的 Map 实现"></a>其它的 Map 实现</h2><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>LinkedHashMap 在主要思路在创建 Entry 的时候，将所有的Entry通过，双向链表，将其串连起来，始终维护一个 header 表示这个链表的头部。每一个 Entry 内部，又多了两个状态，before, after, </p>
<p>那么，这些状态是如何维护的？</p>
<h4 id="header-的初始化"><a href="#header-的初始化" class="headerlink" title="header 的初始化"></a>header 的初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    header = <span class="keyword">new</span> Entry&lt;&gt;(-<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    header.before = header.after = header;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LinkedHashMap override 了 init 方法， 初始化了 header, 并将其 before 和 after 都指向自身。</p>
<h4 id="header-链的中元素的的创建"><a href="#header-链的中元素的的创建" class="headerlink" title="header 链的中元素的的创建"></a>header 链的中元素的的创建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, old);</span><br><span class="line">    table[bucketIndex] = e;</span><br><span class="line">    e.addBefore(header);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>addBefore 方法将新创建的 Entry ，加入到 header 链中。</p>
<h4 id="header-链的中元素的删除"><a href="#header-链的中元素的删除" class="headerlink" title="header 链的中元素的删除"></a>header 链的中元素的删除</h4><p>java.util.LinkedHashMap.Entry&lt;K, V&gt; 中的 recordRemoval 方法会在 removeEntryForKey 和 removeMapping 方法中被调用， 所以 recordRemoval 方法会将自身从 header 链中移除。</p>
<h4 id="header-链的的中元素的位置的调整"><a href="#header-链的的中元素的位置的调整" class="headerlink" title="header 链的的中元素的位置的调整"></a>header 链的的中元素的位置的调整</h4><p>依据参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure>
<p>这个参数默认初始化为 false, 它是在 java.util.LinkedHashMap.Entry.recordAccess(HashMap&lt;K, V&gt; m) 被用到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;</span><br><span class="line">    <span class="keyword">if</span> (lm.accessOrder) &#123;</span><br><span class="line">        lm.modCount++;</span><br><span class="line">        remove();</span><br><span class="line">        addBefore(lm.header);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 recordAccess 方法将会在 Map中Entry中被访问时被调用，Map中Entry中被访问的时机有三个: get, put, putForNullKey. 在 HashMap的实现中， put 和 putForNullKey 在 Entry存在的情况下将修改 key 所对应的value值，所以 HashMap 将这和情况定义为对Entry的access, 但是它并没有在 get 方法中调用recordAccess，说明，HashMap的实现，并不认为 get 方法算是 access,</p>
<p>在 LinkedHashMap override 了 get 方法，在其中调用了recordAccess，说明LinkedHashMap的设计，认为 get 也算是对 Entry 的一种 access.</p>
<p>recordAccess的作用是：将最近一次访问的Entry，调整到 header 链的头部。</p>
<h4 id="header-链的使用"><a href="#header-链的使用" class="headerlink" title="header 链的使用"></a>header 链的使用</h4><p>上面的过程完成了 header 链的维护，而 header 链的使用，则是对应于 HashMap的性能优化。 LinkdedHashMap 优化了 两个方法： transfer 和 containsValue， 加速了遍历过程。</p>
<h4 id="LinkedHashMap-vs-HashMap"><a href="#LinkedHashMap-vs-HashMap" class="headerlink" title="LinkedHashMap vs HashMap"></a>LinkedHashMap vs HashMap</h4><p>LinkedHashMap 返回的 iterator 是有序的，其默认顺序元素插入的顺序，也可以是最近访问优先顺序。</p>
<p>HashMap 返回的 iterator 是无序的，这种无序是相对于使用者的操作来说的，例如 iterator 返回的 Entry 并没有和 put get remove 操作发生联系。但是对于 iterator 内部实现来说，其实也是“有序的”，java.util.HashMap.HashIterator 返回 entry 是按照，Entry的逻辑存储结构的顺序来返回的。</p>
<h3 id="java-util-Properties"><a href="#java-util-Properties" class="headerlink" title="java.util.Properties"></a>java.util.Properties</h3><p>这个类是我们常用来解析 properties 文件的类，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Properties</span> <span class="keyword">extends</span> <span class="title">Hashtable</span>&lt;<span class="title">Object</span>,<span class="title">Object</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>它继承自 Hashtable, 这个类是线程安全的，This class is thread-safe: multiple threads can share a single Properties object without the need for external synchronization</p>
<p>Properties 类也可以使用方法 loadFromXML 解析如下格式的 xml文件</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;
&lt;properties&gt;
    &lt;comment&gt;testconfig&lt;/comment&gt;
    &lt;entry key=&quot;hello&quot;&gt;HELLO1&lt;/entry&gt;
    &lt;entry key=&quot;world&quot;&gt;WORLD1&lt;/entry&gt;
&lt;/properties&gt;
</code></pre><h3 id="IdentityHashMap"><a href="#IdentityHashMap" class="headerlink" title="IdentityHashMap"></a>IdentityHashMap</h3><p>This class implements the Map interface with a hash table, using reference-equality in place of object-equality when comparing keys (and values). In other words, in an IdentityHashMap, two keys k1 and k2 are considered equal if and only if </p>
<pre><code>(k1==k2)
</code></pre><p>In normal Map implementations (like HashMap) two keys k1 and k2 are considered equal if and only if </p>
<pre><code>(k1==null ? k2==null : k1.equals(k2))
</code></pre><p>IdentityHashMap有其特殊用途，比如序列化或者深度复制。或者记录对象代理。</p>
<h4 id="存储结构比较"><a href="#存储结构比较" class="headerlink" title="存储结构比较"></a>存储结构比较</h4><p>HashMap 会将相同的 hash 的元素(key-value),存储在hash之后的 table 的 index 位置，以 Entry 链的结构存储起来，而 IdentityHashMap 横向地将，hash相同，而 key 的引用不同的元素（key-value）存储在 hash table 的索引的连续的下一个位置。其计算next index 的方法如下：</p>
<pre><code>return (i + 2 &lt; len ? i + 2 : 0);
</code></pre><p>因为 key 和 value 各占一个slot，所以是 i + 2.</p>
<h3 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h3><p>如果 Map 的 key 值是，固定的 枚举（Enum）类型，则可以考虑使用 EnumMap，它对Map的实现进行了优化。所有的基本操作都是常量时间。key 不能为空，只能是声明的 枚举类型。使用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EnumMap&lt;Book, Integer&gt; eMap = <span class="keyword">new</span> EnumMap&lt;Book, Integer&gt;(Book.class);</span><br><span class="line">eMap.put(Book.Math, <span class="number">99</span>);</span><br><span class="line">eMap.put(Book.English, <span class="number">66</span>);</span><br><span class="line">eMap.put(Book.Music, <span class="number">88</span>);</span><br><span class="line">eMap.put(Book.Music, <span class="number">33</span>);</span><br></pre></td></tr></table></figure>
<p>其中 Book 为 枚举类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Book &#123;</span><br><span class="line">	Math,</span><br><span class="line">	English,</span><br><span class="line">	Music</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Iterators returned by the collection views are weakly consistent: they will never throw ConcurrentModificationException and they may or may not show the effects of any modifications to the map that occur while the iteration is in progress. </p>
<p>EnumMap 返回的 Iterator不是 fail-fast 的。</p>
<h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><p>和 key 的引用类型有关，关于它的使用参考：</p>
<p><a href="http://www.xiaoyaochong.net/wordpress/index.php/2013/08/05/java%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%B8%8Eweakhashmap/" target="_blank" rel="noopener">Java内存泄露与WeakHashMap</a></p>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>内部使用二叉树来存储Entry。 不支持 null 的 key.</p>
<p>TreeMap是有序的</p>
<p><a href="http://www.cnblogs.com/kathyrani/articles/2520709.html" target="_blank" rel="noopener">HashMap、Hashtable、LinkedHashMap、和TreeMap介绍和区别</a></p>
<p>TreeMap 平均时间复杂度 O(log n)</p>
<p>HashMap 平均时间复杂度 O(1)</p>
</div><div class="tags"><a href="/tags/Collection/">Collection</a><a href="/tags/HashMap/">HashMap</a></div><div class="post-nav"><a class="pre" href="/2016/07/13/Queue/">Queue</a><a class="next" href="/2016/07/10/LinkedList/">LinkedList</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/interface/" style="font-size: 15px;">interface</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/Collections/" style="font-size: 15px;">Collections</a> <a href="/tags/Collection/" style="font-size: 15px;">Collection</a> <a href="/tags/J-U-C/" style="font-size: 15px;">J.U.C</a> <a href="/tags/lock/" style="font-size: 15px;">lock</a> <a href="/tags/Semaphore/" style="font-size: 15px;">Semaphore</a> <a href="/tags/CountDownLatch/" style="font-size: 15px;">CountDownLatch</a> <a href="/tags/CyclicBarrier/" style="font-size: 15px;">CyclicBarrier</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/LinkedList/" style="font-size: 15px;">LinkedList</a> <a href="/tags/Queue/" style="font-size: 15px;">Queue</a> <a href="/tags/Set/" style="font-size: 15px;">Set</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/collection/" style="font-size: 15px;">collection</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/api/" style="font-size: 15px;">api</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/mvc/" style="font-size: 15px;">mvc</a> <a href="/tags/context/" style="font-size: 15px;">context</a> <a href="/tags/component-scan/" style="font-size: 15px;">component-scan</a> <a href="/tags/storm/" style="font-size: 15px;">storm</a> <a href="/tags/windows/" style="font-size: 15px;">windows</a> <a href="/tags/命令行/" style="font-size: 15px;">命令行</a> <a href="/tags/cmder/" style="font-size: 15px;">cmder</a> <a href="/tags/win/" style="font-size: 15px;">win</a> <a href="/tags/效率/" style="font-size: 15px;">效率</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/博客/" style="font-size: 15px;">博客</a> <a href="/tags/apache/" style="font-size: 15px;">apache</a> <a href="/tags/extends/" style="font-size: 15px;">extends</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/svn/" style="font-size: 15px;">svn</a> <a href="/tags/BlockingQueue/" style="font-size: 15px;">BlockingQueue</a> <a href="/tags/LinkedBlockingQueue/" style="font-size: 15px;">LinkedBlockingQueue</a> <a href="/tags/PriorityBlockingQueue/" style="font-size: 15px;">PriorityBlockingQueue</a> <a href="/tags/ConcurrentLinkedQueue/" style="font-size: 15px;">ConcurrentLinkedQueue</a> <a href="/tags/CopyOnWriteArrayList/" style="font-size: 15px;">CopyOnWriteArrayList</a> <a href="/tags/接口/" style="font-size: 15px;">接口</a> <a href="/tags/抽象类/" style="font-size: 15px;">抽象类</a> <a href="/tags/Executor/" style="font-size: 15px;">Executor</a> <a href="/tags/ExecutorService/" style="font-size: 15px;">ExecutorService</a> <a href="/tags/CompletionService/" style="font-size: 15px;">CompletionService</a> <a href="/tags/ThreadPoolExecutor/" style="font-size: 15px;">ThreadPoolExecutor</a> <a href="/tags/vim/" style="font-size: 15px;">vim</a> <a href="/tags/vundle/" style="font-size: 15px;">vundle</a> <a href="/tags/ArrayList/" style="font-size: 15px;">ArrayList</a> <a href="/tags/log/" style="font-size: 15px;">log</a> <a href="/tags/index/" style="font-size: 15px;">index</a> <a href="/tags/concepts/" style="font-size: 15px;">concepts</a> <a href="/tags/Timer/" style="font-size: 15px;">Timer</a> <a href="/tags/TimerTask/" style="font-size: 15px;">TimerTask</a> <a href="/tags/ConcurrentMap/" style="font-size: 15px;">ConcurrentMap</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 15px;">ConcurrentHashMap</a> <a href="/tags/HashMap/" style="font-size: 15px;">HashMap</a> <a href="/tags/ReentrantReadWriteLock/" style="font-size: 15px;">ReentrantReadWriteLock</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/SynchronousQueue/" style="font-size: 15px;">SynchronousQueue</a> <a href="/tags/ScheduledExecutorService/" style="font-size: 15px;">ScheduledExecutorService</a> <a href="/tags/AQS/" style="font-size: 15px;">AQS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/BigData-docker/">Windows 上安装 docker</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/mysql-0.路线/">Mysql学习路线</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/mysql-索引/">Mysql安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/Qunar基础框架-QSchedule/">Qunar基础框架-QSchedule</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/java集合构架中使用到的数据结构和算法/">java集合构架中使用到的数据结构和算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/20/reids-调试环境搭建/">redis-调试环境搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/31/OpenStack-安装/">OpenStack-安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/26/JVM-hotspot-GC机制/">JVM-hotspot-GC机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/11/netty-socketio + socket.io 实现消息推送/">netty-socketio + socket.io 实现消息推送</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/26/mongodb-安装/">mongodb-安装</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/a-ray-of-sunshine" title="github" target="_blank">github</a><ul></ul><a href="http://www.cnblogs.com/a-ray-of-sunshine" title="cnblog" target="_blank">cnblog</a><ul></ul><a href="http://blog.csdn.net/a_ray_of_sunshine" title="csdn" target="_blank">csdn</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Shawshank.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>