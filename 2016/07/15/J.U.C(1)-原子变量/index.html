<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>J.U.C(1)-原子变量 | Shawshank</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">J.U.C(1)-原子变量</h1><a id="logo" href="/.">Shawshank</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">J.U.C(1)-原子变量</h1><div class="post-meta">Jul 15, 2016</div><div class="post-content"><h2 id="Atomic操作"><a href="#Atomic操作" class="headerlink" title="Atomic操作"></a>Atomic操作</h2><p>A small toolkit of classes that support lock-free thread-safe programming on single variables.</p>
<p>在 java.util.concurrent.atomic 包中有关于原子操作的类，其分类有：</p>
<h3 id="原子操作单个值"><a href="#原子操作单个值" class="headerlink" title="原子操作单个值"></a>原子操作单个值</h3><p>AtomicInteger 不需要额外的线程同步（例如：synchronized, 或者其它锁），就可以实现：</p>
<p>自增 value.incrementAndGet</p>
<p>自减 value.decrementAndGet</p>
<p>加某个值 AtomicInteger.getAndAdd</p>
<p>这些操作都是线程安全的不需要进行额外的线程同步了。这个类的使用场景是什么？</p>
<p>考虑这样一种情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberHolder</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> messageCount;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一个基于队列的消息处理系统中，有两个线程，一个生产者线程：产生消息，将其放置到 队列 queue 中，一个消费者线程：消费数据，从队列 queue 中获取消息，进行处理。有一个管理线程，进行检测队列queue,当queue中的消息数量达到一定数据的时候，启动另一个消费者线程，从而增强，系统的消息处理能力。此时，就需要一个类似 NumberHolder 的类来维护queue中消息的数量。生产者线程向queue中offer 一个消息时，需要将 NumberHolder 类的 messageCount 进行<br>加1 操作，相反消息者线程，需要进行 减1 操作。由于是两个操作是在两个线程中发生的，所以就必须对 messageCount 进行同步加锁，否则，这个数值在并发的情况下，会出问题。此时就可以使用 AtomicInteger 来代替 int 类型，这样生产者线程和消费者线程 对 messageCount 不需要任何额外的同步，就可以安全的对 messageCount 进行操作。</p>
<h3 id="原子操作数组"><a href="#原子操作数组" class="headerlink" title="原子操作数组"></a>原子操作数组</h3><h3 id="字段修改器"><a href="#字段修改器" class="headerlink" title="字段修改器"></a>字段修改器</h3><p>使用 AtomicIntegerFieldUpdater 可以对类的  public volatile int 的变量进行同步修改</p>
<p>注意，可以修改的变量的声明必须是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> varName;</span><br></pre></td></tr></table></figure>
<h3 id="atomic使用场景"><a href="#atomic使用场景" class="headerlink" title="atomic使用场景"></a>atomic使用场景</h3><p>atomic variables off the same memory semantics as volatile variables, but with additional support for atomic updates — making them ideal for counters, sequence generators, and statistics gathering while offering better scalability than lock-based alternatives.</p>
<p>并发环境下：计数器，序列生成器（web 应用生成数据库的id，多线程惟一），采集统计信息</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>atomic 类继承自 Number，它们并没有继承 wrapper 类，例如： AtomicInteger 并没有继承 Integer，因为 Integer是 immutable,而 AtomicInteger 是 mutable.</p>
<p>atomic 类没有对 hashCode 和 equals 方法进行 override.所以它们也不能当作 HashMap 的 key 来使用。</p>
<p>在线程竞争不是特别高的时候，使用 Atomic 比使用 Lock 更加的好。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>当多个线程访问一个类时，如果不用考虑这些线程在运行时环境下的调度和交替运行，并且不需要额外的同步及在调用方代码不必做其他的协调，这个类的行为仍然是正确的，那么这个类就是线程安全的。</p>
<p>显然只有资源竞争时才会导致线程不安全，因此无状态对象永远是线程安全的。</p>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>原子操作的描述是： 多个线程执行一个操作时，其中任何一个线程要么完全执行完此操作，要么没有执行此操作的任何步骤，那么这个操作就是原子的。</p>
<h2 id="最终一致性-指令重排"><a href="#最终一致性-指令重排" class="headerlink" title="最终一致性 指令重排"></a>最终一致性 指令重排</h2><h2 id="Happens-before-法则"><a href="#Happens-before-法则" class="headerlink" title="Happens-before 法则"></a>Happens-before 法则</h2><h2 id="volatile-语义"><a href="#volatile-语义" class="headerlink" title="volatile 语义"></a>volatile 语义</h2><p><strong>volatile 只能保证内存可见性，而不能保证原子性，所以它并能保证线程安全</strong></p>
<p>volatile相当于synchronized的弱实现，也就是说volatile实现了类似synchronized的语义，却又没有锁机制。它确保对volatile字段的更新以可预见的方式告知其他的线程。</p>
<p>volatile包含以下语义：</p>
<p>（1）Java 存储模型不会对valatile指令的操作进行重排序：这个保证对volatile变量的操作时按照指令的出现顺序执行的。</p>
<p>（2）volatile变量不会被缓存在寄存器中（只有拥有线程可见）或者其他对CPU不可见的地方，每次总是从主存中读取volatile变量的结果。也就是说对于volatile变量的修改，其它线程总是可见的，并且不是使用自己线程栈内部的变量。也就是在happens-before法则中，对一个valatile变量的写操作后，其后的任何读操作理解可见此写操作的结果。</p>
<p>尽管volatile变量的特性不错，但是volatile并不能保证线程安全的，也就是说volatile字段的操作不是原子性的，volatile变量只能保证可见性（一个线程修改后其它线程能够理解看到此变化后的结果），要想保证原子性，目前为止只能加锁！</p>
<p>volatile通常在下面的场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!done)&#123;</span><br><span class="line">    dosomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用 volatile 变量的三个原则：</p>
<ol>
<li><p>写入变量不依赖此变量的值，或者只有一个线程修改此变量</p>
</li>
<li><p>变量的状态不需要与其它变量共同参与不变约束</p>
</li>
<li><p>访问变量不需要加锁</p>
</li>
</ol>
<h2 id="CAS-Compare-and-Swap"><a href="#CAS-Compare-and-Swap" class="headerlink" title="CAS (Compare and Swap)"></a>CAS (Compare and Swap)</h2><p>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中： </p>
<ul>
<li><p>this, valueOffset 确定了内存值V</p>
</li>
<li><p>expect 确定了预期值 A，</p>
</li>
<li><p>update 确定了新值 B</p>
</li>
</ul>
<p>现代的CPU提供了特殊的指令，可以自动更新共享数据，而且能够检测到其他线程的干扰，而 compareAndSet() 就用这些代替了锁定。</p>
<p>整体的过程就是这样子的，利用CPU的CAS指令，同时借助JNI来完成Java的非阻塞算法。其它原子操作都是利用类似的特性完成的。</p>
<p>而整个J.U.C都是建立在CAS之上的，因此对于synchronized阻塞算法，J.U.C在性能上有了很大的提升。</p>
<p>CAS 相关参考：</p>
<p><a href="http://ifeve.com/compare-and-swap/" target="_blank" rel="noopener">Java并发编程之CAS</a></p>
<p><a href="http://flychao88.iteye.com/blog/2269438" target="_blank" rel="noopener">深入理解并发之CompareAndSet(CAS)</a></p>
<p>Implementation of class sun.misc.Unsafe 的c++实现：</p>
<p>openjdk\hotspot\src\share\vm\prims\unsafe.cpp</p>
<p>openjdk\hotspot\src\os_cpu\windows_x86\vm\atomic_windows_x86.inline.hpp</p>
<p><a href="http://blog.csdn.net/chen77716/article/details/6618779" target="_blank" rel="noopener">深入JVM锁机制1-synchronized</a></p>
<p><a href="http://blog.csdn.net/chen77716/article/details/6641477" target="_blank" rel="noopener">深入JVM锁机制2-Lock</a></p>
<p><a href="http://ifeve.com/java-synchronized/" target="_blank" rel="noopener">聊聊并发（二）Java SE1.6中的Synchronized</a></p>
<p><a href="http://www.cnblogs.com/fanzhidongyzby/p/3654855.html" target="_blank" rel="noopener">CPU对原子操作的支持</a></p>
<h2 id="锁的缺点"><a href="#锁的缺点" class="headerlink" title="锁的缺点"></a>锁的缺点</h2><ul>
<li><p>引起的频繁调度</p>
<p>  多个线程请求同一个锁时，得不到锁的线程会被操作系统 suspend,等锁被释放，线程只是被 resume,而不被会立即调度，所以使用锁是非常重量级的。当锁被频繁竞争时，线程调度的压力非常大。</p>
</li>
<li><p>轻量级同步机制 — volatile 变量</p>
<p>  只能实现，内存可见性，不能实现原子性。</p>
</li>
<li><p>锁导致其它等待锁的线程 cann’t make progress.</p>
<p>  引起 priority inversion 问题。高优先级线程 wait 低优先级持有的 lock.如果一个持有 lock 的线程持续阻塞（permanently blocked）, 那么其它等待该 lock 的线程也将 never make progress.</p>
</li>
</ul>
<h2 id="悲观（pessimistic）-和-乐观（optimistic）"><a href="#悲观（pessimistic）-和-乐观（optimistic）" class="headerlink" title="悲观（pessimistic） 和 乐观（optimistic）"></a>悲观（pessimistic） 和 乐观（optimistic）</h2><ul>
<li><p>悲观锁</p>
<p>  线程通过获取锁的方式来确保，在接下来的代码中不会有其它线程对共享变量进行操作</p>
</li>
<li><p>乐观锁</p>
<p>  总是认为可以在没有其它干涉的情况下完成对共享变量的操作（更新）。方法是：当更新的时候，如果发现当前的共享变量已经被其它线程干涉（更新），那么这次操作就算失败，然后重新尝试。</p>
</li>
</ul>
<h3 id="CAS-—-乐观锁的实现"><a href="#CAS-—-乐观锁的实现" class="headerlink" title="CAS — 乐观锁的实现"></a>CAS — 乐观锁的实现</h3><p>CPU对共享变量的并发访问提供了硬件级别的支持，早期的实现有： test-and-set, fetch-and-increment or swap 指令。现代CPU提供了以 原子 形式执行 read-modify-write 操作的 指令（instruction）, 例如： compare-and-swap, load-linked/store-conditional.</p>
<p>大多数处理器使用 compare-and-swap (CAS) instruction.</p>
<p>CAS means “I think V should have the value A; if it does, put B there, otherwise don’t change it but tell me I was wrong.”</p>
<p>CAS addresses the problem of implementing atomic read-modify-write sequences without locking, because it can detect interference(冲突，干涉) from other threads.</p>
<p>CAS 实现了在没有锁的情况下，原子地执行 read-modify-write 操作。</p>
<p>锁机制，涉及 JVM和OS加锁操作，线程调度，上下切换。而CAS不会涉及 JVM code, 系统调用（system call）,和其它调度活动。</p>
<h3 id="CAS-的缺点"><a href="#CAS-的缺点" class="headerlink" title="CAS 的缺点"></a>CAS 的缺点</h3><p>The primary disadvantage of CAS is that it forces the caller to deal with contention(竞争)（通过 循环，重试或者放弃）。whereas locks deal with contention automatically by blocking until the lock is available.</p>
<p>CAS 迫使调用线程必须处理竞争，而 锁机制 则将当前线程阻塞挂起，直到获得锁。</p>
<h3 id="JVM-对-CAS-的支持"><a href="#JVM-对-CAS-的支持" class="headerlink" title="JVM 对 CAS 的支持"></a>JVM 对 CAS 的支持</h3><p>从 java 5.0 开始，JVM 提供了对CAS的支持。对于支持 CAS 的 platform (CPU) ,Java runtime 会 inline them into the appropriate machine instruction. 如果CPU不支持 CAS， 则 JVM 使用 spin lock 来实现 CAS。</p>
<h2 id="非阻塞算法（nonblocking-algorithms）"><a href="#非阻塞算法（nonblocking-algorithms）" class="headerlink" title="非阻塞算法（nonblocking algorithms）"></a>非阻塞算法（nonblocking algorithms）</h2><ul>
<li><p>blocking 阻塞</p>
<p>  基于锁的算法，可能导致阻塞。如果一个线程因为 blocking I/O, 页错误（page fault）,或者其它延迟（例如：网络延迟，甚至网络中断的情况），就会导致其它所有在锁在等待的线程 blocking.</p>
</li>
<li><p>nonblocking 非阻塞</p>
<p>  如果任意一个线程的失败或者挂起，不会导致其它线程的失败或者挂起，则这个算法就是 nonblocking 的。</p>
<p>  非阻塞算法，也不会产生死锁和优先级反转</p>
</li>
<li><p>lock-free 锁自由</p>
<p>  如果在一个算法的每一步中，都有其它的一些线程可以继续执行，则这样的算法称为 lock-free 的</p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/question/27072408" target="_blank" rel="noopener">有什么好的并发书籍推荐？</a></p>
<p><a href="http://www.blogjava.net/xylz/archive/2010/07/08/325587.html" target="_blank" rel="noopener">深入浅出 Java Concurrency</a></p>
<p><a href="http://www.cnblogs.com/leesf456/p/5550473.html" target="_blank" rel="noopener">JUC线程池框架综述</a></p>
<p><a href="http://www.cnblogs.com/chenpi/p/5614290.html" target="_blank" rel="noopener">JAVA并发编程J.U.C学习总结</a></p>
<p><a href="http://blog.csdn.net/column/details/java-concurrent-prog.html" target="_blank" rel="noopener">Java并发编程实战</a></p>
<p><a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/index.html" target="_blank" rel="noopener">concurrency tutorial</a></p>
<p><a href="http://www.infoq.com/cn/author/%E6%96%B9%E8%85%BE%E9%A3%9E" target="_blank" rel="noopener">聊聊并发</a></p>
<p><a href="http://www.infoq.com/cn/articles/A-Post-Apocalyptic-sun.misc.Unsafe-World" target="_blank" rel="noopener">sun.misc.Unsafe的后启示录</a></p>
<p><a href="http://www.ibm.com/developerworks/cn/java/j-jtp06197.html" target="_blank" rel="noopener">正确使用 Volatile 变量</a></p>
</div><div class="tags"><a href="/tags/J-U-C/">J.U.C</a></div><div class="post-nav"><a class="pre" href="/2016/07/18/J.U.C(2)-锁/">J.U.C(2)-锁</a><a class="next" href="/2016/07/15/Collections同步集合方法/">Collections</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/interface/" style="font-size: 15px;">interface</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/Collections/" style="font-size: 15px;">Collections</a> <a href="/tags/Collection/" style="font-size: 15px;">Collection</a> <a href="/tags/J-U-C/" style="font-size: 15px;">J.U.C</a> <a href="/tags/lock/" style="font-size: 15px;">lock</a> <a href="/tags/Semaphore/" style="font-size: 15px;">Semaphore</a> <a href="/tags/CyclicBarrier/" style="font-size: 15px;">CyclicBarrier</a> <a href="/tags/CountDownLatch/" style="font-size: 15px;">CountDownLatch</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/LinkedList/" style="font-size: 15px;">LinkedList</a> <a href="/tags/Queue/" style="font-size: 15px;">Queue</a> <a href="/tags/Set/" style="font-size: 15px;">Set</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/collection/" style="font-size: 15px;">collection</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/api/" style="font-size: 15px;">api</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/mvc/" style="font-size: 15px;">mvc</a> <a href="/tags/context/" style="font-size: 15px;">context</a> <a href="/tags/component-scan/" style="font-size: 15px;">component-scan</a> <a href="/tags/storm/" style="font-size: 15px;">storm</a> <a href="/tags/windows/" style="font-size: 15px;">windows</a> <a href="/tags/命令行/" style="font-size: 15px;">命令行</a> <a href="/tags/cmder/" style="font-size: 15px;">cmder</a> <a href="/tags/win/" style="font-size: 15px;">win</a> <a href="/tags/效率/" style="font-size: 15px;">效率</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/博客/" style="font-size: 15px;">博客</a> <a href="/tags/apache/" style="font-size: 15px;">apache</a> <a href="/tags/extends/" style="font-size: 15px;">extends</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/svn/" style="font-size: 15px;">svn</a> <a href="/tags/BlockingQueue/" style="font-size: 15px;">BlockingQueue</a> <a href="/tags/LinkedBlockingQueue/" style="font-size: 15px;">LinkedBlockingQueue</a> <a href="/tags/PriorityBlockingQueue/" style="font-size: 15px;">PriorityBlockingQueue</a> <a href="/tags/ConcurrentLinkedQueue/" style="font-size: 15px;">ConcurrentLinkedQueue</a> <a href="/tags/CopyOnWriteArrayList/" style="font-size: 15px;">CopyOnWriteArrayList</a> <a href="/tags/接口/" style="font-size: 15px;">接口</a> <a href="/tags/抽象类/" style="font-size: 15px;">抽象类</a> <a href="/tags/Executor/" style="font-size: 15px;">Executor</a> <a href="/tags/ExecutorService/" style="font-size: 15px;">ExecutorService</a> <a href="/tags/CompletionService/" style="font-size: 15px;">CompletionService</a> <a href="/tags/ThreadPoolExecutor/" style="font-size: 15px;">ThreadPoolExecutor</a> <a href="/tags/vim/" style="font-size: 15px;">vim</a> <a href="/tags/vundle/" style="font-size: 15px;">vundle</a> <a href="/tags/ArrayList/" style="font-size: 15px;">ArrayList</a> <a href="/tags/log/" style="font-size: 15px;">log</a> <a href="/tags/index/" style="font-size: 15px;">index</a> <a href="/tags/concepts/" style="font-size: 15px;">concepts</a> <a href="/tags/Timer/" style="font-size: 15px;">Timer</a> <a href="/tags/TimerTask/" style="font-size: 15px;">TimerTask</a> <a href="/tags/ConcurrentMap/" style="font-size: 15px;">ConcurrentMap</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 15px;">ConcurrentHashMap</a> <a href="/tags/HashMap/" style="font-size: 15px;">HashMap</a> <a href="/tags/ReentrantReadWriteLock/" style="font-size: 15px;">ReentrantReadWriteLock</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/SynchronousQueue/" style="font-size: 15px;">SynchronousQueue</a> <a href="/tags/ScheduledExecutorService/" style="font-size: 15px;">ScheduledExecutorService</a> <a href="/tags/AQS/" style="font-size: 15px;">AQS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/BigData-docker/">Windows 上安装 docker</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/mysql-0.路线/">Mysql学习路线</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/mysql-索引/">Mysql安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/Qunar基础框架-QSchedule/">Qunar基础框架-QSchedule</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/java集合构架中使用到的数据结构和算法/">java集合构架中使用到的数据结构和算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/20/reids-调试环境搭建/">redis-调试环境搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/31/OpenStack-安装/">OpenStack-安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/26/JVM-hotspot-GC机制/">JVM-hotspot-GC机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/11/netty-socketio + socket.io 实现消息推送/">netty-socketio + socket.io 实现消息推送</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/26/mongodb-安装/">mongodb-安装</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/a-ray-of-sunshine" title="github" target="_blank">github</a><ul></ul><a href="http://www.cnblogs.com/a-ray-of-sunshine" title="cnblog" target="_blank">cnblog</a><ul></ul><a href="http://blog.csdn.net/a_ray_of_sunshine" title="csdn" target="_blank">csdn</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Shawshank.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>